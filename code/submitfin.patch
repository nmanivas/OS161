diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..72de946 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -114,7 +114,9 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
-	panic("I don't know how to handle this\n");
+	sys_exit(0);
+	//panic("I don't know how to handle this\n");
+	//thread_exit();
 }
 
 /*
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..7d2eb52 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -32,11 +32,14 @@
 #include <kern/syscall.h>
 #include <lib.h>
 #include <mips/trapframe.h>
+#include <addrspace.h>
+#include <copyinout.h>
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
 
 
+
 /*
  * System call dispatcher.
  *
@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
+        int32_t retvalv1 = 0;
+        int64_t retval64;
 	int err;
+        int32_t stackarg1;
 
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
 		err = sys___time((userptr_t)tf->tf_a0,
 				 (userptr_t)tf->tf_a1);
 		break;
+            case SYS_open:
+		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+			       &retval);
+		break;
+	    case SYS_read:
+		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+			       &retval);
+		break;
+	    case SYS_write:
+		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+				&retval);
+		break;
+	    case SYS_close:
+		err = sys_close(tf->tf_a0);
+		break;
+	    case SYS_lseek:
+                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+                                stackarg1, &retval64);
+                retval = retval64 >> 32;
+                retvalv1 = (int) retval64;
+                break;
+	    case SYS_dup2:
+		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+			break;
+	    case SYS_chdir:
+		err = sys_chdir((userptr_t)tf->tf_a0);
+			break;
+	    case SYS___getcwd:
+		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+			break;
+	    case SYS_fork:
+	    	err=0;
+	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+	    	break;
+	    case SYS_execv:
+	    	err=0;
+	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+	    	break;
+	    case SYS_getpid:
+	    	err=0;
+	    	err=sys_getpid(&retval);
+	    	break;
+	    case SYS_waitpid:
+	    	err=0;
+	    	//kprintf("Dispatch:%d",tf->tf_a0);
+	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+	    	//panic("Waitpid over");
+	    	break;
+	    case SYS__exit:
+	    	sys_exit((int)tf->tf_a0);
+	    	break;
+
 
 	    /* Add stuff here */
  
@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
 	else {
 		/* Success. */
 		tf->tf_v0 = retval;
+                tf->tf_v1 = retvalv1;
 		tf->tf_a3 = 0;      /* signal no error */
 	}
 	
@@ -154,8 +214,49 @@ syscall(struct trapframe *tf)
  *
  * Thus, you can trash it and do things another way if you prefer.
  */
-void
-enter_forked_process(struct trapframe *tf)
+//void
+//enter_forked_process(struct trapframe *tf)
+//{
+	//(void)tf;
+//}
+
+void enter_forked_process(void*tf,unsigned long adrspace)
 {
-	(void)tf;
+	//int flag;
+	//tf=(struct trapframe*)tf;
+	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+		//if(flag)
+		//{
+
+			//return flag;
+			//newtf.tf_v0=ENOMEM;
+			//newtf.tf_a3=1;
+		//}
+	curthread->t_addrspace=(struct addrspace*)adrspace;
+	as_activate(curthread->t_addrspace);
+	//tf=(struct trapframe*)tf;
+	struct trapframe newtf;
+	//int flag;
+	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+	//if(flag)
+	//{
+		//newtf.tf_v0=ENOMEM;
+		//newtf.tf_a3=1;
+	//}
+
+	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+	kfree(tf);
+	//tf=NULL;
+	//int flag;
+
+	//curthread->pid=newtf.tf_a0;
+
+
+
+
+
+	newtf.tf_v0=0;
+	newtf.tf_a3=0;
+	newtf.tf_epc+=4;
+	mips_usermode(&newtf);
 }
diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
new file mode 100644
index 0000000..3e8d5b9
--- /dev/null
+++ b/kern/arch/mips/syscall/syscall.c~
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/syscall.h>
+#include <lib.h>
+#include <mips/trapframe.h>
+#include <thread.h>
+#include <current.h>
+#include <syscall.h>
+
+
+/*
+ * System call dispatcher.
+ *
+ * A pointer to the trapframe created during exception entry (in
+ * exception.S) is passed in.
+ *
+ * The calling conventions for syscalls are as follows: Like ordinary
+ * function calls, the first 4 32-bit arguments are passed in the 4
+ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+ * if the first argument is 32-bit and the second is 64-bit, a1 is
+ * unused.
+ *
+ * This much is the same as the calling conventions for ordinary
+ * function calls. In addition, the system call number is passed in
+ * the v0 register.
+ *
+ * On successful return, the return value is passed back in the v0
+ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+ * function call, and additionally the a3 register is also set to 0 to
+ * indicate success.
+ *
+ * On an error return, the error code is passed back in the v0
+ * register, and the a3 register is set to 1 to indicate failure.
+ * (Userlevel code takes care of storing the error code in errno and
+ * returning the value -1 from the actual userlevel syscall function.
+ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+ *
+ * Upon syscall return the program counter stored in the trapframe
+ * must be incremented by one instruction; otherwise the exception
+ * return code will restart the "syscall" instruction and the system
+ * call will repeat forever.
+ *
+ * If you run out of registers (which happens quickly with 64-bit
+ * values) further arguments must be fetched from the user-level
+ * stack, starting at sp+16 to skip over the slots for the
+ * registerized values, with copyin().
+ */
+void
+syscall(struct trapframe *tf)
+{
+	int callno;
+	int32_t retval;
+	int err;
+
+	KASSERT(curthread != NULL);
+	KASSERT(curthread->t_curspl == 0);
+	KASSERT(curthread->t_iplhigh_count == 0);
+
+	callno = tf->tf_v0;
+
+	/*
+	 * Initialize retval to 0. Many of the system calls don't
+	 * really return a value, just 0 for success and -1 on
+	 * error. Since retval is the value returned on success,
+	 * initialize it to 0 by default; thus it's not necessary to
+	 * deal with it except for calls that return other values, 
+	 * like write.
+	 */
+
+	retval = 0;
+
+	switch (callno) {
+	    case SYS_reboot:
+		err = sys_reboot(tf->tf_a0);
+		break;
+
+	    case SYS___time:
+		err = sys___time((userptr_t)tf->tf_a0,
+				 (userptr_t)tf->tf_a1);
+		break;
+		
+	    case SYS_open:
+	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+	    break;
+
+	    /* Add stuff here */
+ 
+	    default:
+		kprintf("Unknown syscall %d\n", callno);
+		err = ENOSYS;
+		break;
+	}
+
+
+	if (err) {
+		/*
+		 * Return the error code. This gets converted at
+		 * userlevel to a return value of -1 and the error
+		 * code in errno.
+		 */
+		tf->tf_v0 = err;
+		tf->tf_a3 = 1;      /* signal an error */
+	}
+	else {
+		/* Success. */
+		tf->tf_v0 = retval;
+		tf->tf_a3 = 0;      /* signal no error */
+	}
+	
+	/*
+	 * Now, advance the program counter, to avoid restarting
+	 * the syscall over and over again.
+	 */
+	
+	tf->tf_epc += 4;
+
+	/* Make sure the syscall code didn't forget to lower spl */
+	KASSERT(curthread->t_curspl == 0);
+	/* ...or leak any spinlocks */
+	KASSERT(curthread->t_iplhigh_count == 0);
+}
+
+/*
+ * Enter user mode for a newly forked process.
+ *
+ * This function is provided as a reminder. You need to write
+ * both it and the code that calls it.
+ *
+ * Thus, you can trash it and do things another way if you prefer.
+ */
+void
+enter_forked_process(struct trapframe *tf)
+{
+	(void)tf;
+}
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..7d5df71 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -367,6 +367,9 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/file_syscalls.c
+file      syscall/file.c
+file	  syscall/proc_sys.c
 
 #
 # Startup and initialization
diff --git a/kern/include/file.h b/kern/include/file.h
new file mode 100644
index 0000000..2c63bc2
--- /dev/null
+++ b/kern/include/file.h
@@ -0,0 +1,59 @@
+/*
+ * Declarations for file handle and file table management.
+ * New for SOL2.
+ */
+
+#ifndef _FILE_H_
+#define _FILE_H_
+
+#include <limits.h>
+
+struct lock;
+struct vnode;
+
+/*** openfile section ***/
+
+/* 
+ * openfile struct 
+ * note that there's not too much to keep track of, since the vnode does most
+ * of that.  note that it does require synchronization, because a single
+ * openfile can be shared between processes (filetable inheritance).
+ */
+struct openfile {
+	struct vnode *of_vnode;
+	
+	struct lock *of_lock;
+	off_t of_offset;
+	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+	int of_refcount;
+};
+
+/* opens a file (must be kernel pointers in the args) */
+int file_open(char *filename, int flags, int mode, int *retfd);
+
+/* closes a file */
+int file_close(int fd);
+
+
+/*** file table section ***/
+
+/*
+ * filetable struct
+ * just an array of open files.  nice and simple.  doesn't require
+ * synchronization, because a table can only be owned by a single process (on
+ * inheritance in fork, the table is copied).
+ */
+struct filetable {
+	struct openfile *ft_openfiles[OPEN_MAX];
+};
+
+/* these all have an implicit arg of the curthread's filetable */
+int filetable_init(const char *inpath, const char *outpath, 
+		   const char *errpath);
+int filetable_copy(struct filetable **copy);
+int filetable_placefile(struct openfile *file, int *fd);
+int filetable_findfile(int fd, struct openfile **file);
+int filetable_dup2file(int oldfd, int newfd);
+void filetable_destroy(struct filetable *ft);
+
+#endif /* _FILE_H_ */
diff --git a/kern/include/limits.h b/kern/include/limits.h
index 01684c4..3a54e24 100644
--- a/kern/include/limits.h
+++ b/kern/include/limits.h
@@ -48,5 +48,6 @@
 #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
 #define OPEN_MAX        __OPEN_MAX
 #define IOV_MAX         __IOV_MAX
+//#define OPEN_MAX        64
 
 #endif /* _LIMITS_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..df9fe64 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,6 +74,11 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+//volatile struct thread *lockNeed;
+        struct spinlock mut_lock;
+        struct wchan *mut_wchan;
+        volatile int hold;
+struct thread *holder;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+        //struct spinlock cv_lock;
+        struct wchan *cv_wchan;
+        //volatile int hold;
+        //struct thread *holder;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+        volatile int res_count;
+        struct wchan *rd_wchan;
+        struct wchan *wr_wchan;
+        struct semaphore *rw_sem;
+        struct lock *rw_lock;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
new file mode 100644
index 0000000..d98aeb7
--- /dev/null
+++ b/kern/include/synch.h~
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SYNCH_H_
+#define _SYNCH_H_
+
+/*
+ * Header file for synchronization primitives.
+ */
+
+
+#include <spinlock.h>
+
+/*
+ * Dijkstra-style semaphore.
+ *
+ * The name field is for easier debugging. A copy of the name is made
+ * internally.
+ */
+struct semaphore {
+        char *sem_name;
+	struct wchan *sem_wchan;
+	struct spinlock sem_lock;
+        volatile int sem_count;
+};
+
+struct semaphore *sem_create(const char *name, int initial_count);
+void sem_destroy(struct semaphore *);
+
+/*
+ * Operations (both atomic):
+ *     P (proberen): decrement count. If the count is 0, block until
+ *                   the count is 1 again before decrementing.
+ *     V (verhogen): increment count.
+ */
+void P(struct semaphore *);
+void V(struct semaphore *);
+
+
+/*
+ * Simple lock for mutual exclusion.
+ *
+ * When the lock is created, no thread should be holding it. Likewise,
+ * when the lock is destroyed, no thread should be holding it.
+ *
+ * The name field is for easier debugging. A copy of the name is
+ * (should be) made internally.
+ */
+struct lock {
+        char *lk_name;
+//volatile struct thread *lockNeed;
+        struct spinlock mut_lock;
+        struct wchan *mut_wchan;
+        volatile int hold;
+struct thread *holder;
+        // add what you need here
+        // (don't forget to mark things volatile as needed)
+};
+
+struct lock *lock_create(const char *name);
+void lock_acquire(struct lock *);
+
+/*
+ * Operations:
+ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+ *                   same time.
+ *    lock_release - Free the lock. Only the thread holding the lock may do
+ *                   this.
+ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+ *                   false otherwise.
+ *
+ * These operations must be atomic. You get to write them.
+ */
+void lock_release(struct lock *);
+bool lock_do_i_hold(struct lock *);
+void lock_destroy(struct lock *);
+
+
+/*
+ * Condition variable.
+ *
+ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+ * to wait until a variable meets a particular condition, but there's no
+ * actual variable, as such, in the CV.
+ *
+ * These CVs are expected to support Mesa semantics, that is, no
+ * guarantees are made about scheduling.
+ *
+ * The name field is for easier debugging. A copy of the name is
+ * (should be) made internally.
+ */
+
+struct cv {
+        char *cv_name;
+        // add what you need here
+        // (don't forget to mark things volatile as needed)
+};
+
+struct cv *cv_create(const char *name);
+void cv_destroy(struct cv *);
+
+/*
+ * Operations:
+ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+ *                   waking up again, re-acquire the lock.
+ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+ *    cv_broadcast - Wake up all threads sleeping on this CV.
+ *
+ * For all three operations, the current thread must hold the lock passed 
+ * in. Note that under normal circumstances the same lock should be used
+ * on all operations with any particular CV.
+ *
+ * These operations must be atomic. You get to write them.
+ */
+void cv_wait(struct cv *cv, struct lock *lock);
+void cv_signal(struct cv *cv, struct lock *lock);
+void cv_broadcast(struct cv *cv, struct lock *lock);
+
+/*
+ * 13 Feb 2012 : GWA : Reader-writer locks.
+ */
+
+struct rwlock {
+        char *rwlock_name;
+};
+
+struct rwlock * rwlock_create(const char *);
+void rwlock_destroy(struct rwlock *);
+
+void rwlock_acquire_read(struct rwlock *);
+void rwlock_release_read(struct rwlock *);
+void rwlock_acquire_write(struct rwlock *);
+void rwlock_release_write(struct rwlock *);
+
+#endif /* _SYNCH_H_ */
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..ea96700 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -26,6 +26,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
+#include<thread.h>
 
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
  * Support functions.
  */
 
+
 /* Helper for fork(). You write this. */
-void enter_forked_process(struct trapframe *tf);
+void enter_forked_process(void *tf,unsigned long adrspace);
 
 /* Enter user mode. Does not return. */
 void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
  * Prototypes for IN-KERNEL entry points for system call implementations.
  */
 
+int sys_open(userptr_t filename, int flags, int mode, int *retval);
+int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+int sys_close(int fd);
+int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+int sys_dup2(int oldfd, int newfd, int *retval);
+int sys_chdir(userptr_t path);
+int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+int sys_execv(char* progname,char** arguments);
+int sys_getpid(pid_t *retval);
+int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+void sys_exit(int exitcode);
+int mywait(struct process* mypro);
 
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..84f60fc 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -105,7 +105,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname,char** argv,unsigned long argc);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..77a3515 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -73,7 +73,10 @@ struct thread {
 	 */
 	char *t_name;			/* Name of this thread */
 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
-	threadstate_t t_state;		/* State this thread is in */
+	threadstate_t t_state;
+	/* State this thread is in */
+
+	pid_t pid;
 
 	/*
 	 * Thread subsystem internal fields.
@@ -104,7 +107,7 @@ struct thread {
 	/*
 	 * Public fields
 	 */
-
+	struct process* proc;
 	/* VM */
 	struct addrspace *t_addrspace;	/* virtual address space */
 
@@ -112,6 +115,19 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+  struct filetable *t_filetable;
+};
+
+struct process {
+	int full;
+	pid_t pid;
+    pid_t ppid;
+    //struct semaphore* exitsem;
+    struct lock* tlock;
+    struct cv* wcv;
+    bool exited;
+    int exitcode;
+    struct thread* self;
 };
 
 /* Call once during system startup to allocate data structures. */
diff --git a/kern/include/uio.h b/kern/include/uio.h
index 5d97c48..c9124e8 100644
--- a/kern/include/uio.h
+++ b/kern/include/uio.h
@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
 void uio_kinit(struct iovec *, struct uio *,
 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
 
+void uio_uinit(struct iovec *, struct uio *,
+	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+
 
 #endif /* _UIO_H_ */
diff --git a/kern/lib/uio.c b/kern/lib/uio.c
index 594fe96..83ea620 100644
--- a/kern/lib/uio.c
+++ b/kern/lib/uio.c
@@ -153,6 +153,7 @@ void
 uio_kinit(struct iovec *iov, struct uio *u,
 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
 {
+	KASSERT(u);
 	iov->iov_kbase = kbuf;
 	iov->iov_len = len;
 	u->uio_iov = iov;
@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
 	u->uio_rw = rw;
 	u->uio_space = NULL;
 }
+
+void
+uio_uinit(struct iovec *iov, struct uio *u,
+    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+{
+	KASSERT(u);
+	iov->iov_ubase = ubuf;
+	iov->iov_len = len;
+  u->uio_iov = iov;
+	u->uio_iovcnt = 1;
+	u->uio_offset = pos;
+	u->uio_resid = len;
+	u->uio_segflg = UIO_USERSPACE;
+	u->uio_rw = rw;
+	u->uio_space = curthread->t_addrspace;
+}
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..4d8e7e2 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -100,7 +100,7 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
new file mode 100644
index 0000000..4d8e7e2
--- /dev/null
+++ b/kern/startup/main.c~
@@ -0,0 +1,211 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Main.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/reboot.h>
+#include <kern/unistd.h>
+#include <lib.h>
+#include <spl.h>
+#include <clock.h>
+#include <thread.h>
+#include <current.h>
+#include <synch.h>
+#include <vm.h>
+#include <mainbus.h>
+#include <vfs.h>
+#include <device.h>
+#include <syscall.h>
+#include <test.h>
+#include <version.h>
+#include "autoconf.h"  // for pseudoconfig
+
+
+/*
+ * These two pieces of data are maintained by the makefiles and build system.
+ * buildconfig is the name of the config file the kernel was configured with.
+ * buildversion starts at 1 and is incremented every time you link a kernel. 
+ *
+ * The purpose is not to show off how many kernels you've linked, but
+ * to make it easy to make sure that the kernel you just booted is the
+ * same one you just built.
+ */
+extern const int buildversion;
+extern const char buildconfig[];
+
+/*
+ * Copyright message for the OS/161 base code.
+ */
+static const char harvard_copyright[] =
+    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+    "   President and Fellows of Harvard College.  All rights reserved.\n";
+
+
+/*
+ * Initial boot sequence.
+ */
+static
+void
+boot(void)
+{
+	/*
+	 * The order of these is important!
+	 * Don't go changing it without thinking about the consequences.
+	 *
+	 * Among other things, be aware that console output gets
+	 * buffered up at first and does not actually appear until
+	 * mainbus_bootstrap() attaches the console device. This can
+	 * be remarkably confusing if a bug occurs at this point. So
+	 * don't put new code before mainbus_bootstrap if you don't
+	 * absolutely have to.
+	 *
+	 * Also note that the buffer for this is only 1k. If you
+	 * overflow it, the system will crash without printing
+	 * anything at all. You can make it larger though (it's in
+	 * dev/generic/console.c).
+	 */
+
+	kprintf("\n");
+	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+	kprintf("%s", harvard_copyright);
+	kprintf("\n");
+
+	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+		GROUP_VERSION, buildconfig, buildversion);
+	kprintf("\n");
+
+	/* Early initialization. */
+	ram_bootstrap();
+	thread_bootstrap();
+	hardclock_bootstrap();
+	vfs_bootstrap();
+
+	/* Probe and initialize devices. Interrupts should come on. */
+	kprintf("Device probe...\n");
+	KASSERT(curthread->t_curspl > 0);
+	mainbus_bootstrap();
+	KASSERT(curthread->t_curspl == 0);
+	/* Now do pseudo-devices. */
+	pseudoconfig();
+	kprintf("\n");
+
+	/* Late phase of initialization. */
+	vm_bootstrap();
+	kprintf_bootstrap();
+	thread_start_cpus();
+
+	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+	vfs_setbootfs("emu0");
+
+
+	/*
+	 * Make sure various things aren't screwed up.
+	 */
+	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+}
+
+/*
+ * Shutdown sequence. Opposite to boot().
+ */
+static
+void
+shutdown(void)
+{
+
+	kprintf("Shutting down.\n");
+	
+	vfs_clearbootfs();
+	vfs_clearcurdir();
+	vfs_unmountall();
+
+	thread_shutdown();
+
+	splhigh();
+}
+
+/*****************************************/
+
+/*
+ * reboot() system call.
+ *
+ * Note: this is here because it's directly related to the code above,
+ * not because this is where system call code should go. Other syscall
+ * code should probably live in the "syscall" directory.
+ */
+int
+sys_reboot(int code)
+{
+	switch (code) {
+	    case RB_REBOOT:
+	    case RB_HALT:
+	    case RB_POWEROFF:
+		break;
+	    default:
+		return EINVAL;
+	}
+
+	shutdown();
+
+	switch (code) {
+	    case RB_HALT:
+		kprintf("The system is halted.\n");
+		mainbus_halt();
+		break;
+	    case RB_REBOOT:
+		kprintf("Rebooting...\n");
+		mainbus_reboot();
+		break;
+	    case RB_POWEROFF:
+		kprintf("The system is halted.\n");
+		mainbus_poweroff();
+		break;
+	}
+
+	panic("reboot operation failed\n");
+	return 0;
+}
+
+/*
+ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+ * request, and then shut down.
+ */
+void
+kmain(char *arguments)
+{
+	boot();
+
+	menu(arguments);
+
+	/* Should not get here */
+}
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..8cfaa94 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -40,9 +40,13 @@
 #include <sfs.h>
 #include <syscall.h>
 #include <test.h>
+#include<thread.h>
+#include<synch.h>
 #include "opt-synchprobs.h"
 #include "opt-sfs.h"
 #include "opt-net.h"
+#include <copyinout.h>
+//#include "proc_sys.c"
 
 /*
  * In-kernel menu and command dispatcher.
@@ -51,6 +55,7 @@
 #define _PATH_SHELL "/bin/sh"
 
 #define MAXMENUARGS  16
+extern struct process* p_table[17];
 
 // XXX this should not be in this file
 void
@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	result = runprogram(progname,args,nargs);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
@@ -127,6 +132,8 @@ int
 common_prog(int nargs, char **args)
 {
 	int result;
+	struct thread* fthread;
+	//int err;
 
 #if OPT_SYNCHPROBS
 	kprintf("Warning: this probably won't work with a "
@@ -136,7 +143,34 @@ common_prog(int nargs, char **args)
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&fthread);
+	//fthread->
+	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+	if(fthread->proc==NULL)
+		return ENOMEM;
+
+	fthread->pid=PID_MIN;
+	fthread->proc->pid=PID_MIN;
+
+	fthread->proc->self=fthread;
+	fthread->proc->wcv=cv_create("First CV");
+	if(fthread->proc->wcv==NULL)
+		return ENOMEM;
+	fthread->proc->tlock=lock_create("First Lock");
+	if(fthread->proc->tlock==NULL)
+		return ENOMEM;
+	p_table[0]=fthread->proc;
+
+	lock_acquire(p_table[0]->tlock);
+	mywait(p_table[0]);
+	lock_release(p_table[0]->tlock);
+
+	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+
+	//fthread->proc->
+	//while(!p_table[0]->exited)
+
+
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..6c0bb3f 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -43,11 +43,25 @@
  * You should implement your solution to the whalemating problem below.
  */
 
+
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
-// the top of the corresponding driver code.
+// the top of the corresponding driver code
+
+struct semaphore *male_sem;
+struct semaphore *female_sem;
+struct lock *hold;
+struct cv* mate_cv;
+volatile int male_count;
+volatile int female_count;
 
 void whalemating_init() {
+ hold=lock_create("My lock");
+ male_sem=sem_create("Male Semaphore",0);
+ female_sem=sem_create("Female Semaphore",0);
+mate_cv=cv_create("mating cv");
+male_count=0;
+female_count=0;
   return;
 }
 
@@ -55,6 +69,11 @@ void whalemating_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+
+	sem_destroy(male_sem);
+	sem_destroy(female_sem);
+	lock_destroy(hold);
+	cv_destroy(mate_cv);
   return;
 }
 
@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
   (void)which;
   
   male_start();
+
+  lock_acquire(hold);
+
+  V(male_sem);
+  male_count++;
+  if(female_count!=0)
+  cv_signal(mate_cv,hold);
+  else
+	  cv_wait(mate_cv,hold);
+  lock_release(hold);
+
 	// Implement this function 
   male_end();
 
@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
   (void)which;
   
   female_start();
+  lock_acquire(hold);
+   V(female_sem);
+   female_count++;
+   if(male_count!=0)
+   cv_signal(mate_cv,hold);
+   else
+	   cv_wait(mate_cv,hold);
+  lock_release(hold);
 	// Implement this function 
   female_end();
-  
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
   (void)which;
   
   matchmaker_start();
+  lock_acquire(hold);
+ P(male_sem);
+ male_count--;
+ lock_release(hold);
+ lock_acquire(hold);
+  P(female_sem);
+  female_count--;
+  lock_release(hold);
 	// Implement this function 
   matchmaker_end();
-  
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
+
+
 /*
  * You should implement your solution to the stoplight problem below. The
  * quadrant and direction mappings for reference: (although the problem is,
@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+struct lock* intersect_lock;
+struct cv* intersect_cv;
+volatile int cur_poss[4];// an array to store the possible positions of the car
+//currently
 
 void stoplight_init() {
+	intersect_cv=cv_create("Intersection Condition Variable");
+	if(intersect_cv==NULL)
+	{
+		///return NULL;
+		panic("condition variable not created");
+	}
+	intersect_lock=lock_create("A lock on the intersection");
+	if(intersect_lock==NULL)
+	{
+		//return NULL;
+		panic("Lock could not be created");
+	}
+	
+	
   return;
 }
 
@@ -145,6 +210,8 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
+	cv_destroy(intersect_cv);
+	lock_destroy(intersect_lock);
   return;
 }
 
@@ -152,8 +219,29 @@ void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
+  //(void)direction;
+	int sec_quad=(direction+3)%4;
+	lock_acquire(intersect_lock);
+	// So while any of the two possible quadrants are already set, It means some 
+	//thread is waiting...Hopefully
+	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+		cv_wait(intersect_cv,intersect_lock);
+	cur_poss[direction]=1;
+	cur_poss[sec_quad]=1;
+	inQuadrant(direction);
+	lock_release(intersect_lock);
+	lock_acquire(intersect_lock);
+    cur_poss[direction]=0;
+    //while(curr_p)
+    //cv_broadcast(intersect_cv);
+    inQuadrant(sec_quad);
+    cv_broadcast(intersect_cv,intersect_lock);
+    lock_release(intersect_lock);
+    lock_acquire(intersect_lock);
+    cur_poss[sec_quad]=0;
+    leaveIntersection();
+    cv_broadcast(intersect_cv,intersect_lock);
+    lock_release(intersect_lock);
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+  int sec_quad=(direction+3)%4;
+  int third_quad=(direction+2)%4;
+  lock_acquire(intersect_lock);
+  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+	  cv_wait(intersect_cv,intersect_lock);
+  cur_poss[direction]=1;
+  cur_poss[sec_quad]=1;
+  inQuadrant(direction);
+  lock_release(intersect_lock);
+  lock_acquire(intersect_lock);
+  cur_poss[direction]=0;
   
+  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+  //cv_wait(intersect_cv,intersect_lock);
+      cur_poss[third_quad]=1;
+      //while(curr_p)
+      //cv_broadcast(intersect_cv);
+      inQuadrant(sec_quad);
+      cv_broadcast(intersect_cv,intersect_lock);
+      lock_release(intersect_lock);
+        lock_acquire(intersect_lock);
+            //currposs[direction]=0;
+            cur_poss[sec_quad]=0;
+            //while(curr_p)
+            //cv_broadcast(intersect_cv);
+            inQuadrant(third_quad);
+            cv_broadcast(intersect_cv,intersect_lock);
+                //cur_poss[third_quad]=0;
+            lock_release(intersect_lock);
+              lock_acquire(intersect_lock);
+                leaveIntersection();
+                cur_poss[third_quad]=0;
+                cv_broadcast(intersect_cv,intersect_lock);
+                lock_release(intersect_lock);
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
-
+  // Easy coz the vehicle is in same lane!!
+  lock_acquire(intersect_lock);
+  while(cur_poss[direction]==1)
+	  cv_wait(intersect_cv,intersect_lock);
+  cur_poss[direction]=1;
+  inQuadrant(direction);
+  lock_release(intersect_lock);
+    lock_acquire(intersect_lock);
+  leaveIntersection();
+  cur_poss[direction]=0;
+  cv_broadcast(intersect_cv,intersect_lock);
+  lock_release(intersect_lock);
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
diff --git a/kern/syscall/file.c b/kern/syscall/file.c
new file mode 100644
index 0000000..dc5ffe5
--- /dev/null
+++ b/kern/syscall/file.c
@@ -0,0 +1,341 @@
+/*
+ * File handles and file tables.
+ * New for SOL2.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/limits.h>
+#include <kern/stat.h>
+#include <kern/unistd.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <synch.h>
+#include <uio.h>
+#include <thread.h>
+#include <current.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <file.h>
+#include <syscall.h>
+
+/*** openfile functions ***/
+
+/*
+ * file_open
+ * opens a file, places it in the filetable, sets RETFD to the file
+ * descriptor. the pointer arguments must be kernel pointers.
+ * NOTE -- the passed in filename must be a mutable string.
+ */
+int
+file_open(char *filename, int flags, int mode, int *retfd)
+{
+	struct vnode *vn;
+	struct openfile *file;
+	int result;
+	
+	result = vfs_open(filename, flags, mode, &vn);
+	if (result) {
+		return result;
+	}
+
+	file = kmalloc(sizeof(struct openfile));
+	if (file == NULL) {
+		vfs_close(vn);
+		return ENOMEM;
+	}
+
+	/* initialize the file struct */
+	file->of_lock = lock_create("file lock");
+	if (file->of_lock == NULL) {
+		vfs_close(vn);
+		kfree(file);
+		return ENOMEM;
+	}
+	file->of_vnode = vn;
+	file->of_offset = 0;
+	file->of_accmode = flags & O_ACCMODE;
+	file->of_refcount = 1;
+
+	/* vfs_open checks for invalid access modes */
+	KASSERT(file->of_accmode==O_RDONLY ||
+	        file->of_accmode==O_WRONLY ||
+	        file->of_accmode==O_RDWR);
+
+	/* place the file in the filetable, getting the file descriptor */
+	result = filetable_placefile(file, retfd);
+	if (result) {
+		lock_destroy(file->of_lock);
+		kfree(file);
+		vfs_close(vn);
+		return result;
+	}
+
+	return 0;
+}
+
+/*
+ * file_doclose
+ * shared code for file_close and filetable_destroy
+ */
+static
+int
+file_doclose(struct openfile *file)
+{
+	lock_acquire(file->of_lock);
+
+	/* if this is the last close of this file, free it up */
+	if (file->of_refcount == 1) {
+		vfs_close(file->of_vnode);
+		lock_release(file->of_lock);
+		lock_destroy(file->of_lock);
+		kfree(file);
+	}
+	else {
+		KASSERT(file->of_refcount > 1);
+		file->of_refcount--;
+		lock_release(file->of_lock);
+	}
+
+	return 0;
+}
+
+/* 
+ * file_close
+ * knock off the refcount, freeing the memory if it goes to 0.
+ */
+int
+file_close(int fd)
+{
+	struct openfile *file;
+	int result;
+
+	/* find the file in the filetable */
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	result = file_doclose(file);
+	if (result) {
+		/* leave file open for possible retry */
+		return result;
+	}
+	curthread->t_filetable->ft_openfiles[fd] = NULL;
+
+	return 0;
+}
+
+/*** filetable functions ***/
+
+/* 
+ * filetable_init
+ * pretty straightforward -- allocate the space, initialize to NULL.
+ * note that the one careful thing is to open the std i/o in order to
+ * get
+ * stdin  == 0
+ * stdout == 1
+ * stderr == 2
+ */
+int
+filetable_init(const char *inpath, const char *outpath, const char *errpath)
+{
+	/* the filenames come from the kernel; assume reasonable length */
+	char path[32];
+	int result;
+	int fd;
+
+	/* make sure we can fit these */
+	KASSERT(strlen(inpath) < sizeof(path));
+	KASSERT(strlen(outpath) < sizeof(path));
+	KASSERT(strlen(errpath) < sizeof(path));
+	
+	/* catch memory leaks, repeated calls */
+	KASSERT(curthread->t_filetable == NULL);
+
+	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+	if (curthread->t_filetable == NULL) {
+		return ENOMEM;
+	}
+	
+	/* NULL-out the table */
+	for (fd = 0; fd < OPEN_MAX; fd++) {
+		curthread->t_filetable->ft_openfiles[fd] = NULL;
+	}
+
+	/*
+	 * open the std fds.  note that the names must be copied into
+	 * the path buffer so that they're mutable.
+	 */
+	strcpy(path, inpath);
+	result = file_open(path, O_RDONLY, 0, &fd);
+	if (result) {
+		return result;
+	}
+
+	strcpy(path, outpath);
+	result = file_open(path, O_WRONLY, 0, &fd);
+	if (result) {
+		return result;
+	}
+
+	strcpy(path, errpath);
+	result = file_open(path, O_WRONLY, 0, &fd);
+	if (result) {
+		return result;
+	}
+
+	return 0;
+}
+
+/*
+ * filetable_copy
+ * again, pretty straightforward.  the subtle business here is that instead of
+ * copying the openfile structure, we just increment the refcount.  this means
+ * that openfile structs will, in fact, be shared between processes, as in
+ * Unix.
+ */
+int
+filetable_copy(struct filetable **copy)
+{
+	struct filetable *ft = curthread->t_filetable;
+	int fd;
+
+	/* waste of a call, really */
+	if (ft == NULL) {
+		*copy = NULL;
+		return 0;
+	}
+	
+	*copy = kmalloc(sizeof(struct filetable));
+	
+	if (*copy == NULL) {
+		return ENOMEM;
+	}
+
+	/* copy over the entries */
+	for (fd = 0; fd < OPEN_MAX; fd++) {
+		if (ft->ft_openfiles[fd] != NULL) {
+			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+			ft->ft_openfiles[fd]->of_refcount++;
+			lock_release(ft->ft_openfiles[fd]->of_lock);
+			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+		} 
+		else {
+			(*copy)->ft_openfiles[fd] = NULL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * filetable_destroy
+ * closes the files in the file table, frees the table.
+ */
+void
+filetable_destroy(struct filetable *ft)
+{
+	int fd, result;
+
+	KASSERT(ft != NULL);
+
+	for (fd = 0; fd < OPEN_MAX; fd++) {
+		if (ft->ft_openfiles[fd]) {
+			result = file_doclose(ft->ft_openfiles[fd]);
+			KASSERT(result==0);
+		}
+	}
+	
+	kfree(ft);
+}	
+
+/* 
+ * filetable_placefile
+ * finds the smallest available file descriptor, places the file at the point,
+ * sets FD to it.
+ */
+int
+filetable_placefile(struct openfile *file, int *fd)
+{
+	struct filetable *ft = curthread->t_filetable;
+	int i;
+	
+	for (i = 0; i < OPEN_MAX; i++) {
+		if (ft->ft_openfiles[i] == NULL) {
+			ft->ft_openfiles[i] = file;
+			*fd = i;
+			return 0;
+		}
+	}
+
+	return EMFILE;
+}
+
+/*
+ * filetable_findfile
+ * verifies that the file descriptor is valid and actually references an
+ * open file, setting the FILE to the file at that index if it's there.
+ */
+int
+filetable_findfile(int fd, struct openfile **file)
+{
+	struct filetable *ft = curthread->t_filetable;
+
+	if (fd < 0 || fd >= OPEN_MAX) {
+		return EBADF;
+	}
+	
+	*file = ft->ft_openfiles[fd];
+	if (*file == NULL) {
+		return EBADF;
+	}
+
+	return 0;
+}
+
+/*
+ * filetable_dup2file
+ * verifies that both file descriptors are valid, and that the OLDFD is
+ * actually an open file.  then, if the NEWFD is open, it closes it.
+ * finally, it sets the filetable entry at newfd, and ups its refcount.
+ */
+int
+filetable_dup2file(int oldfd, int newfd)
+{
+	struct filetable *ft = curthread->t_filetable;
+	struct openfile *file;
+	int result;
+
+	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+		return EBADF;
+	}
+
+	file = ft->ft_openfiles[oldfd];
+	if (file == NULL) {
+		return EBADF;
+	}
+
+	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+	if (oldfd == newfd) {
+		return 0;
+	}
+
+	/* closes the newfd if it's open */
+	if (ft->ft_openfiles[newfd] != NULL) {
+		result = file_close(newfd);
+		if (result) {
+			return result;
+		}
+	}
+
+	/* up the refcount */
+	lock_acquire(file->of_lock);
+	file->of_refcount++;
+	lock_release(file->of_lock);
+
+	/* doesn't need to be synchronized because it's just changing the ft */
+	ft->ft_openfiles[newfd] = file;
+
+	return 0;
+}
diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
new file mode 100644
index 0000000..8aa024c
--- /dev/null
+++ b/kern/syscall/file_syscalls.c
@@ -0,0 +1,270 @@
+/*
+ * File-related system call implementations.
+ * New for SOL2.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/limits.h>
+#include <kern/stat.h>
+#include <kern/unistd.h>
+#include <kern/fcntl.h>
+#include <kern/seek.h>
+#include <lib.h>
+#include <synch.h>
+#include <uio.h>
+#include <thread.h>
+#include <current.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <file.h>
+#include <syscall.h>
+#include <copyinout.h>
+
+/*
+ * sys_open
+ * just copies in the filename, then passes work to file_open.
+ */
+int
+sys_open(userptr_t filename, int flags, int mode, int *retval)
+{
+	char fname[PATH_MAX];
+	int result;
+
+	result = copyinstr(filename, fname, sizeof(fname), NULL);
+	if (result) {
+		return result;
+	}
+
+	return file_open(fname, flags, mode, retval);
+}
+
+/*
+ * sys_read
+ * translates the fd into its openfile, then calls VOP_READ.
+ */
+int
+sys_read(int fd, userptr_t buf, size_t size, int *retval)
+{
+  struct iovec iov;
+	struct uio useruio;
+	struct openfile *file;
+	int result;
+
+	/* better be a valid file descriptor */
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	lock_acquire(file->of_lock);
+
+	if (file->of_accmode == O_WRONLY) {
+		lock_release(file->of_lock);
+		return EBADF;
+	}
+
+	/* set up a uio with the buffer, its size, and the current offset */
+  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+  
+  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+
+	/* does the read */
+	result = VOP_READ(file->of_vnode, &useruio);
+	if (result) {
+		lock_release(file->of_lock);
+		return result;
+	}
+
+	/* set the offset to the updated offset in the uio */
+	file->of_offset = useruio.uio_offset;
+
+	lock_release(file->of_lock);
+	
+	/*
+	 * The amount read is the size of the buffer originally, minus
+	 * how much is left in it.
+	 */
+	*retval = size - useruio.uio_resid;
+
+	return 0;
+}
+
+/*
+ * sys_write
+ * translates the fd into its openfile, then calls VOP_WRITE.
+ */
+int
+sys_write(int fd, userptr_t buf, size_t size, int *retval)
+{
+  struct iovec iov;
+	struct uio useruio;
+	struct openfile *file;
+	int result;
+
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	lock_acquire(file->of_lock);
+
+	if (file->of_accmode == O_RDONLY) {
+		lock_release(file->of_lock);
+		return EBADF;
+	}
+
+	/* set up a uio with the buffer, its size, and the current offset */
+  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+	
+  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+
+	/* does the write */
+	result = VOP_WRITE(file->of_vnode, &useruio);
+	if (result) {
+		lock_release(file->of_lock);
+		return result;
+	}
+
+	/* set the offset to the updated offset in the uio */
+	file->of_offset = useruio.uio_offset;
+
+	lock_release(file->of_lock);
+
+	/*
+	 * the amount written is the size of the buffer originally,
+	 * minus how much is left in it.
+	 */
+	*retval = size - useruio.uio_resid;
+
+	return 0;
+}
+
+/* 
+ * sys_close
+ * just pass off the work to file_close.
+ */
+int
+sys_close(int fd)
+{
+	return file_close(fd);
+}
+
+/*
+ * sys_lseek
+ * translates the fd into its openfile, then based on the type of seek,
+ * figure out the new offset, try the seek, if that succeeds, update the
+ * openfile.
+ */
+int
+sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+{
+	struct stat info;
+	struct openfile *file;
+	int result;
+
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	lock_acquire(file->of_lock);
+	
+	/* based on the type of seek, set the retval */ 
+	switch (whence) {
+	    case SEEK_SET:
+		*retval = offset;
+		break;
+	    case SEEK_CUR:
+		*retval = file->of_offset + offset;
+		break;
+	    case SEEK_END:
+		result = VOP_STAT(file->of_vnode, &info);
+		if (result) {
+			lock_release(file->of_lock);
+			return result;
+		}
+		*retval = info.st_size + offset;
+		break;
+	    default:
+		lock_release(file->of_lock);
+		return EINVAL;
+	}
+
+	/* try the seek -- if it fails, return */
+	result = VOP_TRYSEEK(file->of_vnode, *retval);
+	if (result) {
+		lock_release(file->of_lock);
+		return result;
+	}
+	
+	/* success -- update the file structure */
+	file->of_offset = *retval;
+
+	lock_release(file->of_lock);
+
+	return 0;
+}
+
+/* 
+ * sys_dup2
+ * just pass the work off to the filetable
+ */
+int
+sys_dup2(int oldfd, int newfd, int *retval)
+{
+	int result;
+
+	result = filetable_dup2file(oldfd, newfd);
+	if (result) {
+		return result;
+	}
+
+	*retval = newfd;
+	return 0;
+}
+
+/* really not "file" calls, per se, but might as well put it here */
+
+/*
+ * sys_chdir
+ * copyin the path and pass it off to vfs.
+ */
+int
+sys_chdir(userptr_t path)
+{
+	char pathbuf[PATH_MAX];
+	int result;
+	
+	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+	if (result) {
+		return result;
+	}
+
+	return vfs_chdir(pathbuf);
+}
+
+/*
+ * sys___getcwd
+ * just use vfs_getcwd.
+ */
+int
+sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+{
+  struct iovec iov;
+	struct uio useruio;
+	int result;
+  
+  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+
+	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+
+	result = vfs_getcwd(&useruio);
+	if (result) {
+		return result;
+	}
+
+	*retval = buflen - useruio.uio_resid;
+
+	return 0;
+}
diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
new file mode 100644
index 0000000..1fdf2c0
--- /dev/null
+++ b/kern/syscall/proc_sys.c
@@ -0,0 +1,498 @@
+/*
+
+ * proc_sys.c
+ *
+ *  Created on: Mar 7, 2014
+ *      Author: trinity
+ */
+
+#include <types.h>
+#include<mips/trapframe.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+#include <test.h>
+#include <file.h>
+#include <synch.h>
+#include<copyinout.h>
+#include <spl.h>
+#include<kern/wait.h>
+
+extern struct process* p_table[17];
+
+//struct cv* wcv;
+
+extern pid_t pidcount;
+int mywait(struct process* mypro) {
+	//lock_acquire(mypro->tlock);
+	while (!mypro->exited) {
+		cv_wait(mypro->wcv, mypro->tlock);
+	}
+	//*status=mypro->exitcode;
+	//lock_release(mypro->tlock);
+	//int test = mypro->exitcode;
+	//test++;
+	return 0;
+}
+
+int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+	(void) adrs;
+	int flag;
+	pid_t childid;
+	struct addrspace *adrcopy;
+	struct trapframe* copyt = (struct trapframe*) kmalloc(sizeof(struct trapframe));
+	if(copyt==NULL)
+		return ENOMEM;
+	bzero(copyt, sizeof(struct trapframe));
+
+	//struct filetable* copyft;
+	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+
+	memcpy(copyt, tf, sizeof(struct trapframe));
+	flag = as_copy(curthread->t_addrspace, &adrcopy);
+	if(flag)
+		return flag;
+	//if(curthread->pid==0)
+	//{
+	//curthread->pid=PID_MIN;
+	//}
+	if (flag) {
+		kfree(copyt);
+		return flag;
+	}
+
+	//we need to allocate pid for our new process
+
+	//pid_t cpid;
+	/*
+	for (childid = 0; childid <= 16; childid++) {
+		if (p_table[childid] == NULL ) {
+			p_table[childid] = (struct process*) kmalloc(
+					sizeof(struct process));
+			if(p_table[childid]==NULL)
+			{
+				return ENOMEM;
+			}
+			p_table[childid]->full = 1;
+			pidcount++;
+			p_table[childid]->pid = pidcount;
+			p_table[childid]->ppid = curthread->pid;
+			//p_table[childid]->exitsem=sem_create("process",0);
+			p_table[childid]->tlock = lock_create("My Lock");
+			if(p_table[childid]==NULL)
+			{
+				return ENOMEM;
+			}
+			p_table[childid]->wcv = cv_create("My CV");
+			if(p_table[childid]==NULL)
+				return ENOMEM;
+			p_table[childid]->self = NULL;
+			break;
+		}
+	}
+	if (childid > PID_MAX) {
+		//retval = 1;
+		return EMPROC;
+	}
+	*/
+	//int i;
+
+	//copyt->tf_a0 = (int) p_table[childid]->pid;
+	//kprintf("Ret:%d\n",copyt->tf_a0);
+	struct thread *new_proc;
+	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+	//int s=splhigh();
+	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+			(unsigned long) adrcopy, &new_proc);
+	//kprintf("Out of thread fork:%d\n",flag);
+	if (flag) {
+		kfree(copyt);
+		as_destroy(adrcopy);
+
+		return flag;
+	}
+
+
+	for (childid = 0; childid <= 16; childid++) {
+			if (p_table[childid] == NULL ) {
+				p_table[childid] = (struct process*) kmalloc(
+						sizeof(struct process));
+				if(p_table[childid]==NULL)
+				{
+					return ENOMEM;
+				}
+				p_table[childid]->full = 1;
+				pidcount++;
+				p_table[childid]->pid = pidcount;
+				p_table[childid]->ppid = curthread->pid;
+				//p_table[childid]->exitsem=sem_create("process",0);
+				p_table[childid]->tlock = lock_create("My Lock");
+				if(p_table[childid]->tlock==NULL)
+				{
+					return ENOMEM;
+				}
+				p_table[childid]->wcv = cv_create("My CV");
+				if(p_table[childid]->wcv==NULL)
+					return ENOMEM;
+				p_table[childid]->self = NULL;
+				break;
+			}
+		}
+		if (childid > PID_MAX) {
+			//*retval = 1;
+			return EMPROC;
+		}
+
+	//new_proc->pid=(pid_t)childid;
+	//new_proc=p_table[childid];
+
+	new_proc->pid = p_table[childid]->pid;
+	new_proc->proc = p_table[childid];
+	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+	//if (new_proc->t_filetable == NULL) {
+	//return ENOMEM;
+	//}
+	p_table[childid]->self = new_proc;
+
+	//new_proc->pid=p_table[childid]->pid;
+	//new_proc->proc->pid=p_table[childid]->pid;
+	//kprintf("Child id in fork: %d\n",new_proc->pid);
+
+	//kprintf("Child id:%d",new_proc->pid);
+	//new_proc->t_filetable->
+	//for(i=0;i<128;i++)
+	//{
+	flag = filetable_copy(&new_proc->t_filetable);
+	//}
+	//splx(s);
+	// kprintf("Fork over!");
+
+	*retval = p_table[childid]->pid;
+	//kprintf("Return val in fork:%d",*retval);
+	return 0;
+
+	//flag=
+	//flag=thread_fork=
+}
+
+int sys_execv(char *progname, char** arguments) {
+
+	int flag;
+	int numargs;
+	int addr;
+	int i;
+	// first we need to copy the program name to the kernel space
+	// then we go for arguments. Path size unknown
+
+	size_t actual_size = 0;
+	char *namedes;
+
+	if (progname == NULL ) {
+		return EFAULT;
+	}
+	if (progname == "") {
+		return EINVAL;
+	}
+
+	namedes = (char*) kmalloc(PATH_MAX);
+	if(namedes==NULL)
+	{
+		return ENOMEM;
+	}
+	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+			&actual_size);
+	if (flag != 0) {
+		kfree(namedes);
+		return flag;
+	}
+	//namedes[actual_size]
+	if (strlen(namedes) == 0) {
+		//*retval=1;
+		return EISDIR;
+	}
+
+	// now we open file using vfs_open. Same as runprogram
+	struct vnode* vn;
+	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+	if (flag) {
+		return flag;
+	}
+	actual_size = 0;
+	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+
+	//char** kargv=(char**)kmalloc(sizeof(char));
+	// get the number of arguments
+	if (arguments == NULL ) {
+		kfree(namedes);
+		return EFAULT;
+	}
+	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+	if (flag) {
+		kfree(namedes);
+		return EFAULT;
+	}
+
+	//check=wthread->exitcode;
+	//err=copyout(&check,(userptr_t)status,sizeof(check));
+	//if(err)
+	//{
+	//	lock_release(p_table[i]->tlock);
+	//return err;
+	//}
+
+	numargs = 0;
+	while (arguments[numargs] != NULL ) {
+		//kprintf("%");
+		numargs = numargs + 1;
+	}
+
+	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+	//int i;
+	for (i = 0; i < numargs; i++) {
+		actual_size = 0;
+		kargv[i] = (char*) kmalloc(PATH_MAX);
+		if(kargv==NULL)
+			return ENOMEM;
+		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+				&actual_size);
+		if (flag) {
+			kfree(kargv);
+			kfree(namedes);
+			return EFAULT;
+		}
+
+	}
+	actual_size = 0;
+
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace == NULL ) {
+		vfs_close(vn);
+		return ENOMEM;
+	}
+
+	vaddr_t entrypoint, stackptr;
+	as_activate(curthread->t_addrspace);
+	flag = load_elf(vn, &entrypoint);
+	if (flag) {
+		// thread_exit destroys curthread->t_addrspace
+		vfs_close(vn);
+		return flag;
+	}
+
+	vfs_close(vn);
+
+	// now set up the user stack with the arguments
+	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (flag) {
+		//thread_exit destroys curthread->t_addrspace
+		return flag;
+	}
+
+	//i=0;
+	vaddr_t stackptrv[numargs + 1];
+	for (i = numargs - 1; i >= 0; i--) {
+		int len = strlen(kargv[i]);
+		int padder=0;
+		len++;// to account for string terminator
+		//if(len%4!=0)
+		padder = len % 4;
+		stackptr =stackptr-( len + (4-padder));
+
+		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+				&actual_size);
+
+		if (flag)
+		{
+			kfree(kargv);
+			kfree(namedes);
+			return flag;
+		}
+
+		stackptrv[i] = stackptr;
+	}
+	stackptrv[numargs] = 0;
+
+	//This copies the actual stack addresses of the arguments
+	//* into the stack. Hopefully.
+
+	 for(i = numargs; i >= 0; i--)
+	 {
+	 stackptr -= sizeof(vaddr_t);
+	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+
+	 if(flag)
+	 {
+	 kfree(kargv);
+	 kfree(namedes);
+	 return flag;
+	 }
+
+	 }
+
+	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+	//pt_getthread();
+
+	//enter_new_process does not return.
+	panic("enter_new_process returned\n");
+	return EINVAL;
+
+}
+
+int sys_getpid(pid_t *retval) {
+	//kprintf("In get pid:%d\n",curthread->pid);
+	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+
+	*retval = curthread->proc->pid;
+	return 0;
+}
+
+int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+	struct process* wthread = NULL;
+	int check;
+	int err;
+	pid_t i;
+	//kprintf("PID in wait pid:%d\n",pid);
+	if (status == NULL )
+		return EFAULT;
+	if (options != 0)
+		return EINVAL;
+	if (pid == curthread->pid)
+		return ECHILD;
+	if (pid < PID_MIN || pid > PID_MAX)
+		return ESRCH;
+	if (status == NULL )
+		return EFAULT;
+	if (pid == curthread->proc->ppid)
+		return ECHILD;
+	//int *shit;
+	//*shit=(int)&status;
+	//kprintf("%d\n",*shit);
+	//if(curthread->)
+	//if(pid!=curthread->)
+	//char* argv=(char*)(status);
+	//int length=strlen(argv)+1;
+	//int length=strlen(kargv[i])+1;
+	//int padder=length%4;
+	//kprintf("Hai:%d\n",padder);
+	//if(padder!=0)
+	//{
+	//return EFAULT;
+	//}
+
+	//if()
+
+	//char pathbuf[PATH_MAX];
+	//int *buffer;
+	//int result;
+
+	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+	//if (result) {
+	//return result;
+	//}
+	//int addr=(int)&status;
+	//kprintf("Status:%d\n",addr);
+	//int *addr=&status;
+	//if(addr%4!=0)
+	//{
+	//return EFAULT;
+	//}
+	//kprintf("Got Here\n");
+	for (i = 0; i <= 16; i++) {
+		if (p_table[i] != NULL ) {
+			if (p_table[i]->pid == pid) {
+				wthread = p_table[i];
+				break;
+			}
+		}
+	}
+	if (wthread == NULL ) {
+		return ESRCH;
+	}
+	if (curthread->proc->pid != wthread->ppid)
+		return ECHILD;
+	//panic("We are here");
+
+	lock_acquire(p_table[i]->tlock);
+
+	//while(!wthread->exited)
+	//{
+//
+	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+	//}
+	mywait(wthread);
+
+	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+	//kprintf("We are here!");
+
+	check = wthread->exitcode;
+	err = copyout(&check, (userptr_t) status, sizeof(check));
+	if (err) {
+		lock_release(p_table[i]->tlock);
+		return err;
+	}
+	//kprintf("Exit code After waiting:%d\n",*status);
+	//kfree(p_table[i]->exitsem);
+	//p_table[i]=NULL;
+
+	//panic("After kfree");
+	//p_table[i]=NULL;
+	lock_release(p_table[i]->tlock);
+	//filetable_destroy(p_table[i]->self->t_filetable);
+	//lock_destroy(p_table[i]->tlock);
+	//cv_destroy(p_table[i]->wcv);
+	//kfree(p_table[i]);
+	p_table[i] = NULL;
+
+	*retval = pid;
+	//panic("After dereferencing");
+	return 0;
+
+	//return -1;
+	//return 0;
+}
+
+void sys_exit(int exitcode) {
+	pid_t pid = curthread->proc->pid;
+	pid_t i = PID_MIN;
+	struct process* ethread=NULL;
+//pid_t parent;
+//if(pid!=2)
+//{
+	for (i = 0; i <= 16; i++) {
+		if (p_table[i] != NULL ) {
+			if (p_table[i]->pid == pid) {
+				ethread = p_table[i];
+				break;
+			}
+		}
+	}
+
+//parent=ethread->ppid;
+	if (ethread != NULL ) {
+		lock_acquire(ethread->tlock);
+//kprintf("Exit code Before:%d\n",exitcode);
+
+		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+//kprintf("Exitcode After:%d\n",ethread->exitcode);
+		ethread->exited = 1;
+//p_table[i]=ethread;
+		cv_broadcast(ethread->wcv, ethread->tlock);
+//kfree(curthread->t_filetable);
+		lock_release(ethread->tlock);
+	}
+//}
+	i = 0;
+//
+//kprintf("Before hanging");
+//filetable_destroy(curthread->t_filetable);
+//kfree(curthread->p);
+
+	thread_exit();
+}
+
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..6d6dc37 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,6 +44,8 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
+#include <file.h>
+#include<copyinout.h>
 
 /*
  * Load program "progname" and start running it in usermode.
@@ -52,7 +54,7 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname,char**argv,unsigned long argc)
 {
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
@@ -66,6 +68,13 @@ runprogram(char *progname)
 
 	/* We should be a new thread. */
 	KASSERT(curthread->t_addrspace == NULL);
+	curthread->t_filetable=NULL;
+  if (curthread->t_filetable == NULL) {
+		result = filetable_init("con:", "con:", "con:");
+		if (result) {
+			return result;
+		}
+	}
 
 	/* Create a new address space. */
 	curthread->t_addrspace = as_create();
@@ -94,9 +103,40 @@ runprogram(char *progname)
 		/* thread_exit destroys curthread->t_addrspace */
 		return result;
 	}
+	vaddr_t stackptrv[argc+1];
+int i;
+size_t actual;
+for(i = argc-1; i >= 0; i--)
+{
+int len = strlen(argv[i]);
+int padder=0;
+len++;
+if(len%4!=0)
+padder = len % 4;
+stackptr=stackptr-( len + (4-padder));
+result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+if(result)
+{
+return result;
+}
+stackptrv[i] = stackptr;
+}
+stackptrv[argc] = 0;
+for(i = argc; i >= 0; i--)
+{
+stackptr -= sizeof(vaddr_t);
+result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+if(result)
+{
+return result;
+}
+}
+
+
+
 
 	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+	enter_new_process(argc, (userptr_t)stackptr,
 			  stackptr, entrypoint);
 	
 	/* enter_new_process does not return. */
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..851f9ea 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -40,6 +40,8 @@
 #include <current.h>
 #include <synch.h>
 
+#define MAXREADERS 20;
+
 ////////////////////////////////////////////////////////////
 //
 // Semaphore.
@@ -162,9 +164,17 @@ lock_create(const char *name)
                 kfree(lock);
                 return NULL;
         }
-        
-        // add stuff here as needed
-        
+        lock->mut_wchan = wchan_create(lock->lk_name);
+        	if (lock->mut_wchan == NULL) {
+        		kfree(lock->lk_name);
+        		kfree(lock);
+        		return NULL;
+        	}
+
+        	spinlock_init(&lock->mut_lock);
+                lock->hold = 0;
+		lock->holder=NULL;
+        //lock->=NULL
         return lock;
 }
 
@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
 
         // add stuff here as needed
         
+        spinlock_cleanup(&lock->mut_lock);
+        	wchan_destroy(lock->mut_wchan);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -183,26 +195,78 @@ void
 lock_acquire(struct lock *lock)
 {
         // Write this
+KASSERT(lock!=NULL);
+
+
+//KASSERT(sem != NULL);
+
+        
+        KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&lock->mut_lock);
+        while (lock->hold ) {
+		
+		wchan_lock(lock->mut_wchan);
+		spinlock_release(&lock->mut_lock);
+                wchan_sleep(lock->mut_wchan);
+
+		spinlock_acquire(&lock->mut_lock);
+        }
+        KASSERT(lock->hold ==0 );
+        lock->hold=1;
+	lock->holder=curthread;
+        //sem->sem_count--;
+	spinlock_release(&lock->mut_lock);
 
-        (void)lock;  // suppress warning until code gets written
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
+	KASSERT(lock!=NULL);
+	KASSERT(lock->hold);
+	KASSERT(lock_do_i_hold(lock));
+	spinlock_acquire(&lock->mut_lock);
+	lock->hold=0;
+	
+	        //sem->sem_count++;
+	        KASSERT(lock->hold == 0);
+lock->holder=NULL;
+		wchan_wakeone(lock->mut_wchan);
+
+		spinlock_release(&lock->mut_lock);
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+	/*
+	
+	KASSERT(lock!=NULL);
+	KASSERT(lock->lockNeed==curthread);
+	spinlock_acquire(&lock->lockNeed);
+	lock->lockNeed==NULL;
+	
+	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+	spinlock_release(&lock->lockNeed);
+*/
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+	
+
+        //(void)lock;  // suppress warning until code gets written
+	KASSERT(lock!=NULL);
+	//spinlock_acquire(&lock->mut_lock);
+	if(!lock->hold) return false;
+if(lock->holder==curthread) return true;
+else 
+return false;
+	
+    //spinlock_release(&lock->mut_lock);
+    
+        //return res; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -225,7 +289,18 @@ cv_create(const char *name)
                 kfree(cv);
                 return NULL;
         }
-        
+        cv->cv_wchan = wchan_create(cv->cv_name);
+                	if (cv->cv_wchan == NULL) {
+                		kfree(cv->cv_name);
+                		kfree(cv);
+                		return NULL;
+                	}
+
+                	//spinlock_init(&cv->cv_lock);
+                        //lock->hold = 0;
+        		//lock->holder=NULL;
+                //lock->=NULL
+                return cv;
         // add stuff here as needed
         
         return cv;
@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
 
         // add stuff here as needed
         
+        //spinlock_cleanup(&cv->cv_lock);
+        
+        wchan_destroy(cv->cv_wchan);
         kfree(cv->cv_name);
         kfree(cv);
 }
@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+	KASSERT(cv!=NULL);
+	KASSERT(lock!=NULL);
+	//KASSERT(lock_do_i_hold(lock));
+	wchan_lock(cv->cv_wchan);
+	lock_release(lock);
+	
+	wchan_sleep(cv->cv_wchan);
+	lock_acquire(lock);
+	
+    // Write this
+    //(void)cv;    // suppress warning until code gets written
+    //(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
         // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv!=NULL);
+	KASSERT(lock!=NULL);
+	KASSERT(lock_do_i_hold(lock));
+	wchan_wakeone(cv->cv_wchan);
+	
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv!=NULL);
+	KASSERT(lock!=NULL);
+	KASSERT(lock_do_i_hold(lock));
+	wchan_wakeall(cv->cv_wchan);
+		
+	
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
+}
+
+struct rwlock *rwlock_create(const char *name)
+{
+	struct rwlock *rw;
+	rw=kmalloc(sizeof(struct rwlock));
+	if(rw==NULL)
+	{
+		return NULL;
+	}
+	rw->rwlock_name=kstrdup(name);
+	if(rw->rwlock_name==NULL)
+	{
+		kfree(rw);
+		return NULL;
+	}
+	rw->rd_wchan=wchan_create(rw->rwlock_name);
+	if(rw->rd_wchan==NULL)
+	{
+		kfree(rw->rwlock_name);
+		kfree(rw);
+		return NULL;
+	}
+	rw->wr_wchan=wchan_create(rw->rwlock_name);
+		if(rw->wr_wchan==NULL)
+		{
+			kfree(rw->rwlock_name);
+			kfree(rw);
+			return NULL;
+		}
+		rw->rw_sem=sem_create("mysem",20);
+		rw->rw_lock=lock_create("mylock");
+	///rw->res_count=MAXREADERS;
+	return rw;
+	
+}
+void rwlock_destroy(struct rwlock *rw)
+{
+		KASSERT(rw != NULL);
+		
+		wchan_destroy(rw->rd_wchan);
+		wchan_destroy(rw->wr_wchan);
+		sem_destroy(rw->rw_sem);
+		lock_destroy(rw->rw_lock);
+	    kfree(rw->rwlock_name);
+        kfree(rw);	
+}
+
+void rwlock_acquire_read(struct rwlock *rw)
+{
+	KASSERT(rw!=NULL);
+	lock_acquire(rw->rw_lock);
+	P(rw->rw_sem);
+	lock_release(rw->rw_lock);
+}
+void rwlock_release_read(struct rwlock *rw)
+{
+	KASSERT(rw!=NULL);
+	//lock_acquire(rw->rw_lock);
+	V(rw->rw_sem);
+	//lock_release(rw->rw_lock);
+}
+void rwlock_acquire_write(struct rwlock *rw)
+{
+	int i;
+	KASSERT(rw!=NULL);
+	lock_acquire(rw->rw_lock);
+	//rwlock->rw_sem->V();
+	for(i=0;i<20;i++)
+	{
+	P(rw->rw_sem);
+	}	
+	lock_release(rw->rw_lock);
+	
+	
 }
+void rwlock_release_write(struct rwlock *rw)
+{
+	int i;
+	KASSERT(rw!=NULL);
+	//lock_acquire(rw->rw_lock);
+	for(i=0;i<20;i++)
+	{
+	V(rw->rw_sem);
+	}	
+	//lock_release(rw->rw_lock);
+	
+}
+
+
+
+
+
+
+
+
+
+
diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
new file mode 100644
index 0000000..b9680d1
--- /dev/null
+++ b/kern/thread/synch.c~
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Synchronization primitives.
+ * The specifications of the functions are in synch.h.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <spinlock.h>
+#include <wchan.h>
+#include <thread.h>
+#include <current.h>
+#include <synch.h>
+
+////////////////////////////////////////////////////////////
+//
+// Semaphore.
+
+struct semaphore *
+sem_create(const char *name, int initial_count)
+{
+        struct semaphore *sem;
+
+        KASSERT(initial_count >= 0);
+
+        sem = kmalloc(sizeof(struct semaphore));
+        if (sem == NULL) {
+                return NULL;
+        }
+
+        sem->sem_name = kstrdup(name);
+        if (sem->sem_name == NULL) {
+                kfree(sem);
+                return NULL;
+        }
+
+	sem->sem_wchan = wchan_create(sem->sem_name);
+	if (sem->sem_wchan == NULL) {
+		kfree(sem->sem_name);
+		kfree(sem);
+		return NULL;
+	}
+
+	spinlock_init(&sem->sem_lock);
+        sem->sem_count = initial_count;
+
+        return sem;
+}
+
+void
+sem_destroy(struct semaphore *sem)
+{
+        KASSERT(sem != NULL);
+
+	/* wchan_cleanup will assert if anyone's waiting on it */
+	spinlock_cleanup(&sem->sem_lock);
+	wchan_destroy(sem->sem_wchan);
+        kfree(sem->sem_name);
+        kfree(sem);
+}
+
+void 
+P(struct semaphore *sem)
+{
+        KASSERT(sem != NULL);
+
+        /*
+         * May not block in an interrupt handler.
+         *
+         * For robustness, always check, even if we can actually
+         * complete the P without blocking.
+         */
+        KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&sem->sem_lock);
+        while (sem->sem_count == 0) {
+		/*
+		 * Bridge to the wchan lock, so if someone else comes
+		 * along in V right this instant the wakeup can't go
+		 * through on the wchan until we've finished going to
+		 * sleep. Note that wchan_sleep unlocks the wchan.
+		 *
+		 * Note that we don't maintain strict FIFO ordering of
+		 * threads going through the semaphore; that is, we
+		 * might "get" it on the first try even if other
+		 * threads are waiting. Apparently according to some
+		 * textbooks semaphores must for some reason have
+		 * strict ordering. Too bad. :-)
+		 *
+		 * Exercise: how would you implement strict FIFO
+		 * ordering?
+		 */
+		wchan_lock(sem->sem_wchan);
+		spinlock_release(&sem->sem_lock);
+                wchan_sleep(sem->sem_wchan);
+
+		spinlock_acquire(&sem->sem_lock);
+        }
+        KASSERT(sem->sem_count > 0);
+        sem->sem_count--;
+	spinlock_release(&sem->sem_lock);
+}
+
+void
+V(struct semaphore *sem)
+{
+        KASSERT(sem != NULL);
+
+	spinlock_acquire(&sem->sem_lock);
+
+        sem->sem_count++;
+        KASSERT(sem->sem_count > 0);
+	wchan_wakeone(sem->sem_wchan);
+
+	spinlock_release(&sem->sem_lock);
+}
+
+////////////////////////////////////////////////////////////
+//
+// Lock.
+
+struct lock *
+lock_create(const char *name)
+{
+        struct lock *lock;
+
+        lock = kmalloc(sizeof(struct lock));
+        if (lock == NULL) {
+                return NULL;
+        }
+
+        lock->lk_name = kstrdup(name);
+        if (lock->lk_name == NULL) {
+                kfree(lock);
+                return NULL;
+        }
+        lock->mut_wchan = wchan_create(lock->lk_name);
+        	if (lock->mut_wchan == NULL) {
+        		kfree(lock->lk_name);
+        		kfree(lock);
+        		return NULL;
+        	}
+
+        	spinlock_init(&lock->mut_lock);
+                lock->hold = 0;
+		lock->holder=NULL;
+        //lock->=NULL
+        return lock;
+}
+
+void
+lock_destroy(struct lock *lock)
+{
+        KASSERT(lock != NULL);
+
+        // add stuff here as needed
+        
+        spinlock_cleanup(&lock->mut_lock);
+        	wchan_destroy(lock->mut_wchan);
+        kfree(lock->lk_name);
+        kfree(lock);
+}
+
+void
+lock_acquire(struct lock *lock)
+{
+        // Write this
+KASSERT(lock!=NULL);
+
+
+//KASSERT(sem != NULL);
+
+        
+        KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&lock->mut_lock);
+        while (lock->hold ) {
+		
+		wchan_lock(lock->mut_wchan);
+		spinlock_release(&lock->mut_lock);
+                wchan_sleep(lock->mut_wchan);
+
+		spinlock_acquire(lock->mut_lock);
+        }
+        KASSERT(lock->hold ==0 );
+        lock->hold=1;
+	lock->holder=curthread;
+        //sem->sem_count--;
+	spinlock_release(&lock->mut_lock);
+
+        //(void)lock;  // suppress warning until code gets written
+}
+
+void
+lock_release(struct lock *lock)
+{
+	KASSERT(lock!=NULL);
+	KASSERT(lock->hold);
+	KASSERT(lock_do_i_hold(lock));
+	spinlock_acquire(&lock->mut_lock);
+	lock->hold=0;
+	
+	        //sem->sem_count++;
+	        KASSERT(lock->hold == 0);
+lock->holder=NULL;
+		wchan_wakeone(lock->mut_wchan);
+
+		spinlock_release(&lock->mut_lock);
+        // Write this
+	/*
+	
+	KASSERT(lock!=NULL);
+	KASSERT(lock->lockNeed==curthread);
+	spinlock_acquire(&lock->lockNeed);
+	lock->lockNeed==NULL;
+	
+	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+	spinlock_release(&lock->lockNeed);
+*/
+        //(void)lock;  // suppress warning until code gets written
+}
+
+bool
+lock_do_i_hold(struct lock *lock)
+{
+        // Write this
+	
+
+        //(void)lock;  // suppress warning until code gets written
+	KASSERT(lock!=NULL);
+	//spinlock_acquire(&lock->mut_lock);
+	if(!lock->hold) return false;
+if(lock->holder==curthread) return true;
+else 
+return false;
+	
+    //spinlock_release(&lock->mut_lock);
+    
+        //return res; // dummy until code gets written
+}
+
+////////////////////////////////////////////////////////////
+//
+// CV
+
+
+struct cv *
+cv_create(const char *name)
+{
+        struct cv *cv;
+
+        cv = kmalloc(sizeof(struct cv));
+        if (cv == NULL) {
+                return NULL;
+        }
+
+        cv->cv_name = kstrdup(name);
+        if (cv->cv_name==NULL) {
+                kfree(cv);
+                return NULL;
+        }
+        
+        // add stuff here as needed
+        
+        return cv;
+}
+
+void
+cv_destroy(struct cv *cv)
+{
+        KASSERT(cv != NULL);
+
+        // add stuff here as needed
+        
+        kfree(cv->cv_name);
+        kfree(cv);
+}
+
+void
+cv_wait(struct cv *cv, struct lock *lock)
+{
+        // Write this
+        (void)cv;    // suppress warning until code gets written
+        (void)lock;  // suppress warning until code gets written
+}
+
+void
+cv_signal(struct cv *cv, struct lock *lock)
+{
+        // Write this
+	(void)cv;    // suppress warning until code gets written
+	(void)lock;  // suppress warning until code gets written
+}
+
+void
+cv_broadcast(struct cv *cv, struct lock *lock)
+{
+	// Write this
+	(void)cv;    // suppress warning until code gets written
+	(void)lock;  // suppress warning until code gets written
+}
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..f3918ab 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,6 +47,7 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <file.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
 
 /* Used to wait for secondary CPUs to come online. */
 static struct semaphore *cpu_startup_sem;
+pid_t pidcount;
+struct process* p_table[17];
 
 ////////////////////////////////////////////////////////////
 
@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
 
 /*
  * Check the magic number we put on the bottom end of the stack in
- * thread_checkstack_init. If these assertions go off, it most likely
+ * thread_checkstack_init. If these KASSERTions go off, it most likely
  * means you overflowed your stack at some point, which can cause all
  * kinds of mysterious other things to happen.
  *
@@ -262,6 +265,9 @@ thread_destroy(struct thread *thread)
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
 
+thread->t_filetable=NULL;
+  KASSERT(thread->t_filetable == NULL);
+
 	kfree(thread->t_name);
 	kfree(thread);
 }
@@ -352,8 +358,15 @@ thread_bootstrap(void)
 {
 	struct cpu *bootcpu;
 	struct thread *bootthread;
+	int i;
 
 	cpuarray_init(&allcpus);
+	pidcount=PID_MIN;
+
+	for(i=0;i<=16;i++)
+	{
+		p_table[i]=NULL;
+	}
 
 	/*
 	 * Create the cpu structure for the bootup CPU, the one we're
@@ -365,6 +378,7 @@ thread_bootstrap(void)
 	 */
 	bootcpu = cpu_create(0);
 	bootthread = bootcpu->c_curthread;
+	//bootthread->pid=PID_MIN;
 
 	/*
 	 * Initializing curcpu and curthread is machine-dependent
@@ -519,7 +533,7 @@ thread_fork(const char *name,
 	 * for the spllower() that will be done releasing it.
 	 */
 	newthread->t_iplhigh_count++;
-
+	//newthread->pid=pidcount++;
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
 
@@ -532,6 +546,7 @@ thread_fork(const char *name,
 	 * only with caution, because in general the child thread
 	 * might exit at any time.
 	 */
+
 	if (ret != NULL) {
 		*ret = newthread;
 	}
@@ -589,7 +604,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 	switch (newstate) {
 	    case S_RUN:
 		panic("Illegal S_RUN in thread_switch\n");
-		break;
 	    case S_READY:
 		thread_make_runnable(cur, true /*have lock*/);
 		break;
@@ -799,6 +813,11 @@ thread_exit(void)
 		VOP_DECREF(cur->t_cwd);
 		cur->t_cwd = NULL;
 	}
+	
+	if (curthread->t_filetable) {
+		filetable_destroy(curthread->t_filetable);
+		curthread->t_filetable = NULL;
+	}
 
 	/* VM fields */
 	if (cur->t_addrspace) {
diff --git a/single10.patch b/single10.patch
new file mode 100644
index 0000000..2267436
--- /dev/null
+++ b/single10.patch
@@ -0,0 +1,915 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..68c73ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,6 +32,7 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++		break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++		break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++		break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++		break;
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..e1d7682 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,8 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..f3a01ad 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+ 
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..08b8f8c 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -112,6 +112,7 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..4ba181a 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,7 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -66,6 +67,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index 5b8099e..60108d3 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -798,6 +801,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..04fc72b
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,8279 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..33b99ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	int flag;
++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	if(flag)
++	{
++		newtf.tf_v0=ENOMEM;
++		newtf.tf_a3=1;
++	}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	curthread->pid=newtf.tf_a0;
++
++	as_activate(curthread->t_addrspace);
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..a4c2750 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	fthread->proc->tlock=lock_create("First Lock");
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..dfd7b53
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,445 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro) {
++	//lock_acquire(mypro->tlock);
++	while (!mypro->exited) {
++		cv_wait(mypro->wcv, mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++	(void) adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++			sizeof(struct trapframe));
++	bzero(copyt, sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt, tf, sizeof(struct trapframe));
++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++	//if(curthread->pid==0)
++	//{
++	//curthread->pid=PID_MIN;
++	//}
++	if (flag) {
++		kfree(copyt);
++		return flag;
++	}
++
++	//we need to allocate pid for our new process
++
++	//pid_t cpid;
++	for (childid = 0; childid <= 16; childid++) {
++		if (p_table[childid] == NULL ) {
++			p_table[childid] = (struct process*) kmalloc(
++					sizeof(struct process));
++			p_table[childid]->full = 1;
++			pidcount++;
++			p_table[childid]->pid = pidcount;
++			p_table[childid]->ppid = curthread->pid;
++			//p_table[childid]->exitsem=sem_create("process",0);
++			p_table[childid]->tlock = lock_create("My Lock");
++			p_table[childid]->wcv = cv_create("My CV");
++			p_table[childid]->self = NULL;
++			break;
++		}
++	}
++	if (childid > PID_MAX) {
++		*retval = 1;
++		return EMPROC;
++	}
++	//int i;
++
++	copyt->tf_a0 = (int) p_table[childid]->pid;
++	//kprintf("Ret:%d\n",copyt->tf_a0);
++	struct thread *new_proc;
++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++	//int s=splhigh();
++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++			(unsigned long) adrcopy, &new_proc);
++	//kprintf("Out of thread fork:%d\n",flag);
++	if (flag) {
++		kfree(copyt);
++		as_destroy(adrcopy);
++
++		return flag;
++	}
++
++	//new_proc->pid=(pid_t)childid;
++	//new_proc=p_table[childid];
++
++	new_proc->pid = p_table[childid]->pid;
++	new_proc->proc = p_table[childid];
++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++	//if (new_proc->t_filetable == NULL) {
++	//return ENOMEM;
++	//}
++	p_table[childid]->self = new_proc;
++
++	//new_proc->pid=p_table[childid]->pid;
++	//new_proc->proc->pid=p_table[childid]->pid;
++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++
++	//kprintf("Child id:%d",new_proc->pid);
++	//new_proc->t_filetable->
++	//for(i=0;i<128;i++)
++	//{
++	flag = filetable_copy(&new_proc->t_filetable);
++	//}
++	//splx(s);
++	// kprintf("Fork over!");
++
++	*retval = p_table[childid]->pid;
++	//kprintf("Return val in fork:%d",*retval);
++	return 0;
++
++	//flag=
++	//flag=thread_fork=
++}
++
++int sys_execv(char *progname, char** arguments) {
++
++	int flag;
++	int numargs;
++	int addr;
++	int i;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size = 0;
++	char *namedes;
++
++	if (progname == NULL ) {
++		return EFAULT;
++	}
++	if (progname == "") {
++		return EINVAL;
++	}
++
++	namedes = (char*) kmalloc(PATH_MAX);
++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++			&actual_size);
++	if (flag != 0) {
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if (strlen(namedes) == 0) {
++		//*retval=1;
++		return EISDIR;
++	}
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++	if (flag) {
++		return flag;
++	}
++	actual_size = 0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++	if (arguments == NULL ) {
++		kfree(namedes);
++		return EFAULT;
++	}
++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++	if (flag) {
++		kfree(namedes);
++		return EFAULT;
++	}
++
++	//check=wthread->exitcode;
++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++	//if(err)
++	//{
++	//	lock_release(p_table[i]->tlock);
++	//return err;
++	//}
++
++	numargs = 0;
++	while (arguments[numargs] != NULL ) {
++		//kprintf("%");
++		numargs = numargs + 1;
++	}
++
++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++	//int i;
++	for (i = 0; i < numargs; i++) {
++		actual_size = 0;
++		kargv[i] = (char*) kmalloc(PATH_MAX);
++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++				&actual_size);
++		if (flag) {
++			kfree(kargv);
++			kfree(namedes);
++			return EFAULT;
++		}
++
++	}
++	actual_size = 0;
++
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace == NULL ) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++	if (flag) {
++		// thread_exit destroys curthread->t_addrspace
++		vfs_close(vn);
++		return flag;
++	}
++
++	vfs_close(vn);
++
++	// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (flag) {
++		//thread_exit destroys curthread->t_addrspace
++		return flag;
++	}
++
++	//i=0;
++	vaddr_t stackptrv[numargs + 1];
++	for (i = numargs - 1; i >= 0; i--) {
++		int len = strlen(kargv[i]);
++		int padder=0;
++		len++;// to account for string terminator
++		if(len%4!=0)
++		padder = len % 4;
++		stackptr =stackptr-(len + padder);
++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++				&actual_size);
++
++		if (flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return flag;
++		}
++
++		stackptrv[i] = stackptr;
++	}
++	stackptrv[numargs] = 0;
++
++	//This copies the actual stack addresses of the arguments
++	//* into the stack. Hopefully.
++
++	 for(i = numargs; i >= 0; i--)
++	 {
++	 stackptr -= sizeof(vaddr_t);
++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++
++	 if(flag)
++	 {
++	 kfree(kargv);
++	 kfree(namedes);
++	 return flag;
++	 }
++
++	 }
++
++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++	//pt_getthread();
++
++	//enter_new_process does not return.
++	panic("enter_new_process returned\n");
++	return EINVAL;
++
++}
++
++int sys_getpid(pid_t *retval) {
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval = curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++	struct process* wthread = NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if (status == NULL )
++		return EFAULT;
++	if (options != 0)
++		return EINVAL;
++	if (pid == curthread->pid)
++		return ECHILD;
++	if (pid < PID_MIN || pid > PID_MAX)
++		return ESRCH;
++	if (status == NULL )
++		return EFAULT;
++	if (pid == curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++	//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++	//return EFAULT;
++	//}
++
++	//if()
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++	//if (result) {
++	//return result;
++	//}
++	//int addr=(int)&status;
++	//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++	//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				wthread = p_table[i];
++				break;
++			}
++		}
++	}
++	if (wthread == NULL ) {
++		return ESRCH;
++	}
++	if (curthread->proc->pid != wthread->ppid)
++		return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check = wthread->exitcode;
++	err = copyout(&check, (userptr_t) status, sizeof(check));
++	if (err) {
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i] = NULL;
++
++	*retval = pid;
++	//panic("After dereferencing");
++	return 0;
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode) {
++	pid_t pid = curthread->proc->pid;
++	pid_t i = PID_MIN;
++	struct process* ethread;
++//pid_t parent;
++//if(pid!=2)
++//{
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				ethread = p_table[i];
++				break;
++			}
++		}
++	}
++
++//parent=ethread->ppid;
++	if (ethread != NULL ) {
++		lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++		ethread->exited = 1;
++//p_table[i]=ethread;
++		cv_broadcast(ethread->wcv, ethread->tlock);
++//kfree(curthread->t_filetable);
++		lock_release(ethread->tlock);
++	}
++//}
++	i = 0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++	thread_exit();
++}
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..1ada408 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,40 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++int padder=0;
++len++;
++if(len%4!=0)
++padder = len % 4;
++stackptr=stackptr-(len + padder);
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..df129b9 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +357,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +377,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +532,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +811,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..e07fb23
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,4058 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..dfd7b53
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,445 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro) {
+++	//lock_acquire(mypro->tlock);
+++	while (!mypro->exited) {
+++		cv_wait(mypro->wcv, mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+++	(void) adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt = (struct trapframe*) kmalloc(
+++			sizeof(struct trapframe));
+++	bzero(copyt, sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt, tf, sizeof(struct trapframe));
+++	flag = as_copy(curthread->t_addrspace, &adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++	//curthread->pid=PID_MIN;
+++	//}
+++	if (flag) {
+++		kfree(copyt);
+++		return flag;
+++	}
+++
+++	//we need to allocate pid for our new process
+++
+++	//pid_t cpid;
+++	for (childid = 0; childid <= 16; childid++) {
+++		if (p_table[childid] == NULL ) {
+++			p_table[childid] = (struct process*) kmalloc(
+++					sizeof(struct process));
+++			p_table[childid]->full = 1;
+++			pidcount++;
+++			p_table[childid]->pid = pidcount;
+++			p_table[childid]->ppid = curthread->pid;
+++			//p_table[childid]->exitsem=sem_create("process",0);
+++			p_table[childid]->tlock = lock_create("My Lock");
+++			p_table[childid]->wcv = cv_create("My CV");
+++			p_table[childid]->self = NULL;
+++			break;
+++		}
+++	}
+++	if (childid > PID_MAX) {
+++		*retval = 1;
+++		return EMPROC;
+++	}
+++	//int i;
+++
+++	copyt->tf_a0 = (int) p_table[childid]->pid;
+++	//kprintf("Ret:%d\n",copyt->tf_a0);
+++	struct thread *new_proc;
+++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+++	//int s=splhigh();
+++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+++			(unsigned long) adrcopy, &new_proc);
+++	//kprintf("Out of thread fork:%d\n",flag);
+++	if (flag) {
+++		kfree(copyt);
+++		as_destroy(adrcopy);
+++
+++		return flag;
+++	}
+++
+++	//new_proc->pid=(pid_t)childid;
+++	//new_proc=p_table[childid];
+++
+++	new_proc->pid = p_table[childid]->pid;
+++	new_proc->proc = p_table[childid];
+++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++	//if (new_proc->t_filetable == NULL) {
+++	//return ENOMEM;
+++	//}
+++	p_table[childid]->self = new_proc;
+++
+++	//new_proc->pid=p_table[childid]->pid;
+++	//new_proc->proc->pid=p_table[childid]->pid;
+++	//kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++	//kprintf("Child id:%d",new_proc->pid);
+++	//new_proc->t_filetable->
+++	//for(i=0;i<128;i++)
+++	//{
+++	flag = filetable_copy(&new_proc->t_filetable);
+++	//}
+++	//splx(s);
+++	// kprintf("Fork over!");
+++
+++	*retval = p_table[childid]->pid;
+++	//kprintf("Return val in fork:%d",*retval);
+++	return 0;
+++
+++	//flag=
+++	//flag=thread_fork=
+++}
+++
+++int sys_execv(char *progname, char** arguments) {
+++
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size = 0;
+++	char *namedes;
+++
+++	if (progname == NULL ) {
+++		return EFAULT;
+++	}
+++	if (progname == "") {
+++		return EINVAL;
+++	}
+++
+++	namedes = (char*) kmalloc(PATH_MAX);
+++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+++			&actual_size);
+++	if (flag != 0) {
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if (strlen(namedes) == 0) {
+++		//*retval=1;
+++		return EISDIR;
+++	}
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+++	if (flag) {
+++		return flag;
+++	}
+++	actual_size = 0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if (arguments == NULL ) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+++	if (flag) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++	//return err;
+++	//}
+++
+++	numargs = 0;
+++	while (arguments[numargs] != NULL ) {
+++		//kprintf("%");
+++		numargs = numargs + 1;
+++	}
+++
+++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+++	//int i;
+++	for (i = 0; i < numargs; i++) {
+++		actual_size = 0;
+++		kargv[i] = (char*) kmalloc(PATH_MAX);
+++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+++				&actual_size);
+++		if (flag) {
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size = 0;
+++
+++	curthread->t_addrspace = as_create();
+++	if (curthread->t_addrspace == NULL ) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++	if (flag) {
+++		// thread_exit destroys curthread->t_addrspace
+++		vfs_close(vn);
+++		return flag;
+++	}
+++
+++	vfs_close(vn);
+++
+++	// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++	if (flag) {
+++		//thread_exit destroys curthread->t_addrspace
+++		return flag;
+++	}
+++
+++	//i=0;
+++	vaddr_t stackptrv[numargs + 1];
+++	for (i = numargs - 1; i >= 0; i--) {
+++		int len = strlen(kargv[i]);
+++		int padder=0;
+++		len++;// to account for string terminator
+++		if(len%4!=0)
+++		padder = len % 4;
+++		stackptr =stackptr-(len + padder);
+++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+++				&actual_size);
+++
+++		if (flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return flag;
+++		}
+++
+++		stackptrv[i] = stackptr;
+++	}
+++	stackptrv[numargs] = 0;
+++
+++	//This copies the actual stack addresses of the arguments
+++	//* into the stack. Hopefully.
+++
+++	 for(i = numargs; i >= 0; i--)
+++	 {
+++	 stackptr -= sizeof(vaddr_t);
+++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++
+++	 if(flag)
+++	 {
+++	 kfree(kargv);
+++	 kfree(namedes);
+++	 return flag;
+++	 }
+++
+++	 }
+++
+++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+++	//pt_getthread();
+++
+++	//enter_new_process does not return.
+++	panic("enter_new_process returned\n");
+++	return EINVAL;
+++
+++}
+++
+++int sys_getpid(pid_t *retval) {
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval = curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+++	struct process* wthread = NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if (status == NULL )
+++		return EFAULT;
+++	if (options != 0)
+++		return EINVAL;
+++	if (pid == curthread->pid)
+++		return ECHILD;
+++	if (pid < PID_MIN || pid > PID_MAX)
+++		return ESRCH;
+++	if (status == NULL )
+++		return EFAULT;
+++	if (pid == curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++	//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++
+++	//if()
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++	//if (result) {
+++	//return result;
+++	//}
+++	//int addr=(int)&status;
+++	//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				wthread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++	if (wthread == NULL ) {
+++		return ESRCH;
+++	}
+++	if (curthread->proc->pid != wthread->ppid)
+++		return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check = wthread->exitcode;
+++	err = copyout(&check, (userptr_t) status, sizeof(check));
+++	if (err) {
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i] = NULL;
+++
+++	*retval = pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode) {
+++	pid_t pid = curthread->proc->pid;
+++	pid_t i = PID_MIN;
+++	struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				ethread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++
+++//parent=ethread->ppid;
+++	if (ethread != NULL ) {
+++		lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++		ethread->exited = 1;
+++//p_table[i]=ethread;
+++		cv_broadcast(ethread->wcv, ethread->tlock);
+++//kfree(curthread->t_filetable);
+++		lock_release(ethread->tlock);
+++	}
+++//}
+++	i = 0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++	thread_exit();
+++}
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..1ada408 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,40 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++int padder=0;
+++len++;
+++if(len%4!=0)
+++padder = len % 4;
+++stackptr=stackptr-(len + padder);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address sp
+\ No newline at end of file
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
index 287a678..db31b89 100644
--- a/user/testbin/badcall/bad_execv.c
+++ b/user/testbin/badcall/bad_execv.c
@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
 		return;
 	}
 
+
 	rv = execv("/bin/true", args);
 	report_test(rv, errno, EFAULT, desc);
 	exit(MAGIC_STATUS);
diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
index 809c68c..8eb69c3 100644
--- a/user/testbin/badcall/bad_waitpid.c
+++ b/user/testbin/badcall/bad_waitpid.c
@@ -36,6 +36,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <err.h>
+#include<stdio.h>
 
 #include "config.h"
 #include "test.h"
@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
 	if (pid==0) {
 		exit(0);
 	}
+	//printf("Hello:%d",(int)ptr);
 
 	rv = waitpid(pid, ptr, 0);
 	report_test(rv, errno, EFAULT, desc);
 	waitpid(pid, &x, 0);
 }
 
+
 static
 void
 wait_unaligned(void)
@@ -85,13 +88,16 @@ wait_unaligned(void)
 	if (pid==0) {
 		exit(0);
 	}
+	//printf("Aligned int:%d",&status);
 
 	/* start with proper integer alignment */
 	ptr = (char *)(&status[0]);
-
+	//printf("Aligned:%c\n",*ptr);
 	/* generate improper alignment on platforms with restrictions*/
 	ptr++;
 
+	//Print("UnAligned:%c\n",*ptr);
+
 	rv = waitpid(pid, (int *)ptr, 0);
 	report_survival(rv, errno, "wait with unaligned status");
 	if (rv<0) {
diff --git a/user/testbin/forkbomb/forkbomb.c b/user/testbin/forkbomb/forkbomb.c
index 880027c..1e9b5cc 100644
--- a/user/testbin/forkbomb/forkbomb.c
+++ b/user/testbin/forkbomb/forkbomb.c
@@ -49,7 +49,7 @@
 
 #include <unistd.h>
 #include <err.h>
-
+#include<stdio.h>
 static volatile int pid;
 
 int
@@ -61,11 +61,12 @@ main()
 		fork();
 
 		pid = getpid();
-
+		//printf("First:%d\n",pid);
 		/* Make sure each fork has its own address space. */
 		for (i=0; i<300; i++) {
 			volatile int seenpid;
 			seenpid = pid;
+			//printf("Second:%d\n",seenpid);
 			if (seenpid != getpid()) {
 				errx(1, "pid mismatch (%d, should be %d) "
 				     "- your vm is broken!", 
diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
new file mode 100644
index 0000000..fe21882
--- /dev/null
+++ b/user/testbin/myforktest/Makefile
@@ -0,0 +1,11 @@
+# Makefile for forktest
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=myforktest
+SRCS=myforktest.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
new file mode 100644
index 0000000..7bd6663
--- /dev/null
+++ b/user/testbin/myforktest/myforktest.c
@@ -0,0 +1,33 @@
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <err.h>
+
+int main()
+{
+	int status;
+	int pid;
+	int childpid;
+	int parent;
+	int returnCode=fork();
+
+	if(returnCode==0)
+	{
+		childpid=getpid();
+		printf("I am child:%d\n",childpid);
+		return -10;
+	}
+	else
+	{
+		//printf("Return:%d",returnCode);
+		//printf("Wait for child\n");
+		parent=getpid();
+		printf("I am parent:%d\n",parent);
+		pid=waitpid(returnCode,&status,0);
+		printf("Child id returned" "%d",pid);
+		printf(" Return code: %d\n",status);
+
+	}
+	return 0;
+}
