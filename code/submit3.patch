diff --git a/kern/arch/mips/conf/conf.arch b/kern/arch/mips/conf/conf.arch
index 39ddbc3..ffa3d0f 100644
--- a/kern/arch/mips/conf/conf.arch
+++ b/kern/arch/mips/conf/conf.arch
@@ -69,8 +69,8 @@ machine mips file    vm/copyinout.c		# copyin/out et al.
 # For the early assignments, we supply a very stupid MIPS-only skeleton
 # of a VM system. It is just barely capable of running a single userlevel
 # program as long as that program's not very large.
-defoption   dumbvm
-machine mips optfile dumbvm    arch/mips/vm/dumbvm.c
+#defoption   dumbvm
+machine mips file    arch/mips/vm/myownvm.c
 
 #
 # System call layer
diff --git a/kern/arch/mips/include/vm.h b/kern/arch/mips/include/vm.h
index af393c7..bfc9642 100644
--- a/kern/arch/mips/include/vm.h
+++ b/kern/arch/mips/include/vm.h
@@ -53,6 +53,10 @@
 #define MIPS_KSEG1  0xa0000000
 #define MIPS_KSEG2  0xc0000000
 
+#define FREE 0;
+#define FIXED 1;
+#define CLEAN 2;
+#define DIRTY 3;
 /* 
  * The first 512 megs of physical space can be addressed in both kseg0 and
  * kseg1. We use kseg0 for the kernel. This macro returns the kernel virtual
@@ -102,11 +106,43 @@ void ram_bootstrap(void);
 paddr_t ram_stealmem(unsigned long npages);
 void ram_getsize(paddr_t *lo, paddr_t *hi);
 
+
+
+
+/* Initialization function */
+void vm_bootstrap(void);
+
+/* Fault handling function called by trap code */
+int vm_fault(int faulttype, vaddr_t faultaddress);
+//int vm_fault();
+
+/* Allocate/free kernel heap pages (called by kmalloc/kfree) */
+vaddr_t alloc_kpages(int npages);
+//vaddr_t alloc_kpages();
+
+void free_kpages(vaddr_t addr);
+//void free_kpages();
+
+/* TLB shootdown handling called from interprocessor_interrupt */
+//void vm_tlbshootdown_all(void);
+//void vm_tlbshootdown(const struct tlbshootdown *);
+
+
 /*
  * TLB shootdown bits.
  *
  * We'll take up to 16 invalidations before just flushing the whole TLB.
  */
+struct page{
+	struct addrspace* as;
+	vaddr_t va;
+	int state;
+	uint64_t timestamp;
+
+
+
+};
+
 
 struct tlbshootdown {
 	/*
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..72de946 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -114,7 +114,9 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
-	panic("I don't know how to handle this\n");
+	sys_exit(0);
+	//panic("I don't know how to handle this\n");
+	//thread_exit();
 }
 
 /*
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..7d2eb52 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -32,11 +32,14 @@
 #include <kern/syscall.h>
 #include <lib.h>
 #include <mips/trapframe.h>
+#include <addrspace.h>
+#include <copyinout.h>
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
 
 
+
 /*
  * System call dispatcher.
  *
@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
+        int32_t retvalv1 = 0;
+        int64_t retval64;
 	int err;
+        int32_t stackarg1;
 
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
 		err = sys___time((userptr_t)tf->tf_a0,
 				 (userptr_t)tf->tf_a1);
 		break;
+            case SYS_open:
+		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+			       &retval);
+		break;
+	    case SYS_read:
+		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+			       &retval);
+		break;
+	    case SYS_write:
+		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+				&retval);
+		break;
+	    case SYS_close:
+		err = sys_close(tf->tf_a0);
+		break;
+	    case SYS_lseek:
+                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+                                stackarg1, &retval64);
+                retval = retval64 >> 32;
+                retvalv1 = (int) retval64;
+                break;
+	    case SYS_dup2:
+		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+			break;
+	    case SYS_chdir:
+		err = sys_chdir((userptr_t)tf->tf_a0);
+			break;
+	    case SYS___getcwd:
+		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+			break;
+	    case SYS_fork:
+	    	err=0;
+	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+	    	break;
+	    case SYS_execv:
+	    	err=0;
+	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+	    	break;
+	    case SYS_getpid:
+	    	err=0;
+	    	err=sys_getpid(&retval);
+	    	break;
+	    case SYS_waitpid:
+	    	err=0;
+	    	//kprintf("Dispatch:%d",tf->tf_a0);
+	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+	    	//panic("Waitpid over");
+	    	break;
+	    case SYS__exit:
+	    	sys_exit((int)tf->tf_a0);
+	    	break;
+
 
 	    /* Add stuff here */
  
@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
 	else {
 		/* Success. */
 		tf->tf_v0 = retval;
+                tf->tf_v1 = retvalv1;
 		tf->tf_a3 = 0;      /* signal no error */
 	}
 	
@@ -154,8 +214,49 @@ syscall(struct trapframe *tf)
  *
  * Thus, you can trash it and do things another way if you prefer.
  */
-void
-enter_forked_process(struct trapframe *tf)
+//void
+//enter_forked_process(struct trapframe *tf)
+//{
+	//(void)tf;
+//}
+
+void enter_forked_process(void*tf,unsigned long adrspace)
 {
-	(void)tf;
+	//int flag;
+	//tf=(struct trapframe*)tf;
+	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+		//if(flag)
+		//{
+
+			//return flag;
+			//newtf.tf_v0=ENOMEM;
+			//newtf.tf_a3=1;
+		//}
+	curthread->t_addrspace=(struct addrspace*)adrspace;
+	as_activate(curthread->t_addrspace);
+	//tf=(struct trapframe*)tf;
+	struct trapframe newtf;
+	//int flag;
+	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+	//if(flag)
+	//{
+		//newtf.tf_v0=ENOMEM;
+		//newtf.tf_a3=1;
+	//}
+
+	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+	kfree(tf);
+	//tf=NULL;
+	//int flag;
+
+	//curthread->pid=newtf.tf_a0;
+
+
+
+
+
+	newtf.tf_v0=0;
+	newtf.tf_a3=0;
+	newtf.tf_epc+=4;
+	mips_usermode(&newtf);
 }
diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
new file mode 100644
index 0000000..3e8d5b9
--- /dev/null
+++ b/kern/arch/mips/syscall/syscall.c~
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/syscall.h>
+#include <lib.h>
+#include <mips/trapframe.h>
+#include <thread.h>
+#include <current.h>
+#include <syscall.h>
+
+
+/*
+ * System call dispatcher.
+ *
+ * A pointer to the trapframe created during exception entry (in
+ * exception.S) is passed in.
+ *
+ * The calling conventions for syscalls are as follows: Like ordinary
+ * function calls, the first 4 32-bit arguments are passed in the 4
+ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+ * if the first argument is 32-bit and the second is 64-bit, a1 is
+ * unused.
+ *
+ * This much is the same as the calling conventions for ordinary
+ * function calls. In addition, the system call number is passed in
+ * the v0 register.
+ *
+ * On successful return, the return value is passed back in the v0
+ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+ * function call, and additionally the a3 register is also set to 0 to
+ * indicate success.
+ *
+ * On an error return, the error code is passed back in the v0
+ * register, and the a3 register is set to 1 to indicate failure.
+ * (Userlevel code takes care of storing the error code in errno and
+ * returning the value -1 from the actual userlevel syscall function.
+ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+ *
+ * Upon syscall return the program counter stored in the trapframe
+ * must be incremented by one instruction; otherwise the exception
+ * return code will restart the "syscall" instruction and the system
+ * call will repeat forever.
+ *
+ * If you run out of registers (which happens quickly with 64-bit
+ * values) further arguments must be fetched from the user-level
+ * stack, starting at sp+16 to skip over the slots for the
+ * registerized values, with copyin().
+ */
+void
+syscall(struct trapframe *tf)
+{
+	int callno;
+	int32_t retval;
+	int err;
+
+	KASSERT(curthread != NULL);
+	KASSERT(curthread->t_curspl == 0);
+	KASSERT(curthread->t_iplhigh_count == 0);
+
+	callno = tf->tf_v0;
+
+	/*
+	 * Initialize retval to 0. Many of the system calls don't
+	 * really return a value, just 0 for success and -1 on
+	 * error. Since retval is the value returned on success,
+	 * initialize it to 0 by default; thus it's not necessary to
+	 * deal with it except for calls that return other values, 
+	 * like write.
+	 */
+
+	retval = 0;
+
+	switch (callno) {
+	    case SYS_reboot:
+		err = sys_reboot(tf->tf_a0);
+		break;
+
+	    case SYS___time:
+		err = sys___time((userptr_t)tf->tf_a0,
+				 (userptr_t)tf->tf_a1);
+		break;
+		
+	    case SYS_open:
+	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+	    break;
+
+	    /* Add stuff here */
+ 
+	    default:
+		kprintf("Unknown syscall %d\n", callno);
+		err = ENOSYS;
+		break;
+	}
+
+
+	if (err) {
+		/*
+		 * Return the error code. This gets converted at
+		 * userlevel to a return value of -1 and the error
+		 * code in errno.
+		 */
+		tf->tf_v0 = err;
+		tf->tf_a3 = 1;      /* signal an error */
+	}
+	else {
+		/* Success. */
+		tf->tf_v0 = retval;
+		tf->tf_a3 = 0;      /* signal no error */
+	}
+	
+	/*
+	 * Now, advance the program counter, to avoid restarting
+	 * the syscall over and over again.
+	 */
+	
+	tf->tf_epc += 4;
+
+	/* Make sure the syscall code didn't forget to lower spl */
+	KASSERT(curthread->t_curspl == 0);
+	/* ...or leak any spinlocks */
+	KASSERT(curthread->t_iplhigh_count == 0);
+}
+
+/*
+ * Enter user mode for a newly forked process.
+ *
+ * This function is provided as a reminder. You need to write
+ * both it and the code that calls it.
+ *
+ * Thus, you can trash it and do things another way if you prefer.
+ */
+void
+enter_forked_process(struct trapframe *tf)
+{
+	(void)tf;
+}
diff --git a/kern/arch/mips/vm/myownvm.c b/kern/arch/mips/vm/myownvm.c
new file mode 100644
index 0000000..f44f4fa
--- /dev/null
+++ b/kern/arch/mips/vm/myownvm.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+
+/*
+ * Dumb MIPS-only "VM system" that is intended to only be just barely
+ * enough to struggle off the ground. You should replace all of this
+ * code while doing the VM assignment. In fact, starting in that
+ * assignment, this file is not included in your kernel!
+ */
+
+/* under dumbvm, always have 48k of user stack */
+#define DUMBVM_STACKPAGES    12
+
+
+//static struct page* pagemap;
+//static int bootflag=0;
+//static struct lock *pagemaplock;
+//static unsigned long long page_num;
+/*
+ * Wrap rma_stealmem in a spinlock.
+ */
+//static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+
+//void
+//vm_bootstrap(void)
+//{
+	/*
+	unsigned long long i;
+	//get ramsize
+	paddr_t firstaddr,lastaddr,freeaddr;
+	ram_getsize(&firstaddr,&lastaddr);
+	page_num=ROUNDDOWN(lastaddr,PAGE_SIZE)/PAGE_SIZE;
+	pagemap=(struct page*)PADDR_TO_KVADDR(firstaddr);
+
+	freeaddr=firstaddr+page_num*sizeof(struct page);
+
+	pagemap=(struct page*)PADDR_TO_KVADDR(firstaddr);
+
+	for (i=0;i<page_num;i++)
+	{
+		pagemap->as=NULL;
+		pagemap->timestamp=0;
+		pagemap->state=FREE;
+		pagemap->va=PADDR_TO_KVADDR(freeaddr+(i*PAGE_SIZE));
+	}
+	bootflag=1;
+	pagemaplock=lock_create("My pagemap lock");
+		Do nothing.
+	*/
+//}
+
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..b301f16 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -330,8 +330,8 @@ file      thread/threadlist.c
 #
 
 file      vm/kmalloc.c
-
-optofffile dumbvm   vm/addrspace.c
+#optofffile dumbvm   vm/addrspace.c
+file   vm/addrspace.c
 
 #
 # Network
@@ -367,6 +367,9 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/file_syscalls.c
+file      syscall/file.c
+file	  syscall/proc_sys.c
 
 #
 # Startup and initialization
diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
index 6788e97..f7ba314 100644
--- a/kern/include/addrspace.h
+++ b/kern/include/addrspace.h
@@ -59,6 +59,13 @@ struct addrspace {
         paddr_t as_stackpbase;
 #else
         /* Put stuff here for your VM system */
+	 vaddr_t as_vbase1;
+        paddr_t as_pbase1;
+        size_t as_npages1;
+        vaddr_t as_vbase2;
+        paddr_t as_pbase2;
+        size_t as_npages2;
+        paddr_t as_stackpbase;
 #endif
 };
 
diff --git a/kern/include/file.h b/kern/include/file.h
new file mode 100644
index 0000000..2c63bc2
--- /dev/null
+++ b/kern/include/file.h
@@ -0,0 +1,59 @@
+/*
+ * Declarations for file handle and file table management.
+ * New for SOL2.
+ */
+
+#ifndef _FILE_H_
+#define _FILE_H_
+
+#include <limits.h>
+
+struct lock;
+struct vnode;
+
+/*** openfile section ***/
+
+/* 
+ * openfile struct 
+ * note that there's not too much to keep track of, since the vnode does most
+ * of that.  note that it does require synchronization, because a single
+ * openfile can be shared between processes (filetable inheritance).
+ */
+struct openfile {
+	struct vnode *of_vnode;
+	
+	struct lock *of_lock;
+	off_t of_offset;
+	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+	int of_refcount;
+};
+
+/* opens a file (must be kernel pointers in the args) */
+int file_open(char *filename, int flags, int mode, int *retfd);
+
+/* closes a file */
+int file_close(int fd);
+
+
+/*** file table section ***/
+
+/*
+ * filetable struct
+ * just an array of open files.  nice and simple.  doesn't require
+ * synchronization, because a table can only be owned by a single process (on
+ * inheritance in fork, the table is copied).
+ */
+struct filetable {
+	struct openfile *ft_openfiles[OPEN_MAX];
+};
+
+/* these all have an implicit arg of the curthread's filetable */
+int filetable_init(const char *inpath, const char *outpath, 
+		   const char *errpath);
+int filetable_copy(struct filetable **copy);
+int filetable_placefile(struct openfile *file, int *fd);
+int filetable_findfile(int fd, struct openfile **file);
+int filetable_dup2file(int oldfd, int newfd);
+void filetable_destroy(struct filetable *ft);
+
+#endif /* _FILE_H_ */
diff --git a/kern/include/limits.h b/kern/include/limits.h
index 01684c4..3a54e24 100644
--- a/kern/include/limits.h
+++ b/kern/include/limits.h
@@ -48,5 +48,6 @@
 #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
 #define OPEN_MAX        __OPEN_MAX
 #define IOV_MAX         __IOV_MAX
+//#define OPEN_MAX        64
 
 #endif /* _LIMITS_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..df9fe64 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,6 +74,11 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+//volatile struct thread *lockNeed;
+        struct spinlock mut_lock;
+        struct wchan *mut_wchan;
+        volatile int hold;
+struct thread *holder;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+        //struct spinlock cv_lock;
+        struct wchan *cv_wchan;
+        //volatile int hold;
+        //struct thread *holder;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+        volatile int res_count;
+        struct wchan *rd_wchan;
+        struct wchan *wr_wchan;
+        struct semaphore *rw_sem;
+        struct lock *rw_lock;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
new file mode 100644
index 0000000..d98aeb7
--- /dev/null
+++ b/kern/include/synch.h~
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SYNCH_H_
+#define _SYNCH_H_
+
+/*
+ * Header file for synchronization primitives.
+ */
+
+
+#include <spinlock.h>
+
+/*
+ * Dijkstra-style semaphore.
+ *
+ * The name field is for easier debugging. A copy of the name is made
+ * internally.
+ */
+struct semaphore {
+        char *sem_name;
+	struct wchan *sem_wchan;
+	struct spinlock sem_lock;
+        volatile int sem_count;
+};
+
+struct semaphore *sem_create(const char *name, int initial_count);
+void sem_destroy(struct semaphore *);
+
+/*
+ * Operations (both atomic):
+ *     P (proberen): decrement count. If the count is 0, block until
+ *                   the count is 1 again before decrementing.
+ *     V (verhogen): increment count.
+ */
+void P(struct semaphore *);
+void V(struct semaphore *);
+
+
+/*
+ * Simple lock for mutual exclusion.
+ *
+ * When the lock is created, no thread should be holding it. Likewise,
+ * when the lock is destroyed, no thread should be holding it.
+ *
+ * The name field is for easier debugging. A copy of the name is
+ * (should be) made internally.
+ */
+struct lock {
+        char *lk_name;
+//volatile struct thread *lockNeed;
+        struct spinlock mut_lock;
+        struct wchan *mut_wchan;
+        volatile int hold;
+struct thread *holder;
+        // add what you need here
+        // (don't forget to mark things volatile as needed)
+};
+
+struct lock *lock_create(const char *name);
+void lock_acquire(struct lock *);
+
+/*
+ * Operations:
+ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+ *                   same time.
+ *    lock_release - Free the lock. Only the thread holding the lock may do
+ *                   this.
+ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+ *                   false otherwise.
+ *
+ * These operations must be atomic. You get to write them.
+ */
+void lock_release(struct lock *);
+bool lock_do_i_hold(struct lock *);
+void lock_destroy(struct lock *);
+
+
+/*
+ * Condition variable.
+ *
+ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+ * to wait until a variable meets a particular condition, but there's no
+ * actual variable, as such, in the CV.
+ *
+ * These CVs are expected to support Mesa semantics, that is, no
+ * guarantees are made about scheduling.
+ *
+ * The name field is for easier debugging. A copy of the name is
+ * (should be) made internally.
+ */
+
+struct cv {
+        char *cv_name;
+        // add what you need here
+        // (don't forget to mark things volatile as needed)
+};
+
+struct cv *cv_create(const char *name);
+void cv_destroy(struct cv *);
+
+/*
+ * Operations:
+ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+ *                   waking up again, re-acquire the lock.
+ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+ *    cv_broadcast - Wake up all threads sleeping on this CV.
+ *
+ * For all three operations, the current thread must hold the lock passed 
+ * in. Note that under normal circumstances the same lock should be used
+ * on all operations with any particular CV.
+ *
+ * These operations must be atomic. You get to write them.
+ */
+void cv_wait(struct cv *cv, struct lock *lock);
+void cv_signal(struct cv *cv, struct lock *lock);
+void cv_broadcast(struct cv *cv, struct lock *lock);
+
+/*
+ * 13 Feb 2012 : GWA : Reader-writer locks.
+ */
+
+struct rwlock {
+        char *rwlock_name;
+};
+
+struct rwlock * rwlock_create(const char *);
+void rwlock_destroy(struct rwlock *);
+
+void rwlock_acquire_read(struct rwlock *);
+void rwlock_release_read(struct rwlock *);
+void rwlock_acquire_write(struct rwlock *);
+void rwlock_release_write(struct rwlock *);
+
+#endif /* _SYNCH_H_ */
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..ea96700 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -26,6 +26,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
+#include<thread.h>
 
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
  * Support functions.
  */
 
+
 /* Helper for fork(). You write this. */
-void enter_forked_process(struct trapframe *tf);
+void enter_forked_process(void *tf,unsigned long adrspace);
 
 /* Enter user mode. Does not return. */
 void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
  * Prototypes for IN-KERNEL entry points for system call implementations.
  */
 
+int sys_open(userptr_t filename, int flags, int mode, int *retval);
+int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+int sys_close(int fd);
+int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+int sys_dup2(int oldfd, int newfd, int *retval);
+int sys_chdir(userptr_t path);
+int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+int sys_execv(char* progname,char** arguments);
+int sys_getpid(pid_t *retval);
+int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+void sys_exit(int exitcode);
+int mywait(struct process* mypro);
 
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..84f60fc 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -105,7 +105,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname,char** argv,unsigned long argc);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..77a3515 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -73,7 +73,10 @@ struct thread {
 	 */
 	char *t_name;			/* Name of this thread */
 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
-	threadstate_t t_state;		/* State this thread is in */
+	threadstate_t t_state;
+	/* State this thread is in */
+
+	pid_t pid;
 
 	/*
 	 * Thread subsystem internal fields.
@@ -104,7 +107,7 @@ struct thread {
 	/*
 	 * Public fields
 	 */
-
+	struct process* proc;
 	/* VM */
 	struct addrspace *t_addrspace;	/* virtual address space */
 
@@ -112,6 +115,19 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+  struct filetable *t_filetable;
+};
+
+struct process {
+	int full;
+	pid_t pid;
+    pid_t ppid;
+    //struct semaphore* exitsem;
+    struct lock* tlock;
+    struct cv* wcv;
+    bool exited;
+    int exitcode;
+    struct thread* self;
 };
 
 /* Call once during system startup to allocate data structures. */
diff --git a/kern/include/uio.h b/kern/include/uio.h
index 5d97c48..c9124e8 100644
--- a/kern/include/uio.h
+++ b/kern/include/uio.h
@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
 void uio_kinit(struct iovec *, struct uio *,
 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
 
+void uio_uinit(struct iovec *, struct uio *,
+	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+
 
 #endif /* _UIO_H_ */
diff --git a/kern/include/vm.h b/kern/include/vm.h
index e4e73d0..a77b73e 100644
--- a/kern/include/vm.h
+++ b/kern/include/vm.h
@@ -50,10 +50,14 @@ void vm_bootstrap(void);
 
 /* Fault handling function called by trap code */
 int vm_fault(int faulttype, vaddr_t faultaddress);
+//int vm_fault();
 
 /* Allocate/free kernel heap pages (called by kmalloc/kfree) */
 vaddr_t alloc_kpages(int npages);
+//vaddr_t alloc_kpages();
+
 void free_kpages(vaddr_t addr);
+//void free_kpages();
 
 /* TLB shootdown handling called from interprocessor_interrupt */
 void vm_tlbshootdown_all(void);
diff --git a/kern/lib/uio.c b/kern/lib/uio.c
index 594fe96..83ea620 100644
--- a/kern/lib/uio.c
+++ b/kern/lib/uio.c
@@ -153,6 +153,7 @@ void
 uio_kinit(struct iovec *iov, struct uio *u,
 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
 {
+	KASSERT(u);
 	iov->iov_kbase = kbuf;
 	iov->iov_len = len;
 	u->uio_iov = iov;
@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
 	u->uio_rw = rw;
 	u->uio_space = NULL;
 }
+
+void
+uio_uinit(struct iovec *iov, struct uio *u,
+    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+{
+	KASSERT(u);
+	iov->iov_ubase = ubuf;
+	iov->iov_len = len;
+  u->uio_iov = iov;
+	u->uio_iovcnt = 1;
+	u->uio_offset = pos;
+	u->uio_resid = len;
+	u->uio_segflg = UIO_USERSPACE;
+	u->uio_rw = rw;
+	u->uio_space = curthread->t_addrspace;
+}
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..4d8e7e2 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -100,7 +100,7 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
new file mode 100644
index 0000000..4d8e7e2
--- /dev/null
+++ b/kern/startup/main.c~
@@ -0,0 +1,211 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Main.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/reboot.h>
+#include <kern/unistd.h>
+#include <lib.h>
+#include <spl.h>
+#include <clock.h>
+#include <thread.h>
+#include <current.h>
+#include <synch.h>
+#include <vm.h>
+#include <mainbus.h>
+#include <vfs.h>
+#include <device.h>
+#include <syscall.h>
+#include <test.h>
+#include <version.h>
+#include "autoconf.h"  // for pseudoconfig
+
+
+/*
+ * These two pieces of data are maintained by the makefiles and build system.
+ * buildconfig is the name of the config file the kernel was configured with.
+ * buildversion starts at 1 and is incremented every time you link a kernel. 
+ *
+ * The purpose is not to show off how many kernels you've linked, but
+ * to make it easy to make sure that the kernel you just booted is the
+ * same one you just built.
+ */
+extern const int buildversion;
+extern const char buildconfig[];
+
+/*
+ * Copyright message for the OS/161 base code.
+ */
+static const char harvard_copyright[] =
+    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+    "   President and Fellows of Harvard College.  All rights reserved.\n";
+
+
+/*
+ * Initial boot sequence.
+ */
+static
+void
+boot(void)
+{
+	/*
+	 * The order of these is important!
+	 * Don't go changing it without thinking about the consequences.
+	 *
+	 * Among other things, be aware that console output gets
+	 * buffered up at first and does not actually appear until
+	 * mainbus_bootstrap() attaches the console device. This can
+	 * be remarkably confusing if a bug occurs at this point. So
+	 * don't put new code before mainbus_bootstrap if you don't
+	 * absolutely have to.
+	 *
+	 * Also note that the buffer for this is only 1k. If you
+	 * overflow it, the system will crash without printing
+	 * anything at all. You can make it larger though (it's in
+	 * dev/generic/console.c).
+	 */
+
+	kprintf("\n");
+	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+	kprintf("%s", harvard_copyright);
+	kprintf("\n");
+
+	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+		GROUP_VERSION, buildconfig, buildversion);
+	kprintf("\n");
+
+	/* Early initialization. */
+	ram_bootstrap();
+	thread_bootstrap();
+	hardclock_bootstrap();
+	vfs_bootstrap();
+
+	/* Probe and initialize devices. Interrupts should come on. */
+	kprintf("Device probe...\n");
+	KASSERT(curthread->t_curspl > 0);
+	mainbus_bootstrap();
+	KASSERT(curthread->t_curspl == 0);
+	/* Now do pseudo-devices. */
+	pseudoconfig();
+	kprintf("\n");
+
+	/* Late phase of initialization. */
+	vm_bootstrap();
+	kprintf_bootstrap();
+	thread_start_cpus();
+
+	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+	vfs_setbootfs("emu0");
+
+
+	/*
+	 * Make sure various things aren't screwed up.
+	 */
+	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+}
+
+/*
+ * Shutdown sequence. Opposite to boot().
+ */
+static
+void
+shutdown(void)
+{
+
+	kprintf("Shutting down.\n");
+	
+	vfs_clearbootfs();
+	vfs_clearcurdir();
+	vfs_unmountall();
+
+	thread_shutdown();
+
+	splhigh();
+}
+
+/*****************************************/
+
+/*
+ * reboot() system call.
+ *
+ * Note: this is here because it's directly related to the code above,
+ * not because this is where system call code should go. Other syscall
+ * code should probably live in the "syscall" directory.
+ */
+int
+sys_reboot(int code)
+{
+	switch (code) {
+	    case RB_REBOOT:
+	    case RB_HALT:
+	    case RB_POWEROFF:
+		break;
+	    default:
+		return EINVAL;
+	}
+
+	shutdown();
+
+	switch (code) {
+	    case RB_HALT:
+		kprintf("The system is halted.\n");
+		mainbus_halt();
+		break;
+	    case RB_REBOOT:
+		kprintf("Rebooting...\n");
+		mainbus_reboot();
+		break;
+	    case RB_POWEROFF:
+		kprintf("The system is halted.\n");
+		mainbus_poweroff();
+		break;
+	}
+
+	panic("reboot operation failed\n");
+	return 0;
+}
+
+/*
+ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+ * request, and then shut down.
+ */
+void
+kmain(char *arguments)
+{
+	boot();
+
+	menu(arguments);
+
+	/* Should not get here */
+}
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..8cfaa94 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -40,9 +40,13 @@
 #include <sfs.h>
 #include <syscall.h>
 #include <test.h>
+#include<thread.h>
+#include<synch.h>
 #include "opt-synchprobs.h"
 #include "opt-sfs.h"
 #include "opt-net.h"
+#include <copyinout.h>
+//#include "proc_sys.c"
 
 /*
  * In-kernel menu and command dispatcher.
@@ -51,6 +55,7 @@
 #define _PATH_SHELL "/bin/sh"
 
 #define MAXMENUARGS  16
+extern struct process* p_table[17];
 
 // XXX this should not be in this file
 void
@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	result = runprogram(progname,args,nargs);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
@@ -127,6 +132,8 @@ int
 common_prog(int nargs, char **args)
 {
 	int result;
+	struct thread* fthread;
+	//int err;
 
 #if OPT_SYNCHPROBS
 	kprintf("Warning: this probably won't work with a "
@@ -136,7 +143,34 @@ common_prog(int nargs, char **args)
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&fthread);
+	//fthread->
+	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+	if(fthread->proc==NULL)
+		return ENOMEM;
+
+	fthread->pid=PID_MIN;
+	fthread->proc->pid=PID_MIN;
+
+	fthread->proc->self=fthread;
+	fthread->proc->wcv=cv_create("First CV");
+	if(fthread->proc->wcv==NULL)
+		return ENOMEM;
+	fthread->proc->tlock=lock_create("First Lock");
+	if(fthread->proc->tlock==NULL)
+		return ENOMEM;
+	p_table[0]=fthread->proc;
+
+	lock_acquire(p_table[0]->tlock);
+	mywait(p_table[0]);
+	lock_release(p_table[0]->tlock);
+
+	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+
+	//fthread->proc->
+	//while(!p_table[0]->exited)
+
+
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..6c0bb3f 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -43,11 +43,25 @@
  * You should implement your solution to the whalemating problem below.
  */
 
+
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
-// the top of the corresponding driver code.
+// the top of the corresponding driver code
+
+struct semaphore *male_sem;
+struct semaphore *female_sem;
+struct lock *hold;
+struct cv* mate_cv;
+volatile int male_count;
+volatile int female_count;
 
 void whalemating_init() {
+ hold=lock_create("My lock");
+ male_sem=sem_create("Male Semaphore",0);
+ female_sem=sem_create("Female Semaphore",0);
+mate_cv=cv_create("mating cv");
+male_count=0;
+female_count=0;
   return;
 }
 
@@ -55,6 +69,11 @@ void whalemating_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+
+	sem_destroy(male_sem);
+	sem_destroy(female_sem);
+	lock_destroy(hold);
+	cv_destroy(mate_cv);
   return;
 }
 
@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
   (void)which;
   
   male_start();
+
+  lock_acquire(hold);
+
+  V(male_sem);
+  male_count++;
+  if(female_count!=0)
+  cv_signal(mate_cv,hold);
+  else
+	  cv_wait(mate_cv,hold);
+  lock_release(hold);
+
 	// Implement this function 
   male_end();
 
@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
   (void)which;
   
   female_start();
+  lock_acquire(hold);
+   V(female_sem);
+   female_count++;
+   if(male_count!=0)
+   cv_signal(mate_cv,hold);
+   else
+	   cv_wait(mate_cv,hold);
+  lock_release(hold);
 	// Implement this function 
   female_end();
-  
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
   (void)which;
   
   matchmaker_start();
+  lock_acquire(hold);
+ P(male_sem);
+ male_count--;
+ lock_release(hold);
+ lock_acquire(hold);
+  P(female_sem);
+  female_count--;
+  lock_release(hold);
 	// Implement this function 
   matchmaker_end();
-  
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
+
+
 /*
  * You should implement your solution to the stoplight problem below. The
  * quadrant and direction mappings for reference: (although the problem is,
@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+struct lock* intersect_lock;
+struct cv* intersect_cv;
+volatile int cur_poss[4];// an array to store the possible positions of the car
+//currently
 
 void stoplight_init() {
+	intersect_cv=cv_create("Intersection Condition Variable");
+	if(intersect_cv==NULL)
+	{
+		///return NULL;
+		panic("condition variable not created");
+	}
+	intersect_lock=lock_create("A lock on the intersection");
+	if(intersect_lock==NULL)
+	{
+		//return NULL;
+		panic("Lock could not be created");
+	}
+	
+	
   return;
 }
 
@@ -145,6 +210,8 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
+	cv_destroy(intersect_cv);
+	lock_destroy(intersect_lock);
   return;
 }
 
@@ -152,8 +219,29 @@ void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
+  //(void)direction;
+	int sec_quad=(direction+3)%4;
+	lock_acquire(intersect_lock);
+	// So while any of the two possible quadrants are already set, It means some 
+	//thread is waiting...Hopefully
+	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+		cv_wait(intersect_cv,intersect_lock);
+	cur_poss[direction]=1;
+	cur_poss[sec_quad]=1;
+	inQuadrant(direction);
+	lock_release(intersect_lock);
+	lock_acquire(intersect_lock);
+    cur_poss[direction]=0;
+    //while(curr_p)
+    //cv_broadcast(intersect_cv);
+    inQuadrant(sec_quad);
+    cv_broadcast(intersect_cv,intersect_lock);
+    lock_release(intersect_lock);
+    lock_acquire(intersect_lock);
+    cur_poss[sec_quad]=0;
+    leaveIntersection();
+    cv_broadcast(intersect_cv,intersect_lock);
+    lock_release(intersect_lock);
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+  int sec_quad=(direction+3)%4;
+  int third_quad=(direction+2)%4;
+  lock_acquire(intersect_lock);
+  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+	  cv_wait(intersect_cv,intersect_lock);
+  cur_poss[direction]=1;
+  cur_poss[sec_quad]=1;
+  inQuadrant(direction);
+  lock_release(intersect_lock);
+  lock_acquire(intersect_lock);
+  cur_poss[direction]=0;
   
+  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+  //cv_wait(intersect_cv,intersect_lock);
+      cur_poss[third_quad]=1;
+      //while(curr_p)
+      //cv_broadcast(intersect_cv);
+      inQuadrant(sec_quad);
+      cv_broadcast(intersect_cv,intersect_lock);
+      lock_release(intersect_lock);
+        lock_acquire(intersect_lock);
+            //currposs[direction]=0;
+            cur_poss[sec_quad]=0;
+            //while(curr_p)
+            //cv_broadcast(intersect_cv);
+            inQuadrant(third_quad);
+            cv_broadcast(intersect_cv,intersect_lock);
+                //cur_poss[third_quad]=0;
+            lock_release(intersect_lock);
+              lock_acquire(intersect_lock);
+                leaveIntersection();
+                cur_poss[third_quad]=0;
+                cv_broadcast(intersect_cv,intersect_lock);
+                lock_release(intersect_lock);
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
-
+  // Easy coz the vehicle is in same lane!!
+  lock_acquire(intersect_lock);
+  while(cur_poss[direction]==1)
+	  cv_wait(intersect_cv,intersect_lock);
+  cur_poss[direction]=1;
+  inQuadrant(direction);
+  lock_release(intersect_lock);
+    lock_acquire(intersect_lock);
+  leaveIntersection();
+  cur_poss[direction]=0;
+  cv_broadcast(intersect_cv,intersect_lock);
+  lock_release(intersect_lock);
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
diff --git a/kern/syscall/file.c b/kern/syscall/file.c
new file mode 100644
index 0000000..dc5ffe5
--- /dev/null
+++ b/kern/syscall/file.c
@@ -0,0 +1,341 @@
+/*
+ * File handles and file tables.
+ * New for SOL2.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/limits.h>
+#include <kern/stat.h>
+#include <kern/unistd.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <synch.h>
+#include <uio.h>
+#include <thread.h>
+#include <current.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <file.h>
+#include <syscall.h>
+
+/*** openfile functions ***/
+
+/*
+ * file_open
+ * opens a file, places it in the filetable, sets RETFD to the file
+ * descriptor. the pointer arguments must be kernel pointers.
+ * NOTE -- the passed in filename must be a mutable string.
+ */
+int
+file_open(char *filename, int flags, int mode, int *retfd)
+{
+	struct vnode *vn;
+	struct openfile *file;
+	int result;
+	
+	result = vfs_open(filename, flags, mode, &vn);
+	if (result) {
+		return result;
+	}
+
+	file = kmalloc(sizeof(struct openfile));
+	if (file == NULL) {
+		vfs_close(vn);
+		return ENOMEM;
+	}
+
+	/* initialize the file struct */
+	file->of_lock = lock_create("file lock");
+	if (file->of_lock == NULL) {
+		vfs_close(vn);
+		kfree(file);
+		return ENOMEM;
+	}
+	file->of_vnode = vn;
+	file->of_offset = 0;
+	file->of_accmode = flags & O_ACCMODE;
+	file->of_refcount = 1;
+
+	/* vfs_open checks for invalid access modes */
+	KASSERT(file->of_accmode==O_RDONLY ||
+	        file->of_accmode==O_WRONLY ||
+	        file->of_accmode==O_RDWR);
+
+	/* place the file in the filetable, getting the file descriptor */
+	result = filetable_placefile(file, retfd);
+	if (result) {
+		lock_destroy(file->of_lock);
+		kfree(file);
+		vfs_close(vn);
+		return result;
+	}
+
+	return 0;
+}
+
+/*
+ * file_doclose
+ * shared code for file_close and filetable_destroy
+ */
+static
+int
+file_doclose(struct openfile *file)
+{
+	lock_acquire(file->of_lock);
+
+	/* if this is the last close of this file, free it up */
+	if (file->of_refcount == 1) {
+		vfs_close(file->of_vnode);
+		lock_release(file->of_lock);
+		lock_destroy(file->of_lock);
+		kfree(file);
+	}
+	else {
+		KASSERT(file->of_refcount > 1);
+		file->of_refcount--;
+		lock_release(file->of_lock);
+	}
+
+	return 0;
+}
+
+/* 
+ * file_close
+ * knock off the refcount, freeing the memory if it goes to 0.
+ */
+int
+file_close(int fd)
+{
+	struct openfile *file;
+	int result;
+
+	/* find the file in the filetable */
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	result = file_doclose(file);
+	if (result) {
+		/* leave file open for possible retry */
+		return result;
+	}
+	curthread->t_filetable->ft_openfiles[fd] = NULL;
+
+	return 0;
+}
+
+/*** filetable functions ***/
+
+/* 
+ * filetable_init
+ * pretty straightforward -- allocate the space, initialize to NULL.
+ * note that the one careful thing is to open the std i/o in order to
+ * get
+ * stdin  == 0
+ * stdout == 1
+ * stderr == 2
+ */
+int
+filetable_init(const char *inpath, const char *outpath, const char *errpath)
+{
+	/* the filenames come from the kernel; assume reasonable length */
+	char path[32];
+	int result;
+	int fd;
+
+	/* make sure we can fit these */
+	KASSERT(strlen(inpath) < sizeof(path));
+	KASSERT(strlen(outpath) < sizeof(path));
+	KASSERT(strlen(errpath) < sizeof(path));
+	
+	/* catch memory leaks, repeated calls */
+	KASSERT(curthread->t_filetable == NULL);
+
+	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+	if (curthread->t_filetable == NULL) {
+		return ENOMEM;
+	}
+	
+	/* NULL-out the table */
+	for (fd = 0; fd < OPEN_MAX; fd++) {
+		curthread->t_filetable->ft_openfiles[fd] = NULL;
+	}
+
+	/*
+	 * open the std fds.  note that the names must be copied into
+	 * the path buffer so that they're mutable.
+	 */
+	strcpy(path, inpath);
+	result = file_open(path, O_RDONLY, 0, &fd);
+	if (result) {
+		return result;
+	}
+
+	strcpy(path, outpath);
+	result = file_open(path, O_WRONLY, 0, &fd);
+	if (result) {
+		return result;
+	}
+
+	strcpy(path, errpath);
+	result = file_open(path, O_WRONLY, 0, &fd);
+	if (result) {
+		return result;
+	}
+
+	return 0;
+}
+
+/*
+ * filetable_copy
+ * again, pretty straightforward.  the subtle business here is that instead of
+ * copying the openfile structure, we just increment the refcount.  this means
+ * that openfile structs will, in fact, be shared between processes, as in
+ * Unix.
+ */
+int
+filetable_copy(struct filetable **copy)
+{
+	struct filetable *ft = curthread->t_filetable;
+	int fd;
+
+	/* waste of a call, really */
+	if (ft == NULL) {
+		*copy = NULL;
+		return 0;
+	}
+	
+	*copy = kmalloc(sizeof(struct filetable));
+	
+	if (*copy == NULL) {
+		return ENOMEM;
+	}
+
+	/* copy over the entries */
+	for (fd = 0; fd < OPEN_MAX; fd++) {
+		if (ft->ft_openfiles[fd] != NULL) {
+			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+			ft->ft_openfiles[fd]->of_refcount++;
+			lock_release(ft->ft_openfiles[fd]->of_lock);
+			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+		} 
+		else {
+			(*copy)->ft_openfiles[fd] = NULL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * filetable_destroy
+ * closes the files in the file table, frees the table.
+ */
+void
+filetable_destroy(struct filetable *ft)
+{
+	int fd, result;
+
+	KASSERT(ft != NULL);
+
+	for (fd = 0; fd < OPEN_MAX; fd++) {
+		if (ft->ft_openfiles[fd]) {
+			result = file_doclose(ft->ft_openfiles[fd]);
+			KASSERT(result==0);
+		}
+	}
+	
+	kfree(ft);
+}	
+
+/* 
+ * filetable_placefile
+ * finds the smallest available file descriptor, places the file at the point,
+ * sets FD to it.
+ */
+int
+filetable_placefile(struct openfile *file, int *fd)
+{
+	struct filetable *ft = curthread->t_filetable;
+	int i;
+	
+	for (i = 0; i < OPEN_MAX; i++) {
+		if (ft->ft_openfiles[i] == NULL) {
+			ft->ft_openfiles[i] = file;
+			*fd = i;
+			return 0;
+		}
+	}
+
+	return EMFILE;
+}
+
+/*
+ * filetable_findfile
+ * verifies that the file descriptor is valid and actually references an
+ * open file, setting the FILE to the file at that index if it's there.
+ */
+int
+filetable_findfile(int fd, struct openfile **file)
+{
+	struct filetable *ft = curthread->t_filetable;
+
+	if (fd < 0 || fd >= OPEN_MAX) {
+		return EBADF;
+	}
+	
+	*file = ft->ft_openfiles[fd];
+	if (*file == NULL) {
+		return EBADF;
+	}
+
+	return 0;
+}
+
+/*
+ * filetable_dup2file
+ * verifies that both file descriptors are valid, and that the OLDFD is
+ * actually an open file.  then, if the NEWFD is open, it closes it.
+ * finally, it sets the filetable entry at newfd, and ups its refcount.
+ */
+int
+filetable_dup2file(int oldfd, int newfd)
+{
+	struct filetable *ft = curthread->t_filetable;
+	struct openfile *file;
+	int result;
+
+	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+		return EBADF;
+	}
+
+	file = ft->ft_openfiles[oldfd];
+	if (file == NULL) {
+		return EBADF;
+	}
+
+	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+	if (oldfd == newfd) {
+		return 0;
+	}
+
+	/* closes the newfd if it's open */
+	if (ft->ft_openfiles[newfd] != NULL) {
+		result = file_close(newfd);
+		if (result) {
+			return result;
+		}
+	}
+
+	/* up the refcount */
+	lock_acquire(file->of_lock);
+	file->of_refcount++;
+	lock_release(file->of_lock);
+
+	/* doesn't need to be synchronized because it's just changing the ft */
+	ft->ft_openfiles[newfd] = file;
+
+	return 0;
+}
diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
new file mode 100644
index 0000000..8aa024c
--- /dev/null
+++ b/kern/syscall/file_syscalls.c
@@ -0,0 +1,270 @@
+/*
+ * File-related system call implementations.
+ * New for SOL2.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/limits.h>
+#include <kern/stat.h>
+#include <kern/unistd.h>
+#include <kern/fcntl.h>
+#include <kern/seek.h>
+#include <lib.h>
+#include <synch.h>
+#include <uio.h>
+#include <thread.h>
+#include <current.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <file.h>
+#include <syscall.h>
+#include <copyinout.h>
+
+/*
+ * sys_open
+ * just copies in the filename, then passes work to file_open.
+ */
+int
+sys_open(userptr_t filename, int flags, int mode, int *retval)
+{
+	char fname[PATH_MAX];
+	int result;
+
+	result = copyinstr(filename, fname, sizeof(fname), NULL);
+	if (result) {
+		return result;
+	}
+
+	return file_open(fname, flags, mode, retval);
+}
+
+/*
+ * sys_read
+ * translates the fd into its openfile, then calls VOP_READ.
+ */
+int
+sys_read(int fd, userptr_t buf, size_t size, int *retval)
+{
+  struct iovec iov;
+	struct uio useruio;
+	struct openfile *file;
+	int result;
+
+	/* better be a valid file descriptor */
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	lock_acquire(file->of_lock);
+
+	if (file->of_accmode == O_WRONLY) {
+		lock_release(file->of_lock);
+		return EBADF;
+	}
+
+	/* set up a uio with the buffer, its size, and the current offset */
+  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+  
+  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+
+	/* does the read */
+	result = VOP_READ(file->of_vnode, &useruio);
+	if (result) {
+		lock_release(file->of_lock);
+		return result;
+	}
+
+	/* set the offset to the updated offset in the uio */
+	file->of_offset = useruio.uio_offset;
+
+	lock_release(file->of_lock);
+	
+	/*
+	 * The amount read is the size of the buffer originally, minus
+	 * how much is left in it.
+	 */
+	*retval = size - useruio.uio_resid;
+
+	return 0;
+}
+
+/*
+ * sys_write
+ * translates the fd into its openfile, then calls VOP_WRITE.
+ */
+int
+sys_write(int fd, userptr_t buf, size_t size, int *retval)
+{
+  struct iovec iov;
+	struct uio useruio;
+	struct openfile *file;
+	int result;
+
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	lock_acquire(file->of_lock);
+
+	if (file->of_accmode == O_RDONLY) {
+		lock_release(file->of_lock);
+		return EBADF;
+	}
+
+	/* set up a uio with the buffer, its size, and the current offset */
+  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+	
+  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+
+	/* does the write */
+	result = VOP_WRITE(file->of_vnode, &useruio);
+	if (result) {
+		lock_release(file->of_lock);
+		return result;
+	}
+
+	/* set the offset to the updated offset in the uio */
+	file->of_offset = useruio.uio_offset;
+
+	lock_release(file->of_lock);
+
+	/*
+	 * the amount written is the size of the buffer originally,
+	 * minus how much is left in it.
+	 */
+	*retval = size - useruio.uio_resid;
+
+	return 0;
+}
+
+/* 
+ * sys_close
+ * just pass off the work to file_close.
+ */
+int
+sys_close(int fd)
+{
+	return file_close(fd);
+}
+
+/*
+ * sys_lseek
+ * translates the fd into its openfile, then based on the type of seek,
+ * figure out the new offset, try the seek, if that succeeds, update the
+ * openfile.
+ */
+int
+sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+{
+	struct stat info;
+	struct openfile *file;
+	int result;
+
+	result = filetable_findfile(fd, &file);
+	if (result) {
+		return result;
+	}
+
+	lock_acquire(file->of_lock);
+	
+	/* based on the type of seek, set the retval */ 
+	switch (whence) {
+	    case SEEK_SET:
+		*retval = offset;
+		break;
+	    case SEEK_CUR:
+		*retval = file->of_offset + offset;
+		break;
+	    case SEEK_END:
+		result = VOP_STAT(file->of_vnode, &info);
+		if (result) {
+			lock_release(file->of_lock);
+			return result;
+		}
+		*retval = info.st_size + offset;
+		break;
+	    default:
+		lock_release(file->of_lock);
+		return EINVAL;
+	}
+
+	/* try the seek -- if it fails, return */
+	result = VOP_TRYSEEK(file->of_vnode, *retval);
+	if (result) {
+		lock_release(file->of_lock);
+		return result;
+	}
+	
+	/* success -- update the file structure */
+	file->of_offset = *retval;
+
+	lock_release(file->of_lock);
+
+	return 0;
+}
+
+/* 
+ * sys_dup2
+ * just pass the work off to the filetable
+ */
+int
+sys_dup2(int oldfd, int newfd, int *retval)
+{
+	int result;
+
+	result = filetable_dup2file(oldfd, newfd);
+	if (result) {
+		return result;
+	}
+
+	*retval = newfd;
+	return 0;
+}
+
+/* really not "file" calls, per se, but might as well put it here */
+
+/*
+ * sys_chdir
+ * copyin the path and pass it off to vfs.
+ */
+int
+sys_chdir(userptr_t path)
+{
+	char pathbuf[PATH_MAX];
+	int result;
+	
+	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+	if (result) {
+		return result;
+	}
+
+	return vfs_chdir(pathbuf);
+}
+
+/*
+ * sys___getcwd
+ * just use vfs_getcwd.
+ */
+int
+sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+{
+  struct iovec iov;
+	struct uio useruio;
+	int result;
+  
+  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+
+	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+
+	result = vfs_getcwd(&useruio);
+	if (result) {
+		return result;
+	}
+
+	*retval = buflen - useruio.uio_resid;
+
+	return 0;
+}
diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
new file mode 100644
index 0000000..9191f2c
--- /dev/null
+++ b/kern/syscall/proc_sys.c
@@ -0,0 +1,499 @@
+/*
+
+ * proc_sys.c
+ *
+ *  Created on: Mar 7, 2014
+ *      Author: trinity
+ */
+
+#include <types.h>
+#include<mips/trapframe.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+#include <test.h>
+#include <file.h>
+#include <synch.h>
+#include<copyinout.h>
+#include <spl.h>
+#include<kern/wait.h>
+
+extern struct process* p_table[17];
+
+//struct cv* wcv;
+
+extern pid_t pidcount;
+int mywait(struct process* mypro) {
+	//lock_acquire(mypro->tlock);
+	while (!mypro->exited) {
+		cv_wait(mypro->wcv, mypro->tlock);
+	}
+	//*status=mypro->exitcode;
+	//lock_release(mypro->tlock);
+	//int test = mypro->exitcode;
+	//test++;
+	return 0;
+}
+
+int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+	(void) adrs;
+	int flag;
+	pid_t childid;
+	struct addrspace *adrcopy;
+	struct trapframe* copyt = (struct trapframe*) kmalloc(sizeof(struct trapframe));
+	if(copyt==NULL)
+		return ENOMEM;
+	bzero(copyt, sizeof(struct trapframe));
+
+	//struct filetable* copyft;
+	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+
+	memcpy(copyt, tf, sizeof(struct trapframe));
+	flag = as_copy(curthread->t_addrspace, &adrcopy);
+	if(flag)
+		return flag;
+	//if(curthread->pid==0)
+	//{
+	//curthread->pid=PID_MIN;
+	//}
+	if (flag) {
+		kfree(copyt);
+		return flag;
+	}
+
+	//we need to allocate pid for our new process
+
+	//pid_t cpid;
+	/*
+	for (childid = 0; childid <= 16; childid++) {
+		if (p_table[childid] == NULL ) {
+			p_table[childid] = (struct process*) kmalloc(
+					sizeof(struct process));
+			if(p_table[childid]==NULL)
+			{
+				return ENOMEM;
+			}
+			p_table[childid]->full = 1;
+			pidcount++;
+			p_table[childid]->pid = pidcount;
+			p_table[childid]->ppid = curthread->pid;
+			//p_table[childid]->exitsem=sem_create("process",0);
+			p_table[childid]->tlock = lock_create("My Lock");
+			if(p_table[childid]==NULL)
+			{
+				return ENOMEM;
+			}
+			p_table[childid]->wcv = cv_create("My CV");
+			if(p_table[childid]==NULL)
+				return ENOMEM;
+			p_table[childid]->self = NULL;
+			break;
+		}
+	}
+	if (childid > PID_MAX) {
+		//retval = 1;
+		return EMPROC;
+	}
+	*/
+	//int i;
+
+	//copyt->tf_a0 = (int) p_table[childid]->pid;
+	//kprintf("Ret:%d\n",copyt->tf_a0);
+	struct thread *new_proc;
+	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+	//int s=splhigh();
+	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+			(unsigned long) adrcopy, &new_proc);
+	//kprintf("Out of thread fork:%d\n",flag);
+	if (flag) {
+		kfree(copyt);
+		as_destroy(adrcopy);
+
+		return flag;
+	}
+
+
+	for (childid = 0; childid <= 16; childid++) {
+			if (p_table[childid] == NULL ) {
+				p_table[childid] = (struct process*) kmalloc(
+						sizeof(struct process));
+				if(p_table[childid]==NULL)
+				{
+					return ENOMEM;
+				}
+				p_table[childid]->full = 1;
+				pidcount++;
+				p_table[childid]->pid = pidcount;
+				p_table[childid]->ppid = curthread->pid;
+				//p_table[childid]->exitsem=sem_create("process",0);
+				p_table[childid]->tlock = lock_create("My Lock");
+				if(p_table[childid]->tlock==NULL)
+				{
+					return ENOMEM;
+				}
+				p_table[childid]->wcv = cv_create("My CV");
+				if(p_table[childid]->wcv==NULL)
+					return ENOMEM;
+				p_table[childid]->self = NULL;
+				break;
+			}
+		}
+		if (childid > PID_MAX) {
+			//*retval = 1;
+			return EMPROC;
+		}
+
+	//new_proc->pid=(pid_t)childid;
+	//new_proc=p_table[childid];
+
+	new_proc->pid = p_table[childid]->pid;
+	new_proc->proc = p_table[childid];
+	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+	//if (new_proc->t_filetable == NULL) {
+	//return ENOMEM;
+	//}
+	p_table[childid]->self = new_proc;
+
+	//new_proc->pid=p_table[childid]->pid;
+	//new_proc->proc->pid=p_table[childid]->pid;
+	//kprintf("Child id in fork: %d\n",new_proc->pid);
+
+	//kprintf("Child id:%d",new_proc->pid);
+	//new_proc->t_filetable->
+	//for(i=0;i<128;i++)
+	//{
+	flag = filetable_copy(&new_proc->t_filetable);
+	//}
+	//splx(s);
+	// kprintf("Fork over!");
+
+	*retval = p_table[childid]->pid;
+	//kprintf("Return val in fork:%d",*retval);
+	return 0;
+
+	//flag=
+	//flag=thread_fork=
+}
+
+int sys_execv(char *progname, char** arguments) {
+
+	int flag;
+	int numargs;
+	int addr;
+	int i;
+	// first we need to copy the program name to the kernel space
+	// then we go for arguments. Path size unknown
+
+	size_t actual_size = 0;
+	char *namedes;
+
+	if (progname == NULL ) {
+		return EFAULT;
+	}
+	if (progname == "") {
+		return EINVAL;
+	}
+
+	namedes = (char*) kmalloc(PATH_MAX);
+	if(namedes==NULL)
+	{
+		return ENOMEM;
+	}
+	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+			&actual_size);
+	if (flag != 0) {
+		kfree(namedes);
+		return flag;
+	}
+	//namedes[actual_size]
+	if (strlen(namedes) == 0) {
+		//*retval=1;
+		return EISDIR;
+	}
+
+	// now we open file using vfs_open. Same as runprogram
+	struct vnode* vn;
+	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+	if (flag) {
+		return flag;
+	}
+	actual_size = 0;
+	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+
+	//char** kargv=(char**)kmalloc(sizeof(char));
+	// get the number of arguments
+	if (arguments == NULL ) {
+		kfree(namedes);
+		return EFAULT;
+	}
+	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+	if (flag) {
+		kfree(namedes);
+		return EFAULT;
+	}
+
+	//check=wthread->exitcode;
+	//err=copyout(&check,(userptr_t)status,sizeof(check));
+	//if(err)
+	//{
+	//	lock_release(p_table[i]->tlock);
+	//return err;
+	//}
+
+	numargs = 0;
+	while (arguments[numargs] != NULL ) {
+		//kprintf("%");
+		numargs = numargs + 1;
+	}
+
+	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+	//int i;
+	for (i = 0; i < numargs; i++) {
+		actual_size = 0;
+		kargv[i] = (char*) kmalloc(PATH_MAX);
+		if(kargv==NULL)
+			return ENOMEM;
+		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+				&actual_size);
+		if (flag) {
+			kfree(kargv);
+			kfree(namedes);
+			return EFAULT;
+		}
+
+	}
+	actual_size = 0;
+
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace == NULL ) {
+		vfs_close(vn);
+		return ENOMEM;
+	}
+
+	vaddr_t entrypoint, stackptr;
+	as_activate(curthread->t_addrspace);
+	flag = load_elf(vn, &entrypoint);
+	if (flag) {
+		// thread_exit destroys curthread->t_addrspace
+		vfs_close(vn);
+		return flag;
+	}
+
+	vfs_close(vn);
+
+	// now set up the user stack with the arguments
+	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (flag) {
+		//thread_exit destroys curthread->t_addrspace
+		return flag;
+	}
+
+	//i=0;
+	vaddr_t stackptrv[numargs + 1];
+
+	for (i = numargs - 1; i >= 0; i--) {
+		int len = strlen(kargv[i]);
+		int padder=0;
+		len++;// to account for string terminator
+		//if(len%4!=0)
+		padder = len % 4;
+		//stackptr=stackptr-(len+padder)
+		stackptr =stackptr-( len + (4-padder));
+
+		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+				&actual_size);
+
+		if (flag)
+		{
+			kfree(kargv);
+			kfree(namedes);
+			return flag;
+		}
+
+		stackptrv[i] = stackptr;
+	}
+	stackptrv[numargs] = 0;
+
+	//This copies the actual stack addresses of the arguments
+	//* into the stack. Hopefully.
+
+	 for(i = numargs; i >= 0; i--)
+	 {
+	 stackptr -= sizeof(vaddr_t);
+	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+
+	 if(flag)
+	 {
+	 kfree(kargv);
+	 kfree(namedes);
+	 return flag;
+	 }
+	 }
+
+	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+	//pt_getthread();
+
+	//enter_new_process does not return.
+	panic("enter_new_process returned\n");
+	return EINVAL;
+
+}
+
+int sys_getpid(pid_t *retval) {
+	//kprintf("In get pid:%d\n",curthread->pid);
+	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+
+	*retval = curthread->proc->pid;
+	return 0;
+}
+
+int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+	struct process* wthread = NULL;
+	int check;
+	int err;
+	pid_t i;
+	//kprintf("PID in wait pid:%d\n",pid);
+	if (status == NULL )
+		return EFAULT;
+	if (options != 0)
+		return EINVAL;
+	if (pid == curthread->pid)
+		return ECHILD;
+	if (pid < PID_MIN || pid > PID_MAX)
+		return ESRCH;
+	if (status == NULL )
+		return EFAULT;
+	if (pid == curthread->proc->ppid)
+		return ECHILD;
+	//int *shit;
+	//*shit=(int)&status;
+	//kprintf("%d\n",*shit);
+	//if(curthread->)
+	//if(pid!=curthread->)
+	//char* argv=(char*)(status);
+	//int length=strlen(argv)+1;
+	//int length=strlen(kargv[i])+1;
+	//int padder=length%4;
+	//kprintf("Hai:%d\n",padder);
+	//if(padder!=0)
+	//{
+	//return EFAULT;
+	//}
+
+	//if()
+
+	//char pathbuf[PATH_MAX];
+	//int *buffer;
+	//int result;
+
+	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+	//if (result) {
+	//return result;
+	//}
+	//int addr=(int)&status;
+	//kprintf("Status:%d\n",addr);
+	//int *addr=&status;
+	//if(addr%4!=0)
+	//{
+	//return EFAULT;
+	//}
+	//kprintf("Got Here\n");
+	for (i = 0; i <= 16; i++) {
+		if (p_table[i] != NULL ) {
+			if (p_table[i]->pid == pid) {
+				wthread = p_table[i];
+				break;
+			}
+		}
+	}
+	if (wthread == NULL ) {
+		return ESRCH;
+	}
+	if (curthread->proc->pid != wthread->ppid)
+		return ECHILD;
+	//panic("We are here");
+
+	lock_acquire(p_table[i]->tlock);
+
+	//while(!wthread->exited)
+	//{
+//
+	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+	//}
+	mywait(wthread);
+
+	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+	//kprintf("We are here!");
+
+	check = wthread->exitcode;
+	err = copyout(&check, (userptr_t) status, sizeof(check));
+	if (err) {
+		lock_release(p_table[i]->tlock);
+		return err;
+	}
+	//kprintf("Exit code After waiting:%d\n",*status);
+	//kfree(p_table[i]->exitsem);
+	//p_table[i]=NULL;
+
+	//panic("After kfree");
+	//p_table[i]=NULL;
+	lock_release(p_table[i]->tlock);
+	//filetable_destroy(p_table[i]->self->t_filetable);
+	//lock_destroy(p_table[i]->tlock);
+	//cv_destroy(p_table[i]->wcv);
+	//kfree(p_table[i]);
+	p_table[i] = NULL;
+
+	*retval = pid;
+	//panic("After dereferencing");
+	return 0;
+
+	//return -1;
+	//return 0;
+}
+
+void sys_exit(int exitcode) {
+	pid_t pid = curthread->proc->pid;
+	pid_t i = PID_MIN;
+	struct process* ethread=NULL;
+//pid_t parent;
+//if(pid!=2)
+//{
+	for (i = 0; i <= 16; i++) {
+		if (p_table[i] != NULL ) {
+			if (p_table[i]->pid == pid) {
+				ethread = p_table[i];
+				break;
+			}
+		}
+	}
+
+//parent=ethread->ppid;
+	if (ethread != NULL ) {
+		lock_acquire(ethread->tlock);
+//kprintf("Exit code Before:%d\n",exitcode);
+
+		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+//kprintf("Exitcode After:%d\n",ethread->exitcode);
+		ethread->exited = 1;
+//p_table[i]=ethread;
+		cv_broadcast(ethread->wcv, ethread->tlock);
+//kfree(curthread->t_filetable);
+		lock_release(ethread->tlock);
+	}
+//}
+	i = 0;
+//
+//kprintf("Before hanging");
+//filetable_destroy(curthread->t_filetable);
+//kfree(curthread->p);
+
+	thread_exit();
+}
+
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..6d6dc37 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,6 +44,8 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
+#include <file.h>
+#include<copyinout.h>
 
 /*
  * Load program "progname" and start running it in usermode.
@@ -52,7 +54,7 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname,char**argv,unsigned long argc)
 {
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
@@ -66,6 +68,13 @@ runprogram(char *progname)
 
 	/* We should be a new thread. */
 	KASSERT(curthread->t_addrspace == NULL);
+	curthread->t_filetable=NULL;
+  if (curthread->t_filetable == NULL) {
+		result = filetable_init("con:", "con:", "con:");
+		if (result) {
+			return result;
+		}
+	}
 
 	/* Create a new address space. */
 	curthread->t_addrspace = as_create();
@@ -94,9 +103,40 @@ runprogram(char *progname)
 		/* thread_exit destroys curthread->t_addrspace */
 		return result;
 	}
+	vaddr_t stackptrv[argc+1];
+int i;
+size_t actual;
+for(i = argc-1; i >= 0; i--)
+{
+int len = strlen(argv[i]);
+int padder=0;
+len++;
+if(len%4!=0)
+padder = len % 4;
+stackptr=stackptr-( len + (4-padder));
+result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+if(result)
+{
+return result;
+}
+stackptrv[i] = stackptr;
+}
+stackptrv[argc] = 0;
+for(i = argc; i >= 0; i--)
+{
+stackptr -= sizeof(vaddr_t);
+result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+if(result)
+{
+return result;
+}
+}
+
+
+
 
 	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+	enter_new_process(argc, (userptr_t)stackptr,
 			  stackptr, entrypoint);
 	
 	/* enter_new_process does not return. */
diff --git a/kern/syscall/runprogram1.c b/kern/syscall/runprogram1.c
new file mode 100644
index 0000000..2152aba
--- /dev/null
+++ b/kern/syscall/runprogram1.c
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Sample/test code for running a user program.  You can use this for
+ * reference when implementing the execv() system call. Remember though
+ * that execv() needs to do more than this function does.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+#include <test.h>
+#include <file.h>
+#include<synch.h>
+#include<copyinout.h>
+//extern pid_t pidcount;
+//extern struct process* p_table[17];
+/*
+ * Load program "progname" and start running it in usermode.
+ * Does not return except on error.
+ *
+ * Calls vfs_open on progname and thus may destroy it.
+ */
+
+int
+runprogram(char *progname,char** arguments)
+{
+	//int firstid;
+	struct vnode *v;
+	vaddr_t entrypoint, stackptr;
+	int result;
+	int i;
+	int numargs;
+	size_t actual_size=0;
+	//int argc1=(int)argc;
+	//curthread->pid=PID_MIN;
+	//curthread->proc=(struct process*)kmalloc(sizeof(struct process));
+	//curthread->proc->pid=PID_MIN;
+
+	//for(firstid=0;firstid<16;firstid++)
+	//{
+	    // if(p_table[firstid]==NULL)
+	     //{
+	    	//p_table[firstid]=(struct process*)kmalloc(sizeof(struct process));
+	    	//p_table[firstid]->full=1;
+	    	//pidcount++;
+	    	//p_table[firstid]->pid=PID_MIN;
+	    	//p_table[firstid]->ppid=1;
+	    	//p_table[childid]->exitsem=sem_create("process",0);
+	    	//p_table[firstid]->tlock=lock_create("My Lock");
+	    	//p_table[firstid]->wcv=cv_create("My CV");
+	    	//p_table[firstid]->self=curthread;
+	    	//break;
+	     //}
+	//}
+	//pidcount++;
+	//curthread->proc->full=1;
+	//curthread->proc->ppid=-1;
+	//curthread->proc->self=curthread;
+	//curthread->proc->tlock=lock_create("My Lock");
+	//curthread->proc->wcv=cv_create("My CV");
+	//p_table[PID_MIN]=curthread->proc;
+	//p_table[c]->full=1;
+	//pidcount++;
+	//p_table[childid]->pid=pidcount;
+	//p_table[childid]->ppid=curthread->pid;
+	    	//p_table[childid]->exitsem=sem_create("process",0);
+	//p_table[childid]->tlock=lock_create("My Lock");
+	//p_table[childid]->wcv=cv_create("My CV");
+	//p_table[childid]->self=NULL;
+
+	/* Open the file. */
+	result = vfs_open(progname, O_RDONLY, 0, &v);
+	if (result) {
+		return result;
+	}
+
+	/* We should be a new thread. */
+	KASSERT(curthread->t_addrspace == NULL);
+	curthread->t_filetable=NULL;
+  if (curthread->t_filetable == NULL) {
+		result = filetable_init("con:", "con:", "con:");
+		if (result) {
+			return result;
+		}
+	}
+
+  /*char** kargv=(char**)kmalloc(sizeof(char*)*argc1);
+  /for(i=0;i<argc1;i++)
+  	{
+  		actual_size=0;
+  		kargv[i]=(char*)kmalloc(PATH_MAX);
+  		result=copyinstr((userptr_t)argv[i],kargv[i],PATH_MAX,&actual_size);
+  		if(result)
+  		{
+  			kfree(kargv);
+  			//kfree(namedes);
+  			return EFAULT;
+  		}
+
+  	}
+  	actual_size=0;
+  	*/
+
+	/* Create a new address space. */
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace==NULL) {
+		vfs_close(v);
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_addrspace);
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(v);
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+
+
+
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		return result;
+	}
+	numargs=0;
+		while(arguments[numargs]!=NULL)
+		{
+			//kprintf("%");
+			numargs=numargs+1;
+		}
+		char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
+		//int i;
+		//for(i=0;i<numargs;i++)
+		//{
+			//actual_size=0;
+			kargv[0]=(char*)kmalloc(PATH_MAX);
+			//result=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
+			memcpy((void*)kargv,(const void*)arguments,sizeof(arguments[0]));
+			//if(result)
+			//{
+				//kfree(kargv);
+				//kfree(namedes);
+				//return EFAULT;
+			//}
+
+		//}
+			//kprintf(%)
+		actual_size=0;
+
+	for(i=numargs-1;i>=0;i--)
+			{
+				actual_size=0;
+				int length=strlen(kargv[i])+1;
+				//int length=strlen(kargv[i]);
+				int padder=length%4;
+				if(padder!=0)
+				length=length+padder;
+				copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
+				//stackptr=stackptr+length;
+				stackptr=stackptr-length;
+
+
+			}
+
+
+	/* Warp to user mode. */
+	enter_new_process(numargs, (userptr_t)stackptr,
+			  stackptr, entrypoint);
+	
+	/* enter_new_process does not return. */
+	panic("enter_new_process returned\n");
+	return EINVAL;
+}
+
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..851f9ea 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -40,6 +40,8 @@
 #include <current.h>
 #include <synch.h>
 
+#define MAXREADERS 20;
+
 ////////////////////////////////////////////////////////////
 //
 // Semaphore.
@@ -162,9 +164,17 @@ lock_create(const char *name)
                 kfree(lock);
                 return NULL;
         }
-        
-        // add stuff here as needed
-        
+        lock->mut_wchan = wchan_create(lock->lk_name);
+        	if (lock->mut_wchan == NULL) {
+        		kfree(lock->lk_name);
+        		kfree(lock);
+        		return NULL;
+        	}
+
+        	spinlock_init(&lock->mut_lock);
+                lock->hold = 0;
+		lock->holder=NULL;
+        //lock->=NULL
         return lock;
 }
 
@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
 
         // add stuff here as needed
         
+        spinlock_cleanup(&lock->mut_lock);
+        	wchan_destroy(lock->mut_wchan);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -183,26 +195,78 @@ void
 lock_acquire(struct lock *lock)
 {
         // Write this
+KASSERT(lock!=NULL);
+
+
+//KASSERT(sem != NULL);
+
+        
+        KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&lock->mut_lock);
+        while (lock->hold ) {
+		
+		wchan_lock(lock->mut_wchan);
+		spinlock_release(&lock->mut_lock);
+                wchan_sleep(lock->mut_wchan);
+
+		spinlock_acquire(&lock->mut_lock);
+        }
+        KASSERT(lock->hold ==0 );
+        lock->hold=1;
+	lock->holder=curthread;
+        //sem->sem_count--;
+	spinlock_release(&lock->mut_lock);
 
-        (void)lock;  // suppress warning until code gets written
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
+	KASSERT(lock!=NULL);
+	KASSERT(lock->hold);
+	KASSERT(lock_do_i_hold(lock));
+	spinlock_acquire(&lock->mut_lock);
+	lock->hold=0;
+	
+	        //sem->sem_count++;
+	        KASSERT(lock->hold == 0);
+lock->holder=NULL;
+		wchan_wakeone(lock->mut_wchan);
+
+		spinlock_release(&lock->mut_lock);
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+	/*
+	
+	KASSERT(lock!=NULL);
+	KASSERT(lock->lockNeed==curthread);
+	spinlock_acquire(&lock->lockNeed);
+	lock->lockNeed==NULL;
+	
+	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+	spinlock_release(&lock->lockNeed);
+*/
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+	
+
+        //(void)lock;  // suppress warning until code gets written
+	KASSERT(lock!=NULL);
+	//spinlock_acquire(&lock->mut_lock);
+	if(!lock->hold) return false;
+if(lock->holder==curthread) return true;
+else 
+return false;
+	
+    //spinlock_release(&lock->mut_lock);
+    
+        //return res; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -225,7 +289,18 @@ cv_create(const char *name)
                 kfree(cv);
                 return NULL;
         }
-        
+        cv->cv_wchan = wchan_create(cv->cv_name);
+                	if (cv->cv_wchan == NULL) {
+                		kfree(cv->cv_name);
+                		kfree(cv);
+                		return NULL;
+                	}
+
+                	//spinlock_init(&cv->cv_lock);
+                        //lock->hold = 0;
+        		//lock->holder=NULL;
+                //lock->=NULL
+                return cv;
         // add stuff here as needed
         
         return cv;
@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
 
         // add stuff here as needed
         
+        //spinlock_cleanup(&cv->cv_lock);
+        
+        wchan_destroy(cv->cv_wchan);
         kfree(cv->cv_name);
         kfree(cv);
 }
@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+	KASSERT(cv!=NULL);
+	KASSERT(lock!=NULL);
+	//KASSERT(lock_do_i_hold(lock));
+	wchan_lock(cv->cv_wchan);
+	lock_release(lock);
+	
+	wchan_sleep(cv->cv_wchan);
+	lock_acquire(lock);
+	
+    // Write this
+    //(void)cv;    // suppress warning until code gets written
+    //(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
         // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv!=NULL);
+	KASSERT(lock!=NULL);
+	KASSERT(lock_do_i_hold(lock));
+	wchan_wakeone(cv->cv_wchan);
+	
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv!=NULL);
+	KASSERT(lock!=NULL);
+	KASSERT(lock_do_i_hold(lock));
+	wchan_wakeall(cv->cv_wchan);
+		
+	
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
+}
+
+struct rwlock *rwlock_create(const char *name)
+{
+	struct rwlock *rw;
+	rw=kmalloc(sizeof(struct rwlock));
+	if(rw==NULL)
+	{
+		return NULL;
+	}
+	rw->rwlock_name=kstrdup(name);
+	if(rw->rwlock_name==NULL)
+	{
+		kfree(rw);
+		return NULL;
+	}
+	rw->rd_wchan=wchan_create(rw->rwlock_name);
+	if(rw->rd_wchan==NULL)
+	{
+		kfree(rw->rwlock_name);
+		kfree(rw);
+		return NULL;
+	}
+	rw->wr_wchan=wchan_create(rw->rwlock_name);
+		if(rw->wr_wchan==NULL)
+		{
+			kfree(rw->rwlock_name);
+			kfree(rw);
+			return NULL;
+		}
+		rw->rw_sem=sem_create("mysem",20);
+		rw->rw_lock=lock_create("mylock");
+	///rw->res_count=MAXREADERS;
+	return rw;
+	
+}
+void rwlock_destroy(struct rwlock *rw)
+{
+		KASSERT(rw != NULL);
+		
+		wchan_destroy(rw->rd_wchan);
+		wchan_destroy(rw->wr_wchan);
+		sem_destroy(rw->rw_sem);
+		lock_destroy(rw->rw_lock);
+	    kfree(rw->rwlock_name);
+        kfree(rw);	
+}
+
+void rwlock_acquire_read(struct rwlock *rw)
+{
+	KASSERT(rw!=NULL);
+	lock_acquire(rw->rw_lock);
+	P(rw->rw_sem);
+	lock_release(rw->rw_lock);
+}
+void rwlock_release_read(struct rwlock *rw)
+{
+	KASSERT(rw!=NULL);
+	//lock_acquire(rw->rw_lock);
+	V(rw->rw_sem);
+	//lock_release(rw->rw_lock);
+}
+void rwlock_acquire_write(struct rwlock *rw)
+{
+	int i;
+	KASSERT(rw!=NULL);
+	lock_acquire(rw->rw_lock);
+	//rwlock->rw_sem->V();
+	for(i=0;i<20;i++)
+	{
+	P(rw->rw_sem);
+	}	
+	lock_release(rw->rw_lock);
+	
+	
 }
+void rwlock_release_write(struct rwlock *rw)
+{
+	int i;
+	KASSERT(rw!=NULL);
+	//lock_acquire(rw->rw_lock);
+	for(i=0;i<20;i++)
+	{
+	V(rw->rw_sem);
+	}	
+	//lock_release(rw->rw_lock);
+	
+}
+
+
+
+
+
+
+
+
+
+
diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
new file mode 100644
index 0000000..b9680d1
--- /dev/null
+++ b/kern/thread/synch.c~
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Synchronization primitives.
+ * The specifications of the functions are in synch.h.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <spinlock.h>
+#include <wchan.h>
+#include <thread.h>
+#include <current.h>
+#include <synch.h>
+
+////////////////////////////////////////////////////////////
+//
+// Semaphore.
+
+struct semaphore *
+sem_create(const char *name, int initial_count)
+{
+        struct semaphore *sem;
+
+        KASSERT(initial_count >= 0);
+
+        sem = kmalloc(sizeof(struct semaphore));
+        if (sem == NULL) {
+                return NULL;
+        }
+
+        sem->sem_name = kstrdup(name);
+        if (sem->sem_name == NULL) {
+                kfree(sem);
+                return NULL;
+        }
+
+	sem->sem_wchan = wchan_create(sem->sem_name);
+	if (sem->sem_wchan == NULL) {
+		kfree(sem->sem_name);
+		kfree(sem);
+		return NULL;
+	}
+
+	spinlock_init(&sem->sem_lock);
+        sem->sem_count = initial_count;
+
+        return sem;
+}
+
+void
+sem_destroy(struct semaphore *sem)
+{
+        KASSERT(sem != NULL);
+
+	/* wchan_cleanup will assert if anyone's waiting on it */
+	spinlock_cleanup(&sem->sem_lock);
+	wchan_destroy(sem->sem_wchan);
+        kfree(sem->sem_name);
+        kfree(sem);
+}
+
+void 
+P(struct semaphore *sem)
+{
+        KASSERT(sem != NULL);
+
+        /*
+         * May not block in an interrupt handler.
+         *
+         * For robustness, always check, even if we can actually
+         * complete the P without blocking.
+         */
+        KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&sem->sem_lock);
+        while (sem->sem_count == 0) {
+		/*
+		 * Bridge to the wchan lock, so if someone else comes
+		 * along in V right this instant the wakeup can't go
+		 * through on the wchan until we've finished going to
+		 * sleep. Note that wchan_sleep unlocks the wchan.
+		 *
+		 * Note that we don't maintain strict FIFO ordering of
+		 * threads going through the semaphore; that is, we
+		 * might "get" it on the first try even if other
+		 * threads are waiting. Apparently according to some
+		 * textbooks semaphores must for some reason have
+		 * strict ordering. Too bad. :-)
+		 *
+		 * Exercise: how would you implement strict FIFO
+		 * ordering?
+		 */
+		wchan_lock(sem->sem_wchan);
+		spinlock_release(&sem->sem_lock);
+                wchan_sleep(sem->sem_wchan);
+
+		spinlock_acquire(&sem->sem_lock);
+        }
+        KASSERT(sem->sem_count > 0);
+        sem->sem_count--;
+	spinlock_release(&sem->sem_lock);
+}
+
+void
+V(struct semaphore *sem)
+{
+        KASSERT(sem != NULL);
+
+	spinlock_acquire(&sem->sem_lock);
+
+        sem->sem_count++;
+        KASSERT(sem->sem_count > 0);
+	wchan_wakeone(sem->sem_wchan);
+
+	spinlock_release(&sem->sem_lock);
+}
+
+////////////////////////////////////////////////////////////
+//
+// Lock.
+
+struct lock *
+lock_create(const char *name)
+{
+        struct lock *lock;
+
+        lock = kmalloc(sizeof(struct lock));
+        if (lock == NULL) {
+                return NULL;
+        }
+
+        lock->lk_name = kstrdup(name);
+        if (lock->lk_name == NULL) {
+                kfree(lock);
+                return NULL;
+        }
+        lock->mut_wchan = wchan_create(lock->lk_name);
+        	if (lock->mut_wchan == NULL) {
+        		kfree(lock->lk_name);
+        		kfree(lock);
+        		return NULL;
+        	}
+
+        	spinlock_init(&lock->mut_lock);
+                lock->hold = 0;
+		lock->holder=NULL;
+        //lock->=NULL
+        return lock;
+}
+
+void
+lock_destroy(struct lock *lock)
+{
+        KASSERT(lock != NULL);
+
+        // add stuff here as needed
+        
+        spinlock_cleanup(&lock->mut_lock);
+        	wchan_destroy(lock->mut_wchan);
+        kfree(lock->lk_name);
+        kfree(lock);
+}
+
+void
+lock_acquire(struct lock *lock)
+{
+        // Write this
+KASSERT(lock!=NULL);
+
+
+//KASSERT(sem != NULL);
+
+        
+        KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&lock->mut_lock);
+        while (lock->hold ) {
+		
+		wchan_lock(lock->mut_wchan);
+		spinlock_release(&lock->mut_lock);
+                wchan_sleep(lock->mut_wchan);
+
+		spinlock_acquire(lock->mut_lock);
+        }
+        KASSERT(lock->hold ==0 );
+        lock->hold=1;
+	lock->holder=curthread;
+        //sem->sem_count--;
+	spinlock_release(&lock->mut_lock);
+
+        //(void)lock;  // suppress warning until code gets written
+}
+
+void
+lock_release(struct lock *lock)
+{
+	KASSERT(lock!=NULL);
+	KASSERT(lock->hold);
+	KASSERT(lock_do_i_hold(lock));
+	spinlock_acquire(&lock->mut_lock);
+	lock->hold=0;
+	
+	        //sem->sem_count++;
+	        KASSERT(lock->hold == 0);
+lock->holder=NULL;
+		wchan_wakeone(lock->mut_wchan);
+
+		spinlock_release(&lock->mut_lock);
+        // Write this
+	/*
+	
+	KASSERT(lock!=NULL);
+	KASSERT(lock->lockNeed==curthread);
+	spinlock_acquire(&lock->lockNeed);
+	lock->lockNeed==NULL;
+	
+	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+	spinlock_release(&lock->lockNeed);
+*/
+        //(void)lock;  // suppress warning until code gets written
+}
+
+bool
+lock_do_i_hold(struct lock *lock)
+{
+        // Write this
+	
+
+        //(void)lock;  // suppress warning until code gets written
+	KASSERT(lock!=NULL);
+	//spinlock_acquire(&lock->mut_lock);
+	if(!lock->hold) return false;
+if(lock->holder==curthread) return true;
+else 
+return false;
+	
+    //spinlock_release(&lock->mut_lock);
+    
+        //return res; // dummy until code gets written
+}
+
+////////////////////////////////////////////////////////////
+//
+// CV
+
+
+struct cv *
+cv_create(const char *name)
+{
+        struct cv *cv;
+
+        cv = kmalloc(sizeof(struct cv));
+        if (cv == NULL) {
+                return NULL;
+        }
+
+        cv->cv_name = kstrdup(name);
+        if (cv->cv_name==NULL) {
+                kfree(cv);
+                return NULL;
+        }
+        
+        // add stuff here as needed
+        
+        return cv;
+}
+
+void
+cv_destroy(struct cv *cv)
+{
+        KASSERT(cv != NULL);
+
+        // add stuff here as needed
+        
+        kfree(cv->cv_name);
+        kfree(cv);
+}
+
+void
+cv_wait(struct cv *cv, struct lock *lock)
+{
+        // Write this
+        (void)cv;    // suppress warning until code gets written
+        (void)lock;  // suppress warning until code gets written
+}
+
+void
+cv_signal(struct cv *cv, struct lock *lock)
+{
+        // Write this
+	(void)cv;    // suppress warning until code gets written
+	(void)lock;  // suppress warning until code gets written
+}
+
+void
+cv_broadcast(struct cv *cv, struct lock *lock)
+{
+	// Write this
+	(void)cv;    // suppress warning until code gets written
+	(void)lock;  // suppress warning until code gets written
+}
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..f3918ab 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,6 +47,7 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <file.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
 
 /* Used to wait for secondary CPUs to come online. */
 static struct semaphore *cpu_startup_sem;
+pid_t pidcount;
+struct process* p_table[17];
 
 ////////////////////////////////////////////////////////////
 
@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
 
 /*
  * Check the magic number we put on the bottom end of the stack in
- * thread_checkstack_init. If these assertions go off, it most likely
+ * thread_checkstack_init. If these KASSERTions go off, it most likely
  * means you overflowed your stack at some point, which can cause all
  * kinds of mysterious other things to happen.
  *
@@ -262,6 +265,9 @@ thread_destroy(struct thread *thread)
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
 
+thread->t_filetable=NULL;
+  KASSERT(thread->t_filetable == NULL);
+
 	kfree(thread->t_name);
 	kfree(thread);
 }
@@ -352,8 +358,15 @@ thread_bootstrap(void)
 {
 	struct cpu *bootcpu;
 	struct thread *bootthread;
+	int i;
 
 	cpuarray_init(&allcpus);
+	pidcount=PID_MIN;
+
+	for(i=0;i<=16;i++)
+	{
+		p_table[i]=NULL;
+	}
 
 	/*
 	 * Create the cpu structure for the bootup CPU, the one we're
@@ -365,6 +378,7 @@ thread_bootstrap(void)
 	 */
 	bootcpu = cpu_create(0);
 	bootthread = bootcpu->c_curthread;
+	//bootthread->pid=PID_MIN;
 
 	/*
 	 * Initializing curcpu and curthread is machine-dependent
@@ -519,7 +533,7 @@ thread_fork(const char *name,
 	 * for the spllower() that will be done releasing it.
 	 */
 	newthread->t_iplhigh_count++;
-
+	//newthread->pid=pidcount++;
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
 
@@ -532,6 +546,7 @@ thread_fork(const char *name,
 	 * only with caution, because in general the child thread
 	 * might exit at any time.
 	 */
+
 	if (ret != NULL) {
 		*ret = newthread;
 	}
@@ -589,7 +604,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 	switch (newstate) {
 	    case S_RUN:
 		panic("Illegal S_RUN in thread_switch\n");
-		break;
 	    case S_READY:
 		thread_make_runnable(cur, true /*have lock*/);
 		break;
@@ -799,6 +813,11 @@ thread_exit(void)
 		VOP_DECREF(cur->t_cwd);
 		cur->t_cwd = NULL;
 	}
+	
+	if (curthread->t_filetable) {
+		filetable_destroy(curthread->t_filetable);
+		curthread->t_filetable = NULL;
+	}
 
 	/* VM fields */
 	if (cur->t_addrspace) {
diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
index 302fa7b..ca9992a 100644
--- a/kern/vm/addrspace.c
+++ b/kern/vm/addrspace.c
@@ -30,117 +30,295 @@
 #include <types.h>
 #include <kern/errno.h>
 #include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
 #include <addrspace.h>
 #include <vm.h>
 
 /*
- * Note! If OPT_DUMBVM is set, as is the case until you start the VM
- * assignment, this file is not compiled or linked or in any way
- * used. The cheesy hack versions in dumbvm.c are used instead.
+ * Dumb MIPS-only "VM system" that is intended to only be just barely
+ * enough to struggle off the ground. You should replace all of this
+ * code while doing the VM assignment. In fact, starting in that
+ * assignment, this file is not included in your kernel!
  */
 
-struct addrspace *
-as_create(void)
+/* under dumbvm, always have 48k of user stack */
+#define DUMBVM_STACKPAGES    12
+
+/*
+ * Wrap rma_stealmem in a spinlock.
+ */
+static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+
+void
+vm_bootstrap(void)
 {
-	struct addrspace *as;
+	/* Do nothing. */
+}
 
-	as = kmalloc(sizeof(struct addrspace));
-	if (as == NULL) {
-		return NULL;
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	paddr_t addr;
+
+	spinlock_acquire(&stealmem_lock);
+
+	addr = ram_stealmem(npages);
+	
+	spinlock_release(&stealmem_lock);
+	return addr;
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t 
+alloc_kpages(int npages)
+{
+	paddr_t pa;
+	pa = getppages(npages);
+	if (pa==0) {
+		return 0;
 	}
+	return PADDR_TO_KVADDR(pa);
+}
 
-	/*
-	 * Initialize as needed.
-	 */
+void 
+free_kpages(vaddr_t addr)
+{
+	/* nothing - leak the memory. */
 
-	return as;
+	(void)addr;
+}
+
+void
+vm_tlbshootdown_all(void)
+{
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+	(void)ts;
+	panic("dumbvm tried to do tlb shootdown?!\n");
 }
 
 int
-as_copy(struct addrspace *old, struct addrspace **ret)
+vm_fault(int faulttype, vaddr_t faultaddress)
 {
-	struct addrspace *newas;
+	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+	paddr_t paddr;
+	int i;
+	uint32_t ehi, elo;
+	struct addrspace *as;
+	int spl;
 
-	newas = as_create();
-	if (newas==NULL) {
-		return ENOMEM;
+	faultaddress &= PAGE_FRAME;
+
+	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+
+	switch (faulttype) {
+	    case VM_FAULT_READONLY:
+		/* We always create pages read-write, so we can't get this */
+		panic("dumbvm: got VM_FAULT_READONLY\n");
+	    case VM_FAULT_READ:
+	    case VM_FAULT_WRITE:
+		break;
+	    default:
+		return EINVAL;
 	}
 
-	/*
-	 * Write this.
-	 */
+	as = curthread->t_addrspace;
+	if (as == NULL) {
+		/*
+		 * No address space set up. This is probably a kernel
+		 * fault early in boot. Return EFAULT so as to panic
+		 * instead of getting into an infinite faulting loop.
+		 */
+		return EFAULT;
+	}
 
-	(void)old;
-	
-	*ret = newas;
-	return 0;
+	/* Assert that the address space has been set up properly. */
+	KASSERT(as->as_vbase1 != 0);
+	KASSERT(as->as_pbase1 != 0);
+	KASSERT(as->as_npages1 != 0);
+	KASSERT(as->as_vbase2 != 0);
+	KASSERT(as->as_pbase2 != 0);
+	KASSERT(as->as_npages2 != 0);
+	KASSERT(as->as_stackpbase != 0);
+	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+
+	vbase1 = as->as_vbase1;
+	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+	vbase2 = as->as_vbase2;
+	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+	stacktop = USERSTACK;
+
+	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+		paddr = (faultaddress - vbase1) + as->as_pbase1;
+	}
+	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+		paddr = (faultaddress - vbase2) + as->as_pbase2;
+	}
+	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+	}
+	else {
+		return EFAULT;
+	}
+
+	/* make sure it's page-aligned */
+	KASSERT((paddr & PAGE_FRAME) == paddr);
+
+	/* Disable interrupts on this CPU while frobbing the TLB. */
+	spl = splhigh();
+
+	for (i=0; i<NUM_TLB; i++) {
+		tlb_read(&ehi, &elo, i);
+		if (elo & TLBLO_VALID) {
+			continue;
+		}
+		ehi = faultaddress;
+		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+		tlb_write(ehi, elo, i);
+		splx(spl);
+		return 0;
+	}
+
+	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+	splx(spl);
+	return EFAULT;
+}
+
+struct addrspace *
+as_create(void)
+{
+	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+	if (as==NULL) {
+		return NULL;
+	}
+
+	as->as_vbase1 = 0;
+	as->as_pbase1 = 0;
+	as->as_npages1 = 0;
+	as->as_vbase2 = 0;
+	as->as_pbase2 = 0;
+	as->as_npages2 = 0;
+	as->as_stackpbase = 0;
+
+	return as;
 }
 
 void
 as_destroy(struct addrspace *as)
 {
-	/*
-	 * Clean up as needed.
-	 */
-	
 	kfree(as);
 }
 
 void
 as_activate(struct addrspace *as)
 {
-	/*
-	 * Write this.
-	 */
+	int i, spl;
+
+	(void)as;
+
+	/* Disable interrupts on this CPU while frobbing the TLB. */
+	spl = splhigh();
 
-	(void)as;  // suppress warning until code gets written
+	for (i=0; i<NUM_TLB; i++) {
+		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+	}
+
+	splx(spl);
 }
 
-/*
- * Set up a segment at virtual address VADDR of size MEMSIZE. The
- * segment in memory extends from VADDR up to (but not including)
- * VADDR+MEMSIZE.
- *
- * The READABLE, WRITEABLE, and EXECUTABLE flags are set if read,
- * write, or execute permission should be set on the segment. At the
- * moment, these are ignored. When you write the VM system, you may
- * want to implement them.
- */
 int
 as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
 		 int readable, int writeable, int executable)
 {
-	/*
-	 * Write this.
-	 */
+	size_t npages; 
 
-	(void)as;
-	(void)vaddr;
-	(void)sz;
+	/* Align the region. First, the base... */
+	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+	vaddr &= PAGE_FRAME;
+
+	/* ...and now the length. */
+	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+	npages = sz / PAGE_SIZE;
+
+	/* We don't use these - all pages are read-write */
 	(void)readable;
 	(void)writeable;
 	(void)executable;
+
+	if (as->as_vbase1 == 0) {
+		as->as_vbase1 = vaddr;
+		as->as_npages1 = npages;
+		return 0;
+	}
+
+	if (as->as_vbase2 == 0) {
+		as->as_vbase2 = vaddr;
+		as->as_npages2 = npages;
+		return 0;
+	}
+
+	/*
+	 * Support for more than two regions is not available.
+	 */
+	kprintf("dumbvm: Warning: too many regions\n");
 	return EUNIMP;
 }
 
+static
+void
+as_zero_region(paddr_t paddr, unsigned npages)
+{
+	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+}
+
 int
 as_prepare_load(struct addrspace *as)
 {
-	/*
-	 * Write this.
-	 */
+	KASSERT(as->as_pbase1 == 0);
+	KASSERT(as->as_pbase2 == 0);
+	KASSERT(as->as_stackpbase == 0);
+
+	as->as_pbase1 = getppages(as->as_npages1);
+	if (as->as_pbase1 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_pbase2 = getppages(as->as_npages2);
+	if (as->as_pbase2 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+	if (as->as_stackpbase == 0) {
+		return ENOMEM;
+	}
+	
+	as_zero_region(as->as_pbase1, as->as_npages1);
+	as_zero_region(as->as_pbase2, as->as_npages2);
+	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
 
-	(void)as;
 	return 0;
 }
 
 int
 as_complete_load(struct addrspace *as)
 {
-	/*
-	 * Write this.
-	 */
-
 	(void)as;
 	return 0;
 }
@@ -148,15 +326,49 @@ as_complete_load(struct addrspace *as)
 int
 as_define_stack(struct addrspace *as, vaddr_t *stackptr)
 {
-	/*
-	 * Write this.
-	 */
+	KASSERT(as->as_stackpbase != 0);
 
-	(void)as;
-
-	/* Initial user-level stack pointer */
 	*stackptr = USERSTACK;
-	
 	return 0;
 }
 
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+	struct addrspace *new;
+
+	new = as_create();
+	if (new==NULL) {
+		return ENOMEM;
+	}
+
+	new->as_vbase1 = old->as_vbase1;
+	new->as_npages1 = old->as_npages1;
+	new->as_vbase2 = old->as_vbase2;
+	new->as_npages2 = old->as_npages2;
+
+	/* (Mis)use as_prepare_load to allocate some physical memory. */
+	if (as_prepare_load(new)) {
+		as_destroy(new);
+		return ENOMEM;
+	}
+
+	KASSERT(new->as_pbase1 != 0);
+	KASSERT(new->as_pbase2 != 0);
+	KASSERT(new->as_stackpbase != 0);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+		old->as_npages1*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+		old->as_npages2*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+		DUMBVM_STACKPAGES*PAGE_SIZE);
+	
+	*ret = new;
+	return 0;
+}
diff --git a/single10.patch b/single10.patch
new file mode 100644
index 0000000..2267436
--- /dev/null
+++ b/single10.patch
@@ -0,0 +1,915 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..68c73ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,6 +32,7 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++		break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++		break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++		break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++		break;
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..e1d7682 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,8 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..f3a01ad 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+ 
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..08b8f8c 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -112,6 +112,7 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..4ba181a 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,7 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -66,6 +67,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index 5b8099e..60108d3 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -798,6 +801,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..04fc72b
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,8279 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..33b99ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	int flag;
++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	if(flag)
++	{
++		newtf.tf_v0=ENOMEM;
++		newtf.tf_a3=1;
++	}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	curthread->pid=newtf.tf_a0;
++
++	as_activate(curthread->t_addrspace);
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..a4c2750 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	fthread->proc->tlock=lock_create("First Lock");
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..dfd7b53
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,445 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro) {
++	//lock_acquire(mypro->tlock);
++	while (!mypro->exited) {
++		cv_wait(mypro->wcv, mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++	(void) adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++			sizeof(struct trapframe));
++	bzero(copyt, sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt, tf, sizeof(struct trapframe));
++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++	//if(curthread->pid==0)
++	//{
++	//curthread->pid=PID_MIN;
++	//}
++	if (flag) {
++		kfree(copyt);
++		return flag;
++	}
++
++	//we need to allocate pid for our new process
++
++	//pid_t cpid;
++	for (childid = 0; childid <= 16; childid++) {
++		if (p_table[childid] == NULL ) {
++			p_table[childid] = (struct process*) kmalloc(
++					sizeof(struct process));
++			p_table[childid]->full = 1;
++			pidcount++;
++			p_table[childid]->pid = pidcount;
++			p_table[childid]->ppid = curthread->pid;
++			//p_table[childid]->exitsem=sem_create("process",0);
++			p_table[childid]->tlock = lock_create("My Lock");
++			p_table[childid]->wcv = cv_create("My CV");
++			p_table[childid]->self = NULL;
++			break;
++		}
++	}
++	if (childid > PID_MAX) {
++		*retval = 1;
++		return EMPROC;
++	}
++	//int i;
++
++	copyt->tf_a0 = (int) p_table[childid]->pid;
++	//kprintf("Ret:%d\n",copyt->tf_a0);
++	struct thread *new_proc;
++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++	//int s=splhigh();
++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++			(unsigned long) adrcopy, &new_proc);
++	//kprintf("Out of thread fork:%d\n",flag);
++	if (flag) {
++		kfree(copyt);
++		as_destroy(adrcopy);
++
++		return flag;
++	}
++
++	//new_proc->pid=(pid_t)childid;
++	//new_proc=p_table[childid];
++
++	new_proc->pid = p_table[childid]->pid;
++	new_proc->proc = p_table[childid];
++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++	//if (new_proc->t_filetable == NULL) {
++	//return ENOMEM;
++	//}
++	p_table[childid]->self = new_proc;
++
++	//new_proc->pid=p_table[childid]->pid;
++	//new_proc->proc->pid=p_table[childid]->pid;
++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++
++	//kprintf("Child id:%d",new_proc->pid);
++	//new_proc->t_filetable->
++	//for(i=0;i<128;i++)
++	//{
++	flag = filetable_copy(&new_proc->t_filetable);
++	//}
++	//splx(s);
++	// kprintf("Fork over!");
++
++	*retval = p_table[childid]->pid;
++	//kprintf("Return val in fork:%d",*retval);
++	return 0;
++
++	//flag=
++	//flag=thread_fork=
++}
++
++int sys_execv(char *progname, char** arguments) {
++
++	int flag;
++	int numargs;
++	int addr;
++	int i;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size = 0;
++	char *namedes;
++
++	if (progname == NULL ) {
++		return EFAULT;
++	}
++	if (progname == "") {
++		return EINVAL;
++	}
++
++	namedes = (char*) kmalloc(PATH_MAX);
++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++			&actual_size);
++	if (flag != 0) {
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if (strlen(namedes) == 0) {
++		//*retval=1;
++		return EISDIR;
++	}
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++	if (flag) {
++		return flag;
++	}
++	actual_size = 0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++	if (arguments == NULL ) {
++		kfree(namedes);
++		return EFAULT;
++	}
++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++	if (flag) {
++		kfree(namedes);
++		return EFAULT;
++	}
++
++	//check=wthread->exitcode;
++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++	//if(err)
++	//{
++	//	lock_release(p_table[i]->tlock);
++	//return err;
++	//}
++
++	numargs = 0;
++	while (arguments[numargs] != NULL ) {
++		//kprintf("%");
++		numargs = numargs + 1;
++	}
++
++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++	//int i;
++	for (i = 0; i < numargs; i++) {
++		actual_size = 0;
++		kargv[i] = (char*) kmalloc(PATH_MAX);
++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++				&actual_size);
++		if (flag) {
++			kfree(kargv);
++			kfree(namedes);
++			return EFAULT;
++		}
++
++	}
++	actual_size = 0;
++
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace == NULL ) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++	if (flag) {
++		// thread_exit destroys curthread->t_addrspace
++		vfs_close(vn);
++		return flag;
++	}
++
++	vfs_close(vn);
++
++	// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (flag) {
++		//thread_exit destroys curthread->t_addrspace
++		return flag;
++	}
++
++	//i=0;
++	vaddr_t stackptrv[numargs + 1];
++	for (i = numargs - 1; i >= 0; i--) {
++		int len = strlen(kargv[i]);
++		int padder=0;
++		len++;// to account for string terminator
++		if(len%4!=0)
++		padder = len % 4;
++		stackptr =stackptr-(len + padder);
++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++				&actual_size);
++
++		if (flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return flag;
++		}
++
++		stackptrv[i] = stackptr;
++	}
++	stackptrv[numargs] = 0;
++
++	//This copies the actual stack addresses of the arguments
++	//* into the stack. Hopefully.
++
++	 for(i = numargs; i >= 0; i--)
++	 {
++	 stackptr -= sizeof(vaddr_t);
++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++
++	 if(flag)
++	 {
++	 kfree(kargv);
++	 kfree(namedes);
++	 return flag;
++	 }
++
++	 }
++
++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++	//pt_getthread();
++
++	//enter_new_process does not return.
++	panic("enter_new_process returned\n");
++	return EINVAL;
++
++}
++
++int sys_getpid(pid_t *retval) {
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval = curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++	struct process* wthread = NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if (status == NULL )
++		return EFAULT;
++	if (options != 0)
++		return EINVAL;
++	if (pid == curthread->pid)
++		return ECHILD;
++	if (pid < PID_MIN || pid > PID_MAX)
++		return ESRCH;
++	if (status == NULL )
++		return EFAULT;
++	if (pid == curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++	//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++	//return EFAULT;
++	//}
++
++	//if()
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++	//if (result) {
++	//return result;
++	//}
++	//int addr=(int)&status;
++	//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++	//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				wthread = p_table[i];
++				break;
++			}
++		}
++	}
++	if (wthread == NULL ) {
++		return ESRCH;
++	}
++	if (curthread->proc->pid != wthread->ppid)
++		return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check = wthread->exitcode;
++	err = copyout(&check, (userptr_t) status, sizeof(check));
++	if (err) {
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i] = NULL;
++
++	*retval = pid;
++	//panic("After dereferencing");
++	return 0;
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode) {
++	pid_t pid = curthread->proc->pid;
++	pid_t i = PID_MIN;
++	struct process* ethread;
++//pid_t parent;
++//if(pid!=2)
++//{
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				ethread = p_table[i];
++				break;
++			}
++		}
++	}
++
++//parent=ethread->ppid;
++	if (ethread != NULL ) {
++		lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++		ethread->exited = 1;
++//p_table[i]=ethread;
++		cv_broadcast(ethread->wcv, ethread->tlock);
++//kfree(curthread->t_filetable);
++		lock_release(ethread->tlock);
++	}
++//}
++	i = 0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++	thread_exit();
++}
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..1ada408 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,40 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++int padder=0;
++len++;
++if(len%4!=0)
++padder = len % 4;
++stackptr=stackptr-(len + padder);
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..df129b9 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +357,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +377,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +532,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +811,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..e07fb23
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,4058 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..dfd7b53
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,445 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro) {
+++	//lock_acquire(mypro->tlock);
+++	while (!mypro->exited) {
+++		cv_wait(mypro->wcv, mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+++	(void) adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt = (struct trapframe*) kmalloc(
+++			sizeof(struct trapframe));
+++	bzero(copyt, sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt, tf, sizeof(struct trapframe));
+++	flag = as_copy(curthread->t_addrspace, &adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++	//curthread->pid=PID_MIN;
+++	//}
+++	if (flag) {
+++		kfree(copyt);
+++		return flag;
+++	}
+++
+++	//we need to allocate pid for our new process
+++
+++	//pid_t cpid;
+++	for (childid = 0; childid <= 16; childid++) {
+++		if (p_table[childid] == NULL ) {
+++			p_table[childid] = (struct process*) kmalloc(
+++					sizeof(struct process));
+++			p_table[childid]->full = 1;
+++			pidcount++;
+++			p_table[childid]->pid = pidcount;
+++			p_table[childid]->ppid = curthread->pid;
+++			//p_table[childid]->exitsem=sem_create("process",0);
+++			p_table[childid]->tlock = lock_create("My Lock");
+++			p_table[childid]->wcv = cv_create("My CV");
+++			p_table[childid]->self = NULL;
+++			break;
+++		}
+++	}
+++	if (childid > PID_MAX) {
+++		*retval = 1;
+++		return EMPROC;
+++	}
+++	//int i;
+++
+++	copyt->tf_a0 = (int) p_table[childid]->pid;
+++	//kprintf("Ret:%d\n",copyt->tf_a0);
+++	struct thread *new_proc;
+++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+++	//int s=splhigh();
+++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+++			(unsigned long) adrcopy, &new_proc);
+++	//kprintf("Out of thread fork:%d\n",flag);
+++	if (flag) {
+++		kfree(copyt);
+++		as_destroy(adrcopy);
+++
+++		return flag;
+++	}
+++
+++	//new_proc->pid=(pid_t)childid;
+++	//new_proc=p_table[childid];
+++
+++	new_proc->pid = p_table[childid]->pid;
+++	new_proc->proc = p_table[childid];
+++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++	//if (new_proc->t_filetable == NULL) {
+++	//return ENOMEM;
+++	//}
+++	p_table[childid]->self = new_proc;
+++
+++	//new_proc->pid=p_table[childid]->pid;
+++	//new_proc->proc->pid=p_table[childid]->pid;
+++	//kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++	//kprintf("Child id:%d",new_proc->pid);
+++	//new_proc->t_filetable->
+++	//for(i=0;i<128;i++)
+++	//{
+++	flag = filetable_copy(&new_proc->t_filetable);
+++	//}
+++	//splx(s);
+++	// kprintf("Fork over!");
+++
+++	*retval = p_table[childid]->pid;
+++	//kprintf("Return val in fork:%d",*retval);
+++	return 0;
+++
+++	//flag=
+++	//flag=thread_fork=
+++}
+++
+++int sys_execv(char *progname, char** arguments) {
+++
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size = 0;
+++	char *namedes;
+++
+++	if (progname == NULL ) {
+++		return EFAULT;
+++	}
+++	if (progname == "") {
+++		return EINVAL;
+++	}
+++
+++	namedes = (char*) kmalloc(PATH_MAX);
+++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+++			&actual_size);
+++	if (flag != 0) {
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if (strlen(namedes) == 0) {
+++		//*retval=1;
+++		return EISDIR;
+++	}
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+++	if (flag) {
+++		return flag;
+++	}
+++	actual_size = 0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if (arguments == NULL ) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+++	if (flag) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++	//return err;
+++	//}
+++
+++	numargs = 0;
+++	while (arguments[numargs] != NULL ) {
+++		//kprintf("%");
+++		numargs = numargs + 1;
+++	}
+++
+++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+++	//int i;
+++	for (i = 0; i < numargs; i++) {
+++		actual_size = 0;
+++		kargv[i] = (char*) kmalloc(PATH_MAX);
+++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+++				&actual_size);
+++		if (flag) {
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size = 0;
+++
+++	curthread->t_addrspace = as_create();
+++	if (curthread->t_addrspace == NULL ) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++	if (flag) {
+++		// thread_exit destroys curthread->t_addrspace
+++		vfs_close(vn);
+++		return flag;
+++	}
+++
+++	vfs_close(vn);
+++
+++	// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++	if (flag) {
+++		//thread_exit destroys curthread->t_addrspace
+++		return flag;
+++	}
+++
+++	//i=0;
+++	vaddr_t stackptrv[numargs + 1];
+++	for (i = numargs - 1; i >= 0; i--) {
+++		int len = strlen(kargv[i]);
+++		int padder=0;
+++		len++;// to account for string terminator
+++		if(len%4!=0)
+++		padder = len % 4;
+++		stackptr =stackptr-(len + padder);
+++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+++				&actual_size);
+++
+++		if (flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return flag;
+++		}
+++
+++		stackptrv[i] = stackptr;
+++	}
+++	stackptrv[numargs] = 0;
+++
+++	//This copies the actual stack addresses of the arguments
+++	//* into the stack. Hopefully.
+++
+++	 for(i = numargs; i >= 0; i--)
+++	 {
+++	 stackptr -= sizeof(vaddr_t);
+++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++
+++	 if(flag)
+++	 {
+++	 kfree(kargv);
+++	 kfree(namedes);
+++	 return flag;
+++	 }
+++
+++	 }
+++
+++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+++	//pt_getthread();
+++
+++	//enter_new_process does not return.
+++	panic("enter_new_process returned\n");
+++	return EINVAL;
+++
+++}
+++
+++int sys_getpid(pid_t *retval) {
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval = curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+++	struct process* wthread = NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if (status == NULL )
+++		return EFAULT;
+++	if (options != 0)
+++		return EINVAL;
+++	if (pid == curthread->pid)
+++		return ECHILD;
+++	if (pid < PID_MIN || pid > PID_MAX)
+++		return ESRCH;
+++	if (status == NULL )
+++		return EFAULT;
+++	if (pid == curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++	//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++
+++	//if()
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++	//if (result) {
+++	//return result;
+++	//}
+++	//int addr=(int)&status;
+++	//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				wthread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++	if (wthread == NULL ) {
+++		return ESRCH;
+++	}
+++	if (curthread->proc->pid != wthread->ppid)
+++		return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check = wthread->exitcode;
+++	err = copyout(&check, (userptr_t) status, sizeof(check));
+++	if (err) {
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i] = NULL;
+++
+++	*retval = pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode) {
+++	pid_t pid = curthread->proc->pid;
+++	pid_t i = PID_MIN;
+++	struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				ethread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++
+++//parent=ethread->ppid;
+++	if (ethread != NULL ) {
+++		lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++		ethread->exited = 1;
+++//p_table[i]=ethread;
+++		cv_broadcast(ethread->wcv, ethread->tlock);
+++//kfree(curthread->t_filetable);
+++		lock_release(ethread->tlock);
+++	}
+++//}
+++	i = 0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++	thread_exit();
+++}
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..1ada408 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,40 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++int padder=0;
+++len++;
+++if(len%4!=0)
+++padder = len % 4;
+++stackptr=stackptr-(len + padder);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address sp
+\ No newline at end of file
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/submit1.patch b/submit1.patch
new file mode 100644
index 0000000..56bd5d9
--- /dev/null
+++ b/submit1.patch
@@ -0,0 +1,11557 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..2ac1283 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++		break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++		break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++		break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++		break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1,&retval);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,33 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	struct trapframe newtf;
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	tf=NULL;
++	int flag;
++	curthread->t_addrspace=(struct addrspace*)adrspace;
++	curthread->pid=newtf.tf_a0;
++	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	if(flag)
++	{
++		newtf.tf_v0=ENOMEM;
++		newtf.tf_a3=1;
++	}
++	as_activate(curthread->t_addrspace);
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..8fc6529 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -44,7 +44,7 @@ void syscall(struct trapframe *tf);
+  */
+ 
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +55,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments,int *retval);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..9155eb5
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,344 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++
++
++
++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
++{
++	(void)adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
++	bzero(copyt,sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++
++	memcpy(copyt,tf,sizeof(struct trapframe));
++	flag=as_copy(curthread->t_addrspace,&adrcopy);
++	//if(curthread->pid==0)
++	//{
++		//curthread->pid=PID_MIN;
++	//}
++    if(flag)
++    {
++    	kfree(copyt);
++    	return flag;
++    }
++
++    //we need to allocate pid for our new process
++
++    //pid_t cpid;
++    for(childid=0;childid<16;childid++)
++    {
++     if(p_table[childid]==NULL)
++     {
++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
++    	p_table[childid]->full=1;
++    	pidcount++;
++    	p_table[childid]->pid=pidcount;
++    	p_table[childid]->ppid=curthread->pid;
++    	//p_table[childid]->exitsem=sem_create("process",0);
++    	p_table[childid]->tlock=lock_create("My Lock");
++    	p_table[childid]->wcv=cv_create("My CV");
++    	p_table[childid]->self=NULL;
++    	break;
++     }
++    }
++    if(childid>PID_MAX)
++    {
++    	*retval=1;
++    	return EMPROC;
++    }
++    //int i;
++    copyt->tf_a0=childid;
++    struct thread *new_proc;
++
++    //int s=splhigh();
++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
++    //kprintf("Out of thread fork:%d\n",flag);
++    if(flag)
++    {
++    	kfree(copyt);
++    	as_destroy(adrcopy);
++
++    	return flag;
++    }
++    //new_proc->pid=(pid_t)childid;
++    p_table[childid]->self=new_proc;
++    new_proc->proc=p_table[childid];
++
++   //kprintf("Child id:%d",new_proc->pid);
++    //new_proc->t_filetable->
++    //for(i=0;i<128;i++)
++    //{
++    	flag=filetable_copy(&new_proc->t_filetable);
++    //}
++    //splx(s);
++   // kprintf("Fork over!");
++
++    *retval=p_table[childid]->pid;
++    kprintf("Return val in fork:%d",*retval);
++    return 0;
++
++    //flag=
++     //flag=thread_fork=
++}
++
++
++
++int sys_execv(char* progname,char** arguments,int *retval)
++{
++	int flag;
++	int numargs;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size=0;
++	char namedes[PATH_MAX+1];
++
++
++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
++	if(flag!=0)
++	{
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if(strlen(namedes)==0)
++	{
++		*retval=1;
++		return ENOENT;
++	}
++
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
++	if(flag)
++	{
++		return flag;
++	}
++	actual_size=0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++
++	numargs=0;
++	while(arguments[numargs]!=NULL)
++	{
++		numargs=numargs+1;
++	}
++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
++	int i;
++	for(i=0;i<numargs;i++)
++	{
++		actual_size=0;
++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
++		if(flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return flag;
++		}
++
++	}
++	actual_size=0;
++
++	// same as runprogram
++
++	curthread->t_addrspace=as_create();
++	if(curthread->t_addrspace==NULL)
++	{
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++		if (flag) {
++			/* thread_exit destroys curthread->t_addrspace */
++			vfs_close(vn);
++			return flag;
++		}
++
++	vfs_close(vn);
++
++// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++		if (flag) {
++			/* thread_exit destroys curthread->t_addrspace */
++			return flag;
++		}
++
++		for(i=numargs;i>0;i--)
++		{
++			actual_size=0;
++			int length=strlen(kargv[i])+1;
++			//int length=strlen(kargv[i]);
++			int padder=length%4;
++			if(padder!=0)
++			length=length+padder;
++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
++			//stackptr=stackptr+length;
++			stackptr=stackptr-length;
++
++
++		}
++		enter_new_process(numargs,(userptr_t)stackptr,
++					  stackptr, entrypoint);
++		//pt_getthread();
++
++
++			/* enter_new_process does not return. */
++			panic("enter_new_process returned\n");
++			return EINVAL;
++}
++
++
++int sys_getpid(pid_t *retval)
++{
++	*retval=curthread->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
++{
++	struct process* wthread=NULL;
++	pid_t i;
++	kprintf("PID in wait pid:%d\n",pid);
++	if(options!=0)
++		return EINVAL;
++	if (pid==curthread->pid)
++		return ECHILD;
++	if (pid<PID_MIN||pid>PID_MAX)
++		return ESRCH;
++	if (status==NULL)
++		return EFAULT;
++	kprintf("Got Here\n");
++	for(i=0;i<=16;i++)
++	{
++		if(p_table[i]->pid==pid)
++		{
++			wthread=p_table[i];
++			break;
++		}
++	}
++	if(wthread==NULL)
++	{
++		return ESRCH;
++	}
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	while(!wthread->exited)
++	{
++
++		cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	}
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++	*status=wthread->exitcode;
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++	//kfree(p_table[i]);
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	*retval=pid;
++	//panic("After dereferencing");
++	return 0;
++
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode)
++{
++pid_t pid=curthread->proc->pid;
++pid_t i=PID_MIN;
++struct process* ethread;
++//pid_t parent;
++
++for(i=0;i<=16;i++)
++{
++	if(p_table[i]->pid==pid)
++	{
++			ethread=p_table[i];
++			break;
++	}
++}
++
++//parent=ethread->ppid;
++if(ethread!=NULL)
++{
++lock_acquire(ethread->tlock);
++ethread->exitcode=_MKWAIT_EXIT(exitcode);
++ethread->exited=1;
++//p_table[i]=ethread;
++cv_broadcast(ethread->wcv,ethread->tlock);
++lock_release(ethread->tlock);
++}
++i=0;
++//kprintf("Before hanging");
++thread_exit();
++}
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..4ba181a 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,7 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -66,6 +67,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..df129b9 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +357,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +377,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +532,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +811,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..7721c95
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,7653 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..2ac1283 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1,&retval);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,33 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	struct trapframe newtf;
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	tf=NULL;
+++	int flag;
+++	curthread->t_addrspace=(struct addrspace*)adrspace;
+++	curthread->pid=newtf.tf_a0;
+++	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..8fc6529 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -44,7 +44,7 @@ void syscall(struct trapframe *tf);
++  */
++ 
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +55,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments,int *retval);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..9155eb5
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,344 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++
+++
+++
+++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
+++{
+++	(void)adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
+++	bzero(copyt,sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++
+++	memcpy(copyt,tf,sizeof(struct trapframe));
+++	flag=as_copy(curthread->t_addrspace,&adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++		//curthread->pid=PID_MIN;
+++	//}
+++    if(flag)
+++    {
+++    	kfree(copyt);
+++    	return flag;
+++    }
+++
+++    //we need to allocate pid for our new process
+++
+++    //pid_t cpid;
+++    for(childid=0;childid<16;childid++)
+++    {
+++     if(p_table[childid]==NULL)
+++     {
+++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
+++    	p_table[childid]->full=1;
+++    	pidcount++;
+++    	p_table[childid]->pid=pidcount;
+++    	p_table[childid]->ppid=curthread->pid;
+++    	//p_table[childid]->exitsem=sem_create("process",0);
+++    	p_table[childid]->tlock=lock_create("My Lock");
+++    	p_table[childid]->wcv=cv_create("My CV");
+++    	p_table[childid]->self=NULL;
+++    	break;
+++     }
+++    }
+++    if(childid>PID_MAX)
+++    {
+++    	*retval=1;
+++    	return EMPROC;
+++    }
+++    //int i;
+++    copyt->tf_a0=childid;
+++    struct thread *new_proc;
+++
+++    //int s=splhigh();
+++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
+++    //kprintf("Out of thread fork:%d\n",flag);
+++    if(flag)
+++    {
+++    	kfree(copyt);
+++    	as_destroy(adrcopy);
+++
+++    	return flag;
+++    }
+++    //new_proc->pid=(pid_t)childid;
+++    p_table[childid]->self=new_proc;
+++    new_proc->proc=p_table[childid];
+++
+++   //kprintf("Child id:%d",new_proc->pid);
+++    //new_proc->t_filetable->
+++    //for(i=0;i<128;i++)
+++    //{
+++    	flag=filetable_copy(&new_proc->t_filetable);
+++    //}
+++    //splx(s);
+++   // kprintf("Fork over!");
+++
+++    *retval=p_table[childid]->pid;
+++    kprintf("Return val in fork:%d",*retval);
+++    return 0;
+++
+++    //flag=
+++     //flag=thread_fork=
+++}
+++
+++
+++
+++int sys_execv(char* progname,char** arguments,int *retval)
+++{
+++	int flag;
+++	int numargs;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size=0;
+++	char namedes[PATH_MAX+1];
+++
+++
+++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
+++	if(flag!=0)
+++	{
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if(strlen(namedes)==0)
+++	{
+++		*retval=1;
+++		return ENOENT;
+++	}
+++
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
+++	if(flag)
+++	{
+++		return flag;
+++	}
+++	actual_size=0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++
+++	numargs=0;
+++	while(arguments[numargs]!=NULL)
+++	{
+++		numargs=numargs+1;
+++	}
+++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
+++	int i;
+++	for(i=0;i<numargs;i++)
+++	{
+++		actual_size=0;
+++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
+++		if(flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return flag;
+++		}
+++
+++	}
+++	actual_size=0;
+++
+++	// same as runprogram
+++
+++	curthread->t_addrspace=as_create();
+++	if(curthread->t_addrspace==NULL)
+++	{
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++		if (flag) {
+++			/* thread_exit destroys curthread->t_addrspace */
+++			vfs_close(vn);
+++			return flag;
+++		}
+++
+++	vfs_close(vn);
+++
+++// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++		if (flag) {
+++			/* thread_exit destroys curthread->t_addrspace */
+++			return flag;
+++		}
+++
+++		for(i=numargs;i>0;i--)
+++		{
+++			actual_size=0;
+++			int length=strlen(kargv[i])+1;
+++			//int length=strlen(kargv[i]);
+++			int padder=length%4;
+++			if(padder!=0)
+++			length=length+padder;
+++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
+++			//stackptr=stackptr+length;
+++			stackptr=stackptr-length;
+++
+++
+++		}
+++		enter_new_process(numargs,(userptr_t)stackptr,
+++					  stackptr, entrypoint);
+++		//pt_getthread();
+++
+++
+++			/* enter_new_process does not return. */
+++			panic("enter_new_process returned\n");
+++			return EINVAL;
+++}
+++
+++
+++int sys_getpid(pid_t *retval)
+++{
+++	*retval=curthread->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
+++{
+++	struct process* wthread=NULL;
+++	pid_t i;
+++	kprintf("PID in wait pid:%d\n",pid);
+++	if(options!=0)
+++		return EINVAL;
+++	if (pid==curthread->pid)
+++		return ECHILD;
+++	if (pid<PID_MIN||pid>PID_MAX)
+++		return ESRCH;
+++	if (status==NULL)
+++		return EFAULT;
+++	kprintf("Got Here\n");
+++	for(i=0;i<=16;i++)
+++	{
+++		if(p_table[i]->pid==pid)
+++		{
+++			wthread=p_table[i];
+++			break;
+++		}
+++	}
+++	if(wthread==NULL)
+++	{
+++		return ESRCH;
+++	}
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	while(!wthread->exited)
+++	{
+++
+++		cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	}
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++	*status=wthread->exitcode;
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++	//kfree(p_table[i]);
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	*retval=pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode)
+++{
+++pid_t pid=curthread->proc->pid;
+++pid_t i=PID_MIN;
+++struct process* ethread;
+++//pid_t parent;
+++
+++for(i=0;i<=16;i++)
+++{
+++	if(p_table[i]->pid==pid)
+++	{
+++			ethread=p_table[i];
+++			break;
+++	}
+++}
+++
+++//parent=ethread->ppid;
+++if(ethread!=NULL)
+++{
+++lock_acquire(ethread->tlock);
+++ethread->exitcode=_MKWAIT_EXIT(exitcode);
+++ethread->exited=1;
+++//p_table[i]=ethread;
+++cv_broadcast(ethread->wcv,ethread->tlock);
+++lock_release(ethread->tlock);
+++}
+++i=0;
+++//kprintf("Before hanging");
+++thread_exit();
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index 5b8099e..60108d3 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -798,6 +801,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..94df80c
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,3748 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..2ac1283 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,11 +32,14 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <addrspace.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
+++ 
++++
+++ /*
+++  * System call dispatcher.
+++  *
+++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_fork:
++++	    	err=0;
++++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++++	    break;
++++	    case SYS_execv:
++++	    	err=0;
++++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1,&retval);
++++	    	break;
++++	    case SYS_getpid:
++++	    	err=0;
++++	    	err=sys_getpid(&retval);
++++	    	break;
++++	    case SYS_waitpid:
++++	    	err=0;
++++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++	    	//panic("Waitpid over");
++++	    	break;
++++	    case SYS__exit:
++++	    	sys_exit((int)tf->tf_a0);
++++	    	break;
++++
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++@@ -154,8 +214,33 @@ syscall(struct trapframe *tf)
+++  *
+++  * Thus, you can trash it and do things another way if you prefer.
+++  */
+++-void
+++-enter_forked_process(struct trapframe *tf)
++++//void
++++//enter_forked_process(struct trapframe *tf)
++++//{
++++	//(void)tf;
++++//}
++++
++++void enter_forked_process(void*tf,unsigned long adrspace)
+++ {
+++-	(void)tf;
++++	struct trapframe newtf;
++++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++++	kfree(tf);
++++	tf=NULL;
++++	int flag;
++++	curthread->t_addrspace=(struct addrspace*)adrspace;
++++	curthread->pid=newtf.tf_a0;
++++	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++++	if(flag)
++++	{
++++		newtf.tf_v0=ENOMEM;
++++		newtf.tf_a3=1;
++++	}
++++	as_activate(curthread->t_addrspace);
++++
++++
++++
++++	newtf.tf_v0=0;
++++	newtf.tf_a3=0;
++++	newtf.tf_epc+=4;
++++	mips_usermode(&newtf);
+++ }
+++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+++new file mode 100644
+++index 0000000..3e8d5b9
+++--- /dev/null
++++++ b/kern/arch/mips/syscall/syscall.c~
+++@@ -0,0 +1,165 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/syscall.h>
++++#include <lib.h>
++++#include <mips/trapframe.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <syscall.h>
++++
++++
++++/*
++++ * System call dispatcher.
++++ *
++++ * A pointer to the trapframe created during exception entry (in
++++ * exception.S) is passed in.
++++ *
++++ * The calling conventions for syscalls are as follows: Like ordinary
++++ * function calls, the first 4 32-bit arguments are passed in the 4
++++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++++ * unused.
++++ *
++++ * This much is the same as the calling conventions for ordinary
++++ * function calls. In addition, the system call number is passed in
++++ * the v0 register.
++++ *
++++ * On successful return, the return value is passed back in the v0
++++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++++ * function call, and additionally the a3 register is also set to 0 to
++++ * indicate success.
++++ *
++++ * On an error return, the error code is passed back in the v0
++++ * register, and the a3 register is set to 1 to indicate failure.
++++ * (Userlevel code takes care of storing the error code in errno and
++++ * returning the value -1 from the actual userlevel syscall function.
++++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++++ *
++++ * Upon syscall return the program counter stored in the trapframe
++++ * must be incremented by one instruction; otherwise the exception
++++ * return code will restart the "syscall" instruction and the system
++++ * call will repeat forever.
++++ *
++++ * If you run out of registers (which happens quickly with 64-bit
++++ * values) further arguments must be fetched from the user-level
++++ * stack, starting at sp+16 to skip over the slots for the
++++ * registerized values, with copyin().
++++ */
++++void
++++syscall(struct trapframe *tf)
++++{
++++	int callno;
++++	int32_t retval;
++++	int err;
++++
++++	KASSERT(curthread != NULL);
++++	KASSERT(curthread->t_curspl == 0);
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++
++++	callno = tf->tf_v0;
++++
++++	/*
++++	 * Initialize retval to 0. Many of the system calls don't
++++	 * really return a value, just 0 for success and -1 on
++++	 * error. Since retval is the value returned on success,
++++	 * initialize it to 0 by default; thus it's not necessary to
++++	 * deal with it except for calls that return other values, 
++++	 * like write.
++++	 */
++++
++++	retval = 0;
++++
++++	switch (callno) {
++++	    case SYS_reboot:
++++		err = sys_reboot(tf->tf_a0);
++++		break;
++++
++++	    case SYS___time:
++++		err = sys___time((userptr_t)tf->tf_a0,
++++				 (userptr_t)tf->tf_a1);
++++		break;
++++		
++++	    case SYS_open:
++++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++++	    break;
++++
++++	    /* Add stuff here */
++++ 
++++	    default:
++++		kprintf("Unknown syscall %d\n", callno);
++++		err = ENOSYS;
++++		break;
++++	}
++++
++++
++++	if (err) {
++++		/*
++++		 * Return the error code. This gets converted at
++++		 * userlevel to a return value of -1 and the error
++++		 * code in errno.
++++		 */
++++		tf->tf_v0 = err;
++++		tf->tf_a3 = 1;      /* signal an error */
++++	}
++++	else {
++++		/* Success. */
++++		tf->tf_v0 = retval;
++++		tf->tf_a3 = 0;      /* signal no error */
++++	}
++++	
++++	/*
++++	 * Now, advance the program counter, to avoid restarting
++++	 * the syscall over and over again.
++++	 */
++++	
++++	tf->tf_epc += 4;
++++
++++	/* Make sure the syscall code didn't forget to lower spl */
++++	KASSERT(curthread->t_curspl == 0);
++++	/* ...or leak any spinlocks */
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++}
++++
++++/*
++++ * Enter user mode for a newly forked process.
++++ *
++++ * This function is provided as a reminder. You need to write
++++ * both it and the code that calls it.
++++ *
++++ * Thus, you can trash it and do things another way if you prefer.
++++ */
++++void
++++enter_forked_process(struct trapframe *tf)
++++{
++++	(void)tf;
++++}
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..7d5df71 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,9 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
++++file	  syscall/proc_sys.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/limits.h b/kern/include/limits.h
+++index 01684c4..3a54e24 100644
+++--- a/kern/include/limits.h
++++++ b/kern/include/limits.h
+++@@ -48,5 +48,6 @@
+++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+++ #define OPEN_MAX        __OPEN_MAX
+++ #define IOV_MAX         __IOV_MAX
++++//#define OPEN_MAX        64
+++ 
+++ #endif /* _LIMITS_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..df9fe64 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,11 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        //struct spinlock cv_lock;
++++        struct wchan *cv_wchan;
++++        //volatile int hold;
++++        //struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ 
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int res_count;
++++        struct wchan *rd_wchan;
++++        struct wchan *wr_wchan;
++++        struct semaphore *rw_sem;
++++        struct lock *rw_lock;
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+++new file mode 100644
+++index 0000000..d98aeb7
+++--- /dev/null
++++++ b/kern/include/synch.h~
+++@@ -0,0 +1,161 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _SYNCH_H_
++++#define _SYNCH_H_
++++
++++/*
++++ * Header file for synchronization primitives.
++++ */
++++
++++
++++#include <spinlock.h>
++++
++++/*
++++ * Dijkstra-style semaphore.
++++ *
++++ * The name field is for easier debugging. A copy of the name is made
++++ * internally.
++++ */
++++struct semaphore {
++++        char *sem_name;
++++	struct wchan *sem_wchan;
++++	struct spinlock sem_lock;
++++        volatile int sem_count;
++++};
++++
++++struct semaphore *sem_create(const char *name, int initial_count);
++++void sem_destroy(struct semaphore *);
++++
++++/*
++++ * Operations (both atomic):
++++ *     P (proberen): decrement count. If the count is 0, block until
++++ *                   the count is 1 again before decrementing.
++++ *     V (verhogen): increment count.
++++ */
++++void P(struct semaphore *);
++++void V(struct semaphore *);
++++
++++
++++/*
++++ * Simple lock for mutual exclusion.
++++ *
++++ * When the lock is created, no thread should be holding it. Likewise,
++++ * when the lock is destroyed, no thread should be holding it.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++struct lock {
++++        char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct lock *lock_create(const char *name);
++++void lock_acquire(struct lock *);
++++
++++/*
++++ * Operations:
++++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++++ *                   same time.
++++ *    lock_release - Free the lock. Only the thread holding the lock may do
++++ *                   this.
++++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++++ *                   false otherwise.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void lock_release(struct lock *);
++++bool lock_do_i_hold(struct lock *);
++++void lock_destroy(struct lock *);
++++
++++
++++/*
++++ * Condition variable.
++++ *
++++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++++ * to wait until a variable meets a particular condition, but there's no
++++ * actual variable, as such, in the CV.
++++ *
++++ * These CVs are expected to support Mesa semantics, that is, no
++++ * guarantees are made about scheduling.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++
++++struct cv {
++++        char *cv_name;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct cv *cv_create(const char *name);
++++void cv_destroy(struct cv *);
++++
++++/*
++++ * Operations:
++++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++++ *                   waking up again, re-acquire the lock.
++++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++++ *
++++ * For all three operations, the current thread must hold the lock passed 
++++ * in. Note that under normal circumstances the same lock should be used
++++ * on all operations with any particular CV.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void cv_wait(struct cv *cv, struct lock *lock);
++++void cv_signal(struct cv *cv, struct lock *lock);
++++void cv_broadcast(struct cv *cv, struct lock *lock);
++++
++++/*
++++ * 13 Feb 2012 : GWA : Reader-writer locks.
++++ */
++++
++++struct rwlock {
++++        char *rwlock_name;
++++};
++++
++++struct rwlock * rwlock_create(const char *);
++++void rwlock_destroy(struct rwlock *);
++++
++++void rwlock_acquire_read(struct rwlock *);
++++void rwlock_release_read(struct rwlock *);
++++void rwlock_acquire_write(struct rwlock *);
++++void rwlock_release_write(struct rwlock *);
++++
++++#endif /* _SYNCH_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..8fc6529 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -44,7 +44,7 @@ void syscall(struct trapframe *tf);
+++  */
+++ 
+++ /* Helper for fork(). You write this. */
+++-void enter_forked_process(struct trapframe *tf);
++++void enter_forked_process(void *tf,unsigned long adrspace);
+++ 
+++ /* Enter user mode. Does not return. */
+++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++@@ -55,7 +55,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++++int sys_execv(char* progname,char** arguments,int *retval);
++++int sys_getpid(pid_t *retval);
++++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++++void sys_exit(int exitcode);
++++
+++ 
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..77a3515 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -73,7 +73,10 @@ struct thread {
+++ 	 */
+++ 	char *t_name;			/* Name of this thread */
+++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+++-	threadstate_t t_state;		/* State this thread is in */
++++	threadstate_t t_state;
++++	/* State this thread is in */
++++
++++	pid_t pid;
+++ 
+++ 	/*
+++ 	 * Thread subsystem internal fields.
+++@@ -104,7 +107,7 @@ struct thread {
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++-
++++	struct process* proc;
+++ 	/* VM */
+++ 	struct addrspace *t_addrspace;	/* virtual address space */
+++ 
+++@@ -112,6 +115,19 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
++++};
++++
++++struct process {
++++	int full;
++++	pid_t pid;
++++    pid_t ppid;
++++    //struct semaphore* exitsem;
++++    struct lock* tlock;
++++    struct cv* wcv;
++++    bool exited;
++++    int exitcode;
++++    struct thread* self;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..4d8e7e2 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -100,7 +100,7 @@ boot(void)
+++ 	kprintf("%s", harvard_copyright);
+++ 	kprintf("\n");
+++ 
+++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++ 		GROUP_VERSION, buildconfig, buildversion);
+++ 	kprintf("\n");
+++ 
+++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+++new file mode 100644
+++index 0000000..4d8e7e2
+++--- /dev/null
++++++ b/kern/startup/main.c~
+++@@ -0,0 +1,211 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Main.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/reboot.h>
++++#include <kern/unistd.h>
++++#include <lib.h>
++++#include <spl.h>
++++#include <clock.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++#include <vm.h>
++++#include <mainbus.h>
++++#include <vfs.h>
++++#include <device.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <version.h>
++++#include "autoconf.h"  // for pseudoconfig
++++
++++
++++/*
++++ * These two pieces of data are maintained by the makefiles and build system.
++++ * buildconfig is the name of the config file the kernel was configured with.
++++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++++ *
++++ * The purpose is not to show off how many kernels you've linked, but
++++ * to make it easy to make sure that the kernel you just booted is the
++++ * same one you just built.
++++ */
++++extern const int buildversion;
++++extern const char buildconfig[];
++++
++++/*
++++ * Copyright message for the OS/161 base code.
++++ */
++++static const char harvard_copyright[] =
++++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++++
++++
++++/*
++++ * Initial boot sequence.
++++ */
++++static
++++void
++++boot(void)
++++{
++++	/*
++++	 * The order of these is important!
++++	 * Don't go changing it without thinking about the consequences.
++++	 *
++++	 * Among other things, be aware that console output gets
++++	 * buffered up at first and does not actually appear until
++++	 * mainbus_bootstrap() attaches the console device. This can
++++	 * be remarkably confusing if a bug occurs at this point. So
++++	 * don't put new code before mainbus_bootstrap if you don't
++++	 * absolutely have to.
++++	 *
++++	 * Also note that the buffer for this is only 1k. If you
++++	 * overflow it, the system will crash without printing
++++	 * anything at all. You can make it larger though (it's in
++++	 * dev/generic/console.c).
++++	 */
++++
++++	kprintf("\n");
++++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++++	kprintf("%s", harvard_copyright);
++++	kprintf("\n");
++++
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++++		GROUP_VERSION, buildconfig, buildversion);
++++	kprintf("\n");
++++
++++	/* Early initialization. */
++++	ram_bootstrap();
++++	thread_bootstrap();
++++	hardclock_bootstrap();
++++	vfs_bootstrap();
++++
++++	/* Probe and initialize devices. Interrupts should come on. */
++++	kprintf("Device probe...\n");
++++	KASSERT(curthread->t_curspl > 0);
++++	mainbus_bootstrap();
++++	KASSERT(curthread->t_curspl == 0);
++++	/* Now do pseudo-devices. */
++++	pseudoconfig();
++++	kprintf("\n");
++++
++++	/* Late phase of initialization. */
++++	vm_bootstrap();
++++	kprintf_bootstrap();
++++	thread_start_cpus();
++++
++++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++++	vfs_setbootfs("emu0");
++++
++++
++++	/*
++++	 * Make sure various things aren't screwed up.
++++	 */
++++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++++}
++++
++++/*
++++ * Shutdown sequence. Opposite to boot().
++++ */
++++static
++++void
++++shutdown(void)
++++{
++++
++++	kprintf("Shutting down.\n");
++++	
++++	vfs_clearbootfs();
++++	vfs_clearcurdir();
++++	vfs_unmountall();
++++
++++	thread_shutdown();
++++
++++	splhigh();
++++}
++++
++++/*****************************************/
++++
++++/*
++++ * reboot() system call.
++++ *
++++ * Note: this is here because it's directly related to the code above,
++++ * not because this is where system call code should go. Other syscall
++++ * code should probably live in the "syscall" directory.
++++ */
++++int
++++sys_reboot(int code)
++++{
++++	switch (code) {
++++	    case RB_REBOOT:
++++	    case RB_HALT:
++++	    case RB_POWEROFF:
++++		break;
++++	    default:
++++		return EINVAL;
++++	}
++++
++++	shutdown();
++++
++++	switch (code) {
++++	    case RB_HALT:
++++		kprintf("The system is halted.\n");
++++		mainbus_halt();
++++		break;
++++	    case RB_REBOOT:
++++		kprintf("Rebooting...\n");
++++		mainbus_reboot();
++++		break;
++++	    case RB_POWEROFF:
++++		kprintf("The system is halted.\n");
++++		mainbus_poweroff();
++++		break;
++++	}
++++
++++	panic("reboot operation failed\n");
++++	return 0;
++++}
++++
++++/*
++++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++++ * request, and then shut down.
++++ */
++++void
++++kmain(char *arguments)
++++{
++++	boot();
++++
++++	menu(arguments);
++++
++++	/* Should not get here */
++++}
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..6c0bb3f 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -43,11 +43,25 @@
+++  * You should implement your solution to the whalemating problem below.
+++  */
+++ 
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++-// the top of the corresponding driver code.
++++// the top of the corresponding driver code
++++
++++struct semaphore *male_sem;
++++struct semaphore *female_sem;
++++struct lock *hold;
++++struct cv* mate_cv;
++++volatile int male_count;
++++volatile int female_count;
+++ 
+++ void whalemating_init() {
++++ hold=lock_create("My lock");
++++ male_sem=sem_create("Male Semaphore",0);
++++ female_sem=sem_create("Female Semaphore",0);
++++mate_cv=cv_create("mating cv");
++++male_count=0;
++++female_count=0;
+++   return;
+++ }
+++ 
+++@@ -55,6 +69,11 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++
++++	sem_destroy(male_sem);
++++	sem_destroy(female_sem);
++++	lock_destroy(hold);
++++	cv_destroy(mate_cv);
+++   return;
+++ }
+++ 
+++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+++   (void)which;
+++   
+++   male_start();
++++
++++  lock_acquire(hold);
++++
++++  V(male_sem);
++++  male_count++;
++++  if(female_count!=0)
++++  cv_signal(mate_cv,hold);
++++  else
++++	  cv_wait(mate_cv,hold);
++++  lock_release(hold);
++++
+++ 	// Implement this function 
+++   male_end();
+++ 
+++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
++++  lock_acquire(hold);
++++   V(female_sem);
++++   female_count++;
++++   if(male_count!=0)
++++   cv_signal(mate_cv,hold);
++++   else
++++	   cv_wait(mate_cv,hold);
++++  lock_release(hold);
+++ 	// Implement this function 
+++   female_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
++++  lock_acquire(hold);
++++ P(male_sem);
++++ male_count--;
++++ lock_release(hold);
++++ lock_acquire(hold);
++++  P(female_sem);
++++  female_count--;
++++  lock_release(hold);
+++ 	// Implement this function 
+++   matchmaker_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
++++
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
++++struct lock* intersect_lock;
++++struct cv* intersect_cv;
++++volatile int cur_poss[4];// an array to store the possible positions of the car
++++//currently
+++ 
+++ void stoplight_init() {
++++	intersect_cv=cv_create("Intersection Condition Variable");
++++	if(intersect_cv==NULL)
++++	{
++++		///return NULL;
++++		panic("condition variable not created");
++++	}
++++	intersect_lock=lock_create("A lock on the intersection");
++++	if(intersect_lock==NULL)
++++	{
++++		//return NULL;
++++		panic("Lock could not be created");
++++	}
++++	
++++	
+++   return;
+++ }
+++ 
+++@@ -145,6 +210,8 @@ void stoplight_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
++++	cv_destroy(intersect_cv);
++++	lock_destroy(intersect_lock);
+++   return;
+++ }
+++ 
+++@@ -152,8 +219,29 @@ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++  //(void)direction;
++++	int sec_quad=(direction+3)%4;
++++	lock_acquire(intersect_lock);
++++	// So while any of the two possible quadrants are already set, It means some 
++++	//thread is waiting...Hopefully
++++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++++		cv_wait(intersect_cv,intersect_lock);
++++	cur_poss[direction]=1;
++++	cur_poss[sec_quad]=1;
++++	inQuadrant(direction);
++++	lock_release(intersect_lock);
++++	lock_acquire(intersect_lock);
++++    cur_poss[direction]=0;
++++    //while(curr_p)
++++    //cv_broadcast(intersect_cv);
++++    inQuadrant(sec_quad);
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++    cur_poss[sec_quad]=0;
++++    leaveIntersection();
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
++++  int sec_quad=(direction+3)%4;
++++  int third_quad=(direction+2)%4;
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  cur_poss[sec_quad]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++  lock_acquire(intersect_lock);
++++  cur_poss[direction]=0;
+++   
++++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++++  //cv_wait(intersect_cv,intersect_lock);
++++      cur_poss[third_quad]=1;
++++      //while(curr_p)
++++      //cv_broadcast(intersect_cv);
++++      inQuadrant(sec_quad);
++++      cv_broadcast(intersect_cv,intersect_lock);
++++      lock_release(intersect_lock);
++++        lock_acquire(intersect_lock);
++++            //currposs[direction]=0;
++++            cur_poss[sec_quad]=0;
++++            //while(curr_p)
++++            //cv_broadcast(intersect_cv);
++++            inQuadrant(third_quad);
++++            cv_broadcast(intersect_cv,intersect_lock);
++++                //cur_poss[third_quad]=0;
++++            lock_release(intersect_lock);
++++              lock_acquire(intersect_lock);
++++                leaveIntersection();
++++                cur_poss[third_quad]=0;
++++                cv_broadcast(intersect_cv,intersect_lock);
++++                lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
+++-
++++  // Easy coz the vehicle is in same lane!!
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++  leaveIntersection();
++++  cur_poss[direction]=0;
++++  cv_broadcast(intersect_cv,intersect_lock);
++++  lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+++new file mode 100644
+++index 0000000..9155eb5
+++--- /dev/null
++++++ b/kern/syscall/proc_sys.c
+++@@ -0,0 +1,344 @@
++++/*
++++
++++ * proc_sys.c
++++ *
++++ *  Created on: Mar 7, 2014
++++ *      Author: trinity
++++ */
++++
++++#include <types.h>
++++#include<mips/trapframe.h>
++++#include <kern/errno.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <addrspace.h>
++++#include <vm.h>
++++#include <vfs.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <file.h>
++++#include <synch.h>
++++#include<copyinout.h>
++++#include <spl.h>
++++#include<kern/wait.h>
++++
++++extern struct process* p_table[17];
++++
++++//struct cv* wcv;
++++
++++extern pid_t pidcount;
++++
++++
++++
++++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
++++{
++++	(void)adrs;
++++	int flag;
++++	pid_t childid;
++++	struct addrspace *adrcopy;
++++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
++++	bzero(copyt,sizeof(struct trapframe));
++++
++++	//struct filetable* copyft;
++++
++++	memcpy(copyt,tf,sizeof(struct trapframe));
++++	flag=as_copy(curthread->t_addrspace,&adrcopy);
++++	//if(curthread->pid==0)
++++	//{
++++		//curthread->pid=PID_MIN;
++++	//}
++++    if(flag)
++++    {
++++    	kfree(copyt);
++++    	return flag;
++++    }
++++
++++    //we need to allocate pid for our new process
++++
++++    //pid_t cpid;
++++    for(childid=0;childid<16;childid++)
++++    {
++++     if(p_table[childid]==NULL)
++++     {
++++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
++++    	p_table[childid]->full=1;
++++    	pidcount++;
++++    	p_table[childid]->pid=pidcount;
++++    	p_table[childid]->ppid=curthread->pid;
++++    	//p_table[childid]->exitsem=sem_create("process",0);
++++    	p_table[childid]->tlock=lock_create("My Lock");
++++    	p_table[childid]->wcv=cv_create("My CV");
++++    	p_table[childid]->self=NULL;
++++    	break;
++++     }
++++    }
++++    if(childid>PID_MAX)
++++    {
++++    	*retval=1;
++++    	return EMPROC;
++++    }
++++    //int i;
++++    copyt->tf_a0=childid;
++++    struct thread *new_proc;
++++
++++    //int s=splhigh();
++++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
++++    //kprintf("Out of thread fork:%d\n",flag);
++++    if(flag)
++++    {
++++    	kfree(copyt);
++++    	as_destroy(adrcopy);
++++
++++    	return flag;
++++    }
++++    //new_proc->pid=(pid_t)childid;
++++    p_table[childid]->self=new_proc;
++++    new_proc->proc=p_table[childid];
++++
++++   //kprintf("Child id:%d",new_proc->pid);
++++    //new_proc->t_filetable->
++++    //for(i=0;i<128;i++)
++++    //{
++++    	flag=filetable_copy(&new_proc->t_filetable);
++++    //}
++++    //splx(s);
++++   // kprintf("Fork over!");
++++
++++    *retval=p_table[childid]->pid;
++++    kprintf("Return val in fork:%d",*retval);
++++    return 0;
++++
++++    //flag=
++++     //flag=thread_fork=
++++}
++++
++++
++++
++++int sys_execv(char* progname,char** arguments,int *retval)
++++{
++++	int flag;
++++	int numargs;
++++	// first we need to copy the program name to the kernel space
++++	// then we go for arguments. Path size unknown
++++
++++	size_t actual_size=0;
++++	char namedes[PATH_MAX+1];
++++
++++
++++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
++++	if(flag!=0)
++++	{
++++		kfree(namedes);
++++		return flag;
++++	}
++++	//namedes[actual_size]
++++	if(strlen(namedes)==0)
++++	{
++++		*retval=1;
++++		return ENOENT;
++++	}
++++
++++
++++	// now we open file using vfs_open. Same as runprogram
++++	struct vnode* vn;
++++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
++++	if(flag)
++++	{
++++		return flag;
++++	}
++++	actual_size=0;
++++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++++
++++	//char** kargv=(char**)kmalloc(sizeof(char));
++++	// get the number of arguments
++++
++++	numargs=0;
++++	while(arguments[numargs]!=NULL)
++++	{
++++		numargs=numargs+1;
++++	}
++++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
++++	int i;
++++	for(i=0;i<numargs;i++)
++++	{
++++		actual_size=0;
++++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
++++		if(flag)
++++		{
++++			kfree(kargv);
++++			kfree(namedes);
++++			return flag;
++++		}
++++
++++	}
++++	actual_size=0;
++++
++++	// same as runprogram
++++
++++	curthread->t_addrspace=as_create();
++++	if(curthread->t_addrspace==NULL)
++++	{
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	vaddr_t entrypoint, stackptr;
++++	as_activate(curthread->t_addrspace);
++++	flag = load_elf(vn, &entrypoint);
++++		if (flag) {
++++			/* thread_exit destroys curthread->t_addrspace */
++++			vfs_close(vn);
++++			return flag;
++++		}
++++
++++	vfs_close(vn);
++++
++++// now set up the user stack with the arguments
++++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++++		if (flag) {
++++			/* thread_exit destroys curthread->t_addrspace */
++++			return flag;
++++		}
++++
++++		for(i=numargs;i>0;i--)
++++		{
++++			actual_size=0;
++++			int length=strlen(kargv[i])+1;
++++			//int length=strlen(kargv[i]);
++++			int padder=length%4;
++++			if(padder!=0)
++++			length=length+padder;
++++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
++++			//stackptr=stackptr+length;
++++			stackptr=stackptr-length;
++++
++++
++++		}
++++		enter_new_process(numargs,(userptr_t)stackptr,
++++					  stackptr, entrypoint);
++++		//pt_getthread();
++++
++++
++++			/* enter_new_process does not return. */
++++			panic("enter_new_process returned\n");
++++			return EINVAL;
++++}
++++
++++
++++int sys_getpid(pid_t *retval)
++++{
++++	*retval=curthread->pid;
++++	return 0;
++++}
++++
++++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
++++{
++++	struct process* wthread=NULL;
++++	pid_t i;
++++	kprintf("PID in wait pid:%d\n",pid);
++++	if(options!=0)
++++		return EINVAL;
++++	if (pid==curthread->pid)
++++		return ECHILD;
++++	if (pid<PID_MIN||pid>PID_MAX)
++++		return ESRCH;
++++	if (status==NULL)
++++		return EFAULT;
++++	kprintf("Got Here\n");
++++	for(i=0;i<=16;i++)
++++	{
++++		if(p_table[i]->pid==pid)
++++		{
++++			wthread=p_table[i];
++++			break;
++++		}
++++	}
++++	if(wthread==NULL)
++++	{
++++		return ESRCH;
++++	}
++++	//panic("We are here");
++++
++++	lock_acquire(p_table[i]->tlock);
++++
++++	while(!wthread->exited)
++++	{
++++
++++		cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++++	}
++++
++++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++++	//kprintf("We are here!");
++++	*status=wthread->exitcode;
++++	//kfree(p_table[i]->exitsem);
++++	//p_table[i]=NULL;
++++	//kfree(p_table[i]);
++++	//panic("After kfree");
++++	//p_table[i]=NULL;
++++	lock_release(p_table[i]->tlock);
++++	*retval=pid;
++++	//panic("After dereferencing");
++++	return 0;
++++
++++
++++	//return -1;
++++	//return 0;
++++}
++++
++++void sys_exit(int exitcode)
++++{
++++pid_t pid=curthread->proc->pid;
++++pid_t i=PID_MIN;
++++struct process* ethread;
++++//pid_t parent;
++++
++++for(i=0;i<=16;i++)
++++{
++++	if(p_table[i]->pid==pid)
++++	{
++++			ethread=p_table[i];
++++			break;
++++	}
++++}
++++
++++//parent=ethread->ppid;
++++if(ethread!=NULL)
++++{
++++lock_acquire(ethread->tlock);
++++ethread->exitcode=_MKWAIT_EXIT(exitcode);
++++ethread->exited=1;
++++//p_table[i]=ethread;
++++cv_broadcast(ethread->wcv,ethread->tlock);
++++lock_release(ethread->tlock);
++++}
++++i=0;
++++//kprintf("Before hanging");
++++thread_exit();
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..851f9ea 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -40,6 +40,8 @@
+++ #include <current.h>
+++ #include <synch.h>
+++ 
++++#define MAXREADERS 20;
++++
+++ ////////////////////////////////////////////////////////////
+++ //
+++ // Semaphore.
+++@@ -162,9 +164,17 @@ lock_create(const char *name)
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
+++-        // add stuff here as needed
+++-        
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
+++         return lock;
+++ }
+++ 
+++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+++ 
+++         // add stuff here as needed
+++         
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
+++         kfree(lock->lk_name);
+++         kfree(lock);
+++ }
+++@@ -183,26 +195,78 @@ void
+++ lock_acquire(struct lock *lock)
+++ {
+++         // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(&lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -225,7 +289,18 @@ cv_create(const char *name)
+++                 kfree(cv);
+++                 return NULL;
+++         }
+++-        
++++        cv->cv_wchan = wchan_create(cv->cv_name);
++++                	if (cv->cv_wchan == NULL) {
++++                		kfree(cv->cv_name);
++++                		kfree(cv);
++++                		return NULL;
++++                	}
++++
++++                	//spinlock_init(&cv->cv_lock);
++++                        //lock->hold = 0;
++++        		//lock->holder=NULL;
++++                //lock->=NULL
++++                return cv;
+++         // add stuff here as needed
+++         
+++         return cv;
+++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+++ 
+++         // add stuff here as needed
+++         
++++        //spinlock_cleanup(&cv->cv_lock);
++++        
++++        wchan_destroy(cv->cv_wchan);
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++ }
+++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	//KASSERT(lock_do_i_hold(lock));
++++	wchan_lock(cv->cv_wchan);
++++	lock_release(lock);
++++	
++++	wchan_sleep(cv->cv_wchan);
++++	lock_acquire(lock);
++++	
++++    // Write this
++++    //(void)cv;    // suppress warning until code gets written
++++    //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++         // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeone(cv->cv_wchan);
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeall(cv->cv_wchan);
++++		
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
++++}
++++
++++struct rwlock *rwlock_create(const char *name)
++++{
++++	struct rwlock *rw;
++++	rw=kmalloc(sizeof(struct rwlock));
++++	if(rw==NULL)
++++	{
++++		return NULL;
++++	}
++++	rw->rwlock_name=kstrdup(name);
++++	if(rw->rwlock_name==NULL)
++++	{
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++++	if(rw->rd_wchan==NULL)
++++	{
++++		kfree(rw->rwlock_name);
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++++		if(rw->wr_wchan==NULL)
++++		{
++++			kfree(rw->rwlock_name);
++++			kfree(rw);
++++			return NULL;
++++		}
++++		rw->rw_sem=sem_create("mysem",20);
++++		rw->rw_lock=lock_create("mylock");
++++	///rw->res_count=MAXREADERS;
++++	return rw;
++++	
++++}
++++void rwlock_destroy(struct rwlock *rw)
++++{
++++		KASSERT(rw != NULL);
++++		
++++		wchan_destroy(rw->rd_wchan);
++++		wchan_destroy(rw->wr_wchan);
++++		sem_destroy(rw->rw_sem);
++++		lock_destroy(rw->rw_lock);
++++	    kfree(rw->rwlock_name);
++++        kfree(rw);	
++++}
++++
++++void rwlock_acquire_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	P(rw->rw_sem);
++++	lock_release(rw->rw_lock);
++++}
++++void rwlock_release_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	V(rw->rw_sem);
++++	//lock_release(rw->rw_lock);
++++}
++++void rwlock_acquire_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	//rwlock->rw_sem->V();
++++	for(i=0;i<20;i++)
++++	{
++++	P(rw->rw_sem);
++++	}	
++++	lock_release(rw->rw_lock);
++++	
++++	
+++ }
++++void rwlock_release_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	for(i=0;i<20;i++)
++++	{
++++	V(rw->rw_sem);
++++	}	
++++	//lock_release(rw->rw_lock);
++++	
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+++new file mode 100644
+++index 0000000..b9680d1
+++--- /dev/null
++++++ b/kern/thread/synch.c~
+++@@ -0,0 +1,329 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Synchronization primitives.
++++ * The specifications of the functions are in synch.h.
++++ */
++++
++++#include <types.h>
++++#include <lib.h>
++++#include <spinlock.h>
++++#include <wchan.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Semaphore.
++++
++++struct semaphore *
++++sem_create(const char *name, int initial_count)
++++{
++++        struct semaphore *sem;
++++
++++        KASSERT(initial_count >= 0);
++++
++++        sem = kmalloc(sizeof(struct semaphore));
++++        if (sem == NULL) {
++++                return NULL;
++++        }
++++
++++        sem->sem_name = kstrdup(name);
++++        if (sem->sem_name == NULL) {
++++                kfree(sem);
++++                return NULL;
++++        }
++++
++++	sem->sem_wchan = wchan_create(sem->sem_name);
++++	if (sem->sem_wchan == NULL) {
++++		kfree(sem->sem_name);
++++		kfree(sem);
++++		return NULL;
++++	}
++++
++++	spinlock_init(&sem->sem_lock);
++++        sem->sem_count = initial_count;
++++
++++        return sem;
++++}
++++
++++void
++++sem_destroy(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	/* wchan_cleanup will assert if anyone's waiting on it */
++++	spinlock_cleanup(&sem->sem_lock);
++++	wchan_destroy(sem->sem_wchan);
++++        kfree(sem->sem_name);
++++        kfree(sem);
++++}
++++
++++void 
++++P(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++        /*
++++         * May not block in an interrupt handler.
++++         *
++++         * For robustness, always check, even if we can actually
++++         * complete the P without blocking.
++++         */
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++        while (sem->sem_count == 0) {
++++		/*
++++		 * Bridge to the wchan lock, so if someone else comes
++++		 * along in V right this instant the wakeup can't go
++++		 * through on the wchan until we've finished going to
++++		 * sleep. Note that wchan_sleep unlocks the wchan.
++++		 *
++++		 * Note that we don't maintain strict FIFO ordering of
++++		 * threads going through the semaphore; that is, we
++++		 * might "get" it on the first try even if other
++++		 * threads are waiting. Apparently according to some
++++		 * textbooks semaphores must for some reason have
++++		 * strict ordering. Too bad. :-)
++++		 *
++++		 * Exercise: how would you implement strict FIFO
++++		 * ordering?
++++		 */
++++		wchan_lock(sem->sem_wchan);
++++		spinlock_release(&sem->sem_lock);
++++                wchan_sleep(sem->sem_wchan);
++++
++++		spinlock_acquire(&sem->sem_lock);
++++        }
++++        KASSERT(sem->sem_count > 0);
++++        sem->sem_count--;
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++void
++++V(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++
++++        sem->sem_count++;
++++        KASSERT(sem->sem_count > 0);
++++	wchan_wakeone(sem->sem_wchan);
++++
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Lock.
++++
++++struct lock *
++++lock_create(const char *name)
++++{
++++        struct lock *lock;
++++
++++        lock = kmalloc(sizeof(struct lock));
++++        if (lock == NULL) {
++++                return NULL;
++++        }
++++
++++        lock->lk_name = kstrdup(name);
++++        if (lock->lk_name == NULL) {
++++                kfree(lock);
++++                return NULL;
++++        }
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
++++        return lock;
++++}
++++
++++void
++++lock_destroy(struct lock *lock)
++++{
++++        KASSERT(lock != NULL);
++++
++++        // add stuff here as needed
++++        
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
++++        kfree(lock->lk_name);
++++        kfree(lock);
++++}
++++
++++void
++++lock_acquire(struct lock *lock)
++++{
++++        // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
++++
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++lock_release(struct lock *lock)
++++{
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
++++        // Write this
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++bool
++++lock_do_i_hold(struct lock *lock)
++++{
++++        // Write this
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// CV
++++
++++
++++struct cv *
++++cv_create(const char *name)
++++{
++++        struct cv *cv;
++++
++++        cv = kmalloc(sizeof(struct cv));
++++        if (cv == NULL) {
++++                return NULL;
++++        }
++++
++++        cv->cv_name = kstrdup(name);
++++        if (cv->cv_name==NULL) {
++++                kfree(cv);
++++                return NULL;
++++        }
++++        
++++        // add stuff here as needed
++++        
++++        return cv;
++++}
++++
++++void
++++cv_destroy(struct cv *cv)
++++{
++++        KASSERT(cv != NULL);
++++
++++        // add stuff here as needed
++++        
++++        kfree(cv->cv_name);
++++        kfree(cv);
++++}
++++
++++void
++++cv_wait(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++        (void)cv;    // suppress warning until code gets written
++++        (void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_signal(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_broadcast(struct cv *cv, struct lock *lock)
++++{
++++	// Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..df129b9 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+++ 
+++ /* Used to wait for secondary CPUs to come online. */
+++ static struct semaphore *cpu_startup_sem;
++++pid_t pidcount;
++++struct process* p_table[17];
+++ 
+++ ////////////////////////////////////////////////////////////
+++ 
+++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -352,8 +357,15 @@ thread_bootstrap(void)
+++ {
+++ 	struct cpu *bootcpu;
+++ 	struct thread *bootthread;
++++	int i;
+++ 
+++ 	cpuarray_init(&allcpus);
++++	pidcount=PID_MIN;
++++
++++	for(i=0;i<=16;i++)
++++	{
++++		p_table[i]=NULL;
++++	}
+++ 
+++ 	/*
+++ 	 * Create the cpu structure for the bootup CPU, the one we're
+++@@ -365,6 +377,7 @@ thread_bootstrap(void)
+++ 	 */
+++ 	bootcpu = cpu_create(0);
+++ 	bootthread = bootcpu->c_curthread;
++++	//bootthread->pid=PID_MIN;
+++ 
+++ 	/*
+++ 	 * Initializing curcpu and curthread is machine-dependent
+++@@ -519,7 +532,7 @@ thread_fork(const char *name,
+++ 	 * for the spllower() that will be done releasing it.
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++-
++++	//newthread->pid=pidcount++;
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 	switch (newstate) {
+++ 	    case S_RUN:
+++ 		panic("Illegal S_RUN in thread_switch\n");
+++-		break;
+++ 	    case S_READY:
+++ 		thread_make_runnable(cur, true /*have lock*/);
+++ 		break;
+++@@ -799,6 +811,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
+++diff --git a/single10.patch b/single10.patch
+++new file mode 100644
+++index 0000000..2267436
+++--- /dev/null
++++++ b/single10.patch
+++@@ -0,0 +1,915 @@
++++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++++index 0f773bd..68c73ff 100644
++++--- a/kern/arch/mips/syscall/syscall.c
+++++++ b/kern/arch/mips/syscall/syscall.c
++++@@ -32,6 +32,7 @@
++++ #include <kern/syscall.h>
++++ #include <lib.h>
++++ #include <mips/trapframe.h>
+++++#include <copyinout.h>
++++ #include <thread.h>
++++ #include <current.h>
++++ #include <syscall.h>
++++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++++ {
++++ 	int callno;
++++ 	int32_t retval;
+++++        int32_t retvalv1 = 0;
+++++        int64_t retval64;
++++ 	int err;
+++++        int32_t stackarg1;
++++ 
++++ 	KASSERT(curthread != NULL);
++++ 	KASSERT(curthread->t_curspl == 0);
++++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++++ 		err = sys___time((userptr_t)tf->tf_a0,
++++ 				 (userptr_t)tf->tf_a1);
++++ 		break;
+++++            case SYS_open:
+++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_read:
+++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_write:
+++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++				&retval);
+++++		break;
+++++	    case SYS_close:
+++++		err = sys_close(tf->tf_a0);
+++++		break;
+++++	    case SYS_lseek:
+++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++++                                stackarg1, &retval64);
+++++                retval = retval64 >> 32;
+++++                retvalv1 = (int) retval64;
+++++		break;
+++++	    case SYS_dup2:
+++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
+++++	    case SYS_chdir:
+++++		err = sys_chdir((userptr_t)tf->tf_a0);
+++++		break;
+++++	    case SYS___getcwd:
+++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
++++ 
++++ 	    /* Add stuff here */
++++  
++++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++++ 	else {
++++ 		/* Success. */
++++ 		tf->tf_v0 = retval;
+++++                tf->tf_v1 = retvalv1;
++++ 		tf->tf_a3 = 0;      /* signal no error */
++++ 	}
++++ 	
++++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++++index d527f61..e1d7682 100644
++++--- a/kern/conf/conf.kern
+++++++ b/kern/conf/conf.kern
++++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++++ file      syscall/loadelf.c
++++ file      syscall/runprogram.c
++++ file      syscall/time_syscalls.c
+++++file      syscall/file_syscalls.c
+++++file      syscall/file.c
++++ 
++++ #
++++ # Startup and initialization
++++diff --git a/kern/include/file.h b/kern/include/file.h
++++new file mode 100644
++++index 0000000..2c63bc2
++++--- /dev/null
+++++++ b/kern/include/file.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Declarations for file handle and file table management.
+++++ * New for SOL2.
+++++ */
+++++
+++++#ifndef _FILE_H_
+++++#define _FILE_H_
+++++
+++++#include <limits.h>
+++++
+++++struct lock;
+++++struct vnode;
+++++
+++++/*** openfile section ***/
+++++
+++++/* 
+++++ * openfile struct 
+++++ * note that there's not too much to keep track of, since the vnode does most
+++++ * of that.  note that it does require synchronization, because a single
+++++ * openfile can be shared between processes (filetable inheritance).
+++++ */
+++++struct openfile {
+++++	struct vnode *of_vnode;
+++++	
+++++	struct lock *of_lock;
+++++	off_t of_offset;
+++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++++	int of_refcount;
+++++};
+++++
+++++/* opens a file (must be kernel pointers in the args) */
+++++int file_open(char *filename, int flags, int mode, int *retfd);
+++++
+++++/* closes a file */
+++++int file_close(int fd);
+++++
+++++
+++++/*** file table section ***/
+++++
+++++/*
+++++ * filetable struct
+++++ * just an array of open files.  nice and simple.  doesn't require
+++++ * synchronization, because a table can only be owned by a single process (on
+++++ * inheritance in fork, the table is copied).
+++++ */
+++++struct filetable {
+++++	struct openfile *ft_openfiles[OPEN_MAX];
+++++};
+++++
+++++/* these all have an implicit arg of the curthread's filetable */
+++++int filetable_init(const char *inpath, const char *outpath, 
+++++		   const char *errpath);
+++++int filetable_copy(struct filetable **copy);
+++++int filetable_placefile(struct openfile *file, int *fd);
+++++int filetable_findfile(int fd, struct openfile **file);
+++++int filetable_dup2file(int oldfd, int newfd);
+++++void filetable_destroy(struct filetable *ft);
+++++
+++++#endif /* _FILE_H_ */
++++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++++index befd3d8..f3a01ad 100644
++++--- a/kern/include/syscall.h
+++++++ b/kern/include/syscall.h
++++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++++  * Prototypes for IN-KERNEL entry points for system call implementations.
++++  */
++++ 
+++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_close(int fd);
+++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++++int sys_dup2(int oldfd, int newfd, int *retval);
+++++int sys_chdir(userptr_t path);
+++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++++
++++ int sys_reboot(int code);
++++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++ 
++++diff --git a/kern/include/thread.h b/kern/include/thread.h
++++index 86706ca..08b8f8c 100644
++++--- a/kern/include/thread.h
+++++++ b/kern/include/thread.h
++++@@ -112,6 +112,7 @@ struct thread {
++++ 	struct vnode *t_cwd;		/* current working directory */
++++ 
++++ 	/* add more here as needed */
+++++  struct filetable *t_filetable;
++++ };
++++ 
++++ /* Call once during system startup to allocate data structures. */
++++diff --git a/kern/include/uio.h b/kern/include/uio.h
++++index 5d97c48..c9124e8 100644
++++--- a/kern/include/uio.h
+++++++ b/kern/include/uio.h
++++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++++ void uio_kinit(struct iovec *, struct uio *,
++++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++++ 
+++++void uio_uinit(struct iovec *, struct uio *,
+++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++++
++++ 
++++ #endif /* _UIO_H_ */
++++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++++index 594fe96..83ea620 100644
++++--- a/kern/lib/uio.c
+++++++ b/kern/lib/uio.c
++++@@ -153,6 +153,7 @@ void
++++ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++++ {
+++++	KASSERT(u);
++++ 	iov->iov_kbase = kbuf;
++++ 	iov->iov_len = len;
++++ 	u->uio_iov = iov;
++++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	u->uio_rw = rw;
++++ 	u->uio_space = NULL;
++++ }
+++++
+++++void
+++++uio_uinit(struct iovec *iov, struct uio *u,
+++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++++{
+++++	KASSERT(u);
+++++	iov->iov_ubase = ubuf;
+++++	iov->iov_len = len;
+++++  u->uio_iov = iov;
+++++	u->uio_iovcnt = 1;
+++++	u->uio_offset = pos;
+++++	u->uio_resid = len;
+++++	u->uio_segflg = UIO_USERSPACE;
+++++	u->uio_rw = rw;
+++++	u->uio_space = curthread->t_addrspace;
+++++}
++++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++++new file mode 100644
++++index 0000000..dc5ffe5
++++--- /dev/null
+++++++ b/kern/syscall/file.c
++++@@ -0,0 +1,341 @@
+++++/*
+++++ * File handles and file tables.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++
+++++/*** openfile functions ***/
+++++
+++++/*
+++++ * file_open
+++++ * opens a file, places it in the filetable, sets RETFD to the file
+++++ * descriptor. the pointer arguments must be kernel pointers.
+++++ * NOTE -- the passed in filename must be a mutable string.
+++++ */
+++++int
+++++file_open(char *filename, int flags, int mode, int *retfd)
+++++{
+++++	struct vnode *vn;
+++++	struct openfile *file;
+++++	int result;
+++++	
+++++	result = vfs_open(filename, flags, mode, &vn);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	file = kmalloc(sizeof(struct openfile));
+++++	if (file == NULL) {
+++++		vfs_close(vn);
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* initialize the file struct */
+++++	file->of_lock = lock_create("file lock");
+++++	if (file->of_lock == NULL) {
+++++		vfs_close(vn);
+++++		kfree(file);
+++++		return ENOMEM;
+++++	}
+++++	file->of_vnode = vn;
+++++	file->of_offset = 0;
+++++	file->of_accmode = flags & O_ACCMODE;
+++++	file->of_refcount = 1;
+++++
+++++	/* vfs_open checks for invalid access modes */
+++++	KASSERT(file->of_accmode==O_RDONLY ||
+++++	        file->of_accmode==O_WRONLY ||
+++++	        file->of_accmode==O_RDWR);
+++++
+++++	/* place the file in the filetable, getting the file descriptor */
+++++	result = filetable_placefile(file, retfd);
+++++	if (result) {
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++		vfs_close(vn);
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * file_doclose
+++++ * shared code for file_close and filetable_destroy
+++++ */
+++++static
+++++int
+++++file_doclose(struct openfile *file)
+++++{
+++++	lock_acquire(file->of_lock);
+++++
+++++	/* if this is the last close of this file, free it up */
+++++	if (file->of_refcount == 1) {
+++++		vfs_close(file->of_vnode);
+++++		lock_release(file->of_lock);
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++	}
+++++	else {
+++++		KASSERT(file->of_refcount > 1);
+++++		file->of_refcount--;
+++++		lock_release(file->of_lock);
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * file_close
+++++ * knock off the refcount, freeing the memory if it goes to 0.
+++++ */
+++++int
+++++file_close(int fd)
+++++{
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* find the file in the filetable */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	result = file_doclose(file);
+++++	if (result) {
+++++		/* leave file open for possible retry */
+++++		return result;
+++++	}
+++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++
+++++	return 0;
+++++}
+++++
+++++/*** filetable functions ***/
+++++
+++++/* 
+++++ * filetable_init
+++++ * pretty straightforward -- allocate the space, initialize to NULL.
+++++ * note that the one careful thing is to open the std i/o in order to
+++++ * get
+++++ * stdin  == 0
+++++ * stdout == 1
+++++ * stderr == 2
+++++ */
+++++int
+++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++++{
+++++	/* the filenames come from the kernel; assume reasonable length */
+++++	char path[32];
+++++	int result;
+++++	int fd;
+++++
+++++	/* make sure we can fit these */
+++++	KASSERT(strlen(inpath) < sizeof(path));
+++++	KASSERT(strlen(outpath) < sizeof(path));
+++++	KASSERT(strlen(errpath) < sizeof(path));
+++++	
+++++	/* catch memory leaks, repeated calls */
+++++	KASSERT(curthread->t_filetable == NULL);
+++++
+++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++++	if (curthread->t_filetable == NULL) {
+++++		return ENOMEM;
+++++	}
+++++	
+++++	/* NULL-out the table */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++	}
+++++
+++++	/*
+++++	 * open the std fds.  note that the names must be copied into
+++++	 * the path buffer so that they're mutable.
+++++	 */
+++++	strcpy(path, inpath);
+++++	result = file_open(path, O_RDONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, outpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, errpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_copy
+++++ * again, pretty straightforward.  the subtle business here is that instead of
+++++ * copying the openfile structure, we just increment the refcount.  this means
+++++ * that openfile structs will, in fact, be shared between processes, as in
+++++ * Unix.
+++++ */
+++++int
+++++filetable_copy(struct filetable **copy)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int fd;
+++++
+++++	/* waste of a call, really */
+++++	if (ft == NULL) {
+++++		*copy = NULL;
+++++		return 0;
+++++	}
+++++	
+++++	*copy = kmalloc(sizeof(struct filetable));
+++++	
+++++	if (*copy == NULL) {
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* copy over the entries */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd] != NULL) {
+++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++++			ft->ft_openfiles[fd]->of_refcount++;
+++++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++++		} 
+++++		else {
+++++			(*copy)->ft_openfiles[fd] = NULL;
+++++		}
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_destroy
+++++ * closes the files in the file table, frees the table.
+++++ */
+++++void
+++++filetable_destroy(struct filetable *ft)
+++++{
+++++	int fd, result;
+++++
+++++	KASSERT(ft != NULL);
+++++
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd]) {
+++++			result = file_doclose(ft->ft_openfiles[fd]);
+++++			KASSERT(result==0);
+++++		}
+++++	}
+++++	
+++++	kfree(ft);
+++++}	
+++++
+++++/* 
+++++ * filetable_placefile
+++++ * finds the smallest available file descriptor, places the file at the point,
+++++ * sets FD to it.
+++++ */
+++++int
+++++filetable_placefile(struct openfile *file, int *fd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int i;
+++++	
+++++	for (i = 0; i < OPEN_MAX; i++) {
+++++		if (ft->ft_openfiles[i] == NULL) {
+++++			ft->ft_openfiles[i] = file;
+++++			*fd = i;
+++++			return 0;
+++++		}
+++++	}
+++++
+++++	return EMFILE;
+++++}
+++++
+++++/*
+++++ * filetable_findfile
+++++ * verifies that the file descriptor is valid and actually references an
+++++ * open file, setting the FILE to the file at that index if it's there.
+++++ */
+++++int
+++++filetable_findfile(int fd, struct openfile **file)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++
+++++	if (fd < 0 || fd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++	
+++++	*file = ft->ft_openfiles[fd];
+++++	if (*file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_dup2file
+++++ * verifies that both file descriptors are valid, and that the OLDFD is
+++++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++++ */
+++++int
+++++filetable_dup2file(int oldfd, int newfd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++
+++++	file = ft->ft_openfiles[oldfd];
+++++	if (file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++++	if (oldfd == newfd) {
+++++		return 0;
+++++	}
+++++
+++++	/* closes the newfd if it's open */
+++++	if (ft->ft_openfiles[newfd] != NULL) {
+++++		result = file_close(newfd);
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
+++++
+++++	/* up the refcount */
+++++	lock_acquire(file->of_lock);
+++++	file->of_refcount++;
+++++	lock_release(file->of_lock);
+++++
+++++	/* doesn't need to be synchronized because it's just changing the ft */
+++++	ft->ft_openfiles[newfd] = file;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++++new file mode 100644
++++index 0000000..8aa024c
++++--- /dev/null
+++++++ b/kern/syscall/file_syscalls.c
++++@@ -0,0 +1,270 @@
+++++/*
+++++ * File-related system call implementations.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <kern/seek.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++#include <copyinout.h>
+++++
+++++/*
+++++ * sys_open
+++++ * just copies in the filename, then passes work to file_open.
+++++ */
+++++int
+++++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++++{
+++++	char fname[PATH_MAX];
+++++	int result;
+++++
+++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return file_open(fname, flags, mode, retval);
+++++}
+++++
+++++/*
+++++ * sys_read
+++++ * translates the fd into its openfile, then calls VOP_READ.
+++++ */
+++++int
+++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* better be a valid file descriptor */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_WRONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++++  
+++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++++
+++++	/* does the read */
+++++	result = VOP_READ(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++	
+++++	/*
+++++	 * The amount read is the size of the buffer originally, minus
+++++	 * how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * sys_write
+++++ * translates the fd into its openfile, then calls VOP_WRITE.
+++++ */
+++++int
+++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_RDONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++++	
+++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++++
+++++	/* does the write */
+++++	result = VOP_WRITE(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	/*
+++++	 * the amount written is the size of the buffer originally,
+++++	 * minus how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_close
+++++ * just pass off the work to file_close.
+++++ */
+++++int
+++++sys_close(int fd)
+++++{
+++++	return file_close(fd);
+++++}
+++++
+++++/*
+++++ * sys_lseek
+++++ * translates the fd into its openfile, then based on the type of seek,
+++++ * figure out the new offset, try the seek, if that succeeds, update the
+++++ * openfile.
+++++ */
+++++int
+++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++++{
+++++	struct stat info;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++	
+++++	/* based on the type of seek, set the retval */ 
+++++	switch (whence) {
+++++	    case SEEK_SET:
+++++		*retval = offset;
+++++		break;
+++++	    case SEEK_CUR:
+++++		*retval = file->of_offset + offset;
+++++		break;
+++++	    case SEEK_END:
+++++		result = VOP_STAT(file->of_vnode, &info);
+++++		if (result) {
+++++			lock_release(file->of_lock);
+++++			return result;
+++++		}
+++++		*retval = info.st_size + offset;
+++++		break;
+++++	    default:
+++++		lock_release(file->of_lock);
+++++		return EINVAL;
+++++	}
+++++
+++++	/* try the seek -- if it fails, return */
+++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++	
+++++	/* success -- update the file structure */
+++++	file->of_offset = *retval;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_dup2
+++++ * just pass the work off to the filetable
+++++ */
+++++int
+++++sys_dup2(int oldfd, int newfd, int *retval)
+++++{
+++++	int result;
+++++
+++++	result = filetable_dup2file(oldfd, newfd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = newfd;
+++++	return 0;
+++++}
+++++
+++++/* really not "file" calls, per se, but might as well put it here */
+++++
+++++/*
+++++ * sys_chdir
+++++ * copyin the path and pass it off to vfs.
+++++ */
+++++int
+++++sys_chdir(userptr_t path)
+++++{
+++++	char pathbuf[PATH_MAX];
+++++	int result;
+++++	
+++++	result = copyinstr(path, pathbuf, PATH_MAX, 
++\ No newline at end of file
++diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
++new file mode 100644
++index 0000000..fe21882
++--- /dev/null
+++++ b/user/testbin/myforktest/Makefile
++@@ -0,0 +1,11 @@
+++# Makefile for forktest
+++
+++TOP=../../..
+++.include "$(TOP)/mk/os161.config.mk"
+++
+++PROG=myforktest
+++SRCS=myforktest.c
+++BINDIR=/testbin
+++
+++.include "$(TOP)/mk/os161.prog.mk"
+++
++diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
++new file mode 100644
++index 0000000..8b3a1cd
++--- /dev/null
+++++ b/user/testbin/myforktest/myforktest.c
++@@ -0,0 +1,28 @@
+++#include <unistd.h>
+++#include <string.h>
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <err.h>
+++
+++int main()
+++{
+++	int status;
+++	int pid;
+++	int returnCode=fork();
+++
+++	if(returnCode==0)
+++	{
+++		//printf("I am child\n");
+++		return -10;
+++	}
+++	else
+++	{
+++		//printf("Return:%d",returnCode);
+++		//printf("Wait for child\n");
+++		pid=waitpid(returnCode,&status,0);
+++		printf("Child id returned" "%d",pid);
+++		printf(" Return code: %d\n",status);
+++
+++	}
+++	return 0;
+++}
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..8b3a1cd
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,28 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		//printf("I am child\n");
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/submit2.patch b/submit2.patch
new file mode 100644
index 0000000..ab0823b
--- /dev/null
+++ b/submit2.patch
@@ -0,0 +1,13384 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..33b99ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	int flag;
++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	if(flag)
++	{
++		newtf.tf_v0=ENOMEM;
++		newtf.tf_a3=1;
++	}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	curthread->pid=newtf.tf_a0;
++
++	as_activate(curthread->t_addrspace);
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..a4c2750 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	fthread->proc->tlock=lock_create("First Lock");
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..c8d768b
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,741 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro)
++{
++	//lock_acquire(mypro->tlock);
++	while(!mypro->exited)
++	{
++		cv_wait(mypro->wcv,mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++
++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
++{
++	(void)adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
++	bzero(copyt,sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt,tf,sizeof(struct trapframe));
++	flag=as_copy(curthread->t_addrspace,&adrcopy);
++	//if(curthread->pid==0)
++	//{
++		//curthread->pid=PID_MIN;
++	//}
++    if(flag)
++    {
++    	kfree(copyt);
++    	return flag;
++    }
++
++    //we need to allocate pid for our new process
++
++    //pid_t cpid;
++    for(childid=0;childid<=16;childid++)
++    {
++     if(p_table[childid]==NULL)
++     {
++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
++    	p_table[childid]->full=1;
++    	pidcount++;
++    	p_table[childid]->pid=pidcount;
++    	p_table[childid]->ppid=curthread->pid;
++    	//p_table[childid]->exitsem=sem_create("process",0);
++    	p_table[childid]->tlock=lock_create("My Lock");
++    	p_table[childid]->wcv=cv_create("My CV");
++    	p_table[childid]->self=NULL;
++    	break;
++     }
++    }
++    if(childid>PID_MAX)
++    {
++    	*retval=1;
++    	return EMPROC;
++    }
++    //int i;
++
++    copyt->tf_a0=(int)p_table[childid]->pid;
++    //kprintf("Ret:%d\n",copyt->tf_a0);
++    struct thread *new_proc;
++    //curthread->t_addrspace=(struct addrspace*)adrcopy;
++    //int s=splhigh();
++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
++    //kprintf("Out of thread fork:%d\n",flag);
++    if(flag)
++    {
++    	kfree(copyt);
++    	as_destroy(adrcopy);
++
++    	return flag;
++    }
++
++    //new_proc->pid=(pid_t)childid;
++    //new_proc=p_table[childid];
++
++    new_proc->pid=p_table[childid]->pid;
++    new_proc->proc=p_table[childid];
++   // new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++    //if (new_proc->t_filetable == NULL) {
++    //return ENOMEM;
++    //}
++    p_table[childid]->self=new_proc;
++
++    //new_proc->pid=p_table[childid]->pid;
++    //new_proc->proc->pid=p_table[childid]->pid;
++    //kprintf("Child id in fork: %d\n",new_proc->pid);
++
++
++   //kprintf("Child id:%d",new_proc->pid);
++    //new_proc->t_filetable->
++    //for(i=0;i<128;i++)
++    //{
++    flag=filetable_copy(&new_proc->t_filetable);
++    //}
++    //splx(s);
++   // kprintf("Fork over!");
++
++    *retval=p_table[childid]->pid;
++    //kprintf("Return val in fork:%d",*retval);
++    return 0;
++
++    //flag=
++     //flag=thread_fork=
++}
++
++/*
++
++int sys_execv(char* progname,char** arguments,int *retval)
++{
++	int flag;
++	int numargs;
++	int addr;
++	int i;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size=0;
++	char *namedes;
++
++
++	if(progname==NULL)
++	{
++		return EFAULT;
++	}
++	if(progname=="")
++	{
++		return EINVAL;
++	}
++
++
++	namedes=(char*)kmalloc(PATH_MAX);
++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
++	if(flag!=0)
++	{
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if(strlen(namedes)==0)
++	{
++		*retval=1;
++		return EISDIR;
++	}
++
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
++	if(flag)
++	{
++		return flag;
++	}
++	actual_size=0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++	if(arguments==NULL)
++	{
++		kfree(namedes);
++		return EFAULT;
++	}
++	flag=copyin((userptr_t)arguments,&addr,sizeof(int));
++	if(flag)
++	{
++		kfree(namedes);
++		return EFAULT;
++	}
++
++	//check=wthread->exitcode;
++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++	//if(err)
++	//{
++	//	lock_release(p_table[i]->tlock);
++		//return err;
++	//}
++
++	numargs=0;
++	while(arguments[numargs]!=NULL)
++	{
++		//kprintf("%");
++		numargs=numargs+1;
++	}
++
++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
++	int i;
++	for(i=0;i<numargs;i++)
++	{
++		actual_size=0;
++		kargv[i]=(char*)kmalloc(PATH_MAX);
++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
++		if(flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return EFAULT;
++		}
++
++	}
++	actual_size=0;
++
++
++	// same as runprogram
++
++	curthread->t_addrspace=as_create();
++	if(curthread->t_addrspace==NULL)
++	{
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++		if (flag) {
++			// thread_exit destroys curthread->t_addrspace
++			vfs_close(vn);
++			return flag;
++		}
++
++	vfs_close(vn);
++
++// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++		if (flag) {
++			 //thread_exit destroys curthread->t_addrspace
++			return flag;
++		}
++		//i=0;
++
++		for(i=numargs-1;i>=0;i--)
++		{
++			actual_size=0;
++			int length=strlen(kargv[i])+1;
++			//int length=strlen(kargv[i]);
++			int padder=length%4;
++			if(padder!=0)
++			length=length+padder;
++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
++			//stackptr=stackptr+length;
++			stackptr=stackptr-length;
++
++
++		}
++		for(i = numargs; i >= 0; i--)
++		{
++		stackptr -= sizeof(vaddr_t);
++		flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++		if(result)
++		{
++		for(j = 0; j < argc; j++)
++		{
++		kfree(kargv[j]);
++		}
++		kfree(kargv);
++		kfree(filename);
++		return result;
++		}
++		}
++
++		vaddr_t stackptrv[argc+1];
++		for(i = argc-1; i >= 0; i--)
++		{
++		int len = strlen(kargv[i]);
++		len++;
++		int padding = len % 4;
++		stackptr -= len + (4 - padding);
++		result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
++		if(result)
++		{
++		for(j = 0; j < argc; j++)
++		{
++		kfree(kargv[j]);
++		}
++		kfree(kargv);
++		kfree(namedes);
++		return flag;
++		}
++		stackptrv[i] = stackptr;
++		}
++		stackptrv[numargs] = 0;
++		enter_new_process(numargs,(userptr_t)stackptr,
++					  stackptr, entrypoint);
++		//pt_getthread();
++
++
++			//enter_new_process does not return.
++			panic("enter_new_process returned\n");
++			return EINVAL;
++}
++*/
++
++
++
++
++
++int
++sys_execv(char *progname, char **argv)
++{
++struct vnode *v;
++vaddr_t entrypoint, stackptr;
++char **kargv;
++int result;
++int i;
++int j;
++int testAddress;
++int argc = 0;
++size_t actual;
++
++if(progname == NULL)
++{
++return EFAULT;
++}
++
++char *filename = (char *)kmalloc(PATH_MAX);
++result = copyinstr((const_userptr_t)progname, filename, (size_t)NAME_MAX, &actual);
++if(result)
++{
++kfree(filename);
++return result;
++}
++if(strlen(filename) == 0)
++{
++return EINVAL;
++}
++
++if(argv != NULL)
++{
++/* test to see that argv is a valid address */
++result = copyin((const_userptr_t)argv, &testAddress, sizeof(int));
++if(result)
++{
++kfree(filename);
++return result;
++}
++
++/* Get argc */
++while(argv[argc] != NULL)
++{
++argc++;
++}
++/* Create kargv and safely copy in string arguments. */
++kargv = (char **)kmalloc(sizeof(char *) * argc);
++for(i = 0; i < argc; i++)
++{
++kargv[i] = (char *)kmalloc(PATH_MAX);
++result = copyinstr((const_userptr_t)argv[i], kargv[i], PATH_MAX, &actual);
++if(result)
++{
++/* In here I'm just freeing the char *
++* that I've already kmalloc'ed. Not sure
++* if this is correct
++*/
++for(j = 0; j < i; j++)
++{
++kfree(kargv[j]);
++}
++kfree(kargv[i]);
++kfree(kargv);
++kfree(filename);
++return result;
++}
++}
++}
++/* open the file with filename */
++result = vfs_open(filename, O_RDONLY,0,&v);
++if(result)
++{
++if(argv != NULL)
++{
++for(i = 0; i < argc; i++)
++{
++kfree(kargv[i]);
++}
++kfree(kargv);
++}
++kfree(filename);
++return result;
++}
++/* Destroy current address space */
++if(curthread->t_addrspace)
++{
++as_destroy(curthread->t_addrspace);
++curthread->t_addrspace = NULL;
++}
++
++KASSERT(curthread->t_addrspace == NULL);
++
++/* Create new address space */
++curthread->t_addrspace = as_create();
++if(curthread->t_addrspace == NULL)
++{
++vfs_close(v);
++if(argv != NULL)
++{
++for(i = 0; i < argc; i++)
++{
++kfree(kargv[i]);
++}
++kfree(kargv);
++}
++kfree(filename);
++return result;
++}
++
++/* Activate the address space */
++as_activate(curthread->t_addrspace);
++
++/* Load the executable. */
++result = load_elf(v, &entrypoint);
++if (result)
++{
++vfs_close(v);
++if(argv != NULL)
++{
++for(i = 0; i < argc; i++)
++{
++kfree(kargv[i]);
++}
++kfree(kargv);
++}
++kfree(filename);
++return result;
++}
++/* Done with the file now. */
++vfs_close(v);
++
++/* Define the user stack in the address space */
++result = as_define_stack(curthread->t_addrspace, &stackptr);
++if (result) {
++if(argv != NULL)
++{
++for(i = 0; i < argc; i++)
++{
++kfree(kargv[i]);
++}
++kfree(kargv);
++}
++kfree(filename);
++return result;
++}
++
++//if(argv != NULL)
++//{
++/* This hopefully safely copies from kargv into
++* the user stack
++*/
++vaddr_t stackptrv[argc+1];
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(kargv[i]);
++len++;
++int padding = len % 4;
++stackptr -= len + (4 - padding);
++result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++for(j = 0; j < argc; j++)
++{
++kfree(kargv[j]);
++}
++kfree(kargv);
++kfree(filename);
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++
++/* This copies the actual stack addresses of the arguments
++* into the stack. Hopefully.
++*/
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++for(j = 0; j < argc; j++)
++{
++kfree(kargv[j]);
++}
++kfree(kargv);
++kfree(filename);
++return result;
++}
++//}
++
++/* Free everything we have kmalloc'ed */
++for(i = 0; i < argc; i++)
++{
++kfree(kargv[i]);
++}
++kfree(kargv);
++}
++kfree(filename);
++
++/* Warp to user mode */
++//md_usermode(argc, (userptr_t)stackptr, stackptr, entrypoint);
++enter_new_process(argc,(userptr_t)stackptr,
++					  stackptr, entrypoint);
++		//pt_getthread();
++
++/* md_usermode does not return */
++panic("md_usermode returned\n");
++return EINVAL;
++}
++
++
++
++int sys_getpid(pid_t *retval)
++{
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval=curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
++{
++	struct process* wthread=NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if(status==NULL)
++		return EFAULT;
++	if(options!=0)
++		return EINVAL;
++	if (pid==curthread->pid)
++		return ECHILD;
++	if (pid<PID_MIN||pid>PID_MAX)
++		return ESRCH;
++	if (status==NULL)
++		return EFAULT;
++	if(pid==curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++				//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++		//return EFAULT;
++	//}
++
++
++	//if()
++
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++		//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++		//if (result) {
++			//return result;
++		//}
++		//int addr=(int)&status;
++		//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++		//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for(i=0;i<=16;i++)
++	{
++		if(p_table[i]!=NULL)
++		{
++		if(p_table[i]->pid==pid)
++		{
++			wthread=p_table[i];
++			break;
++		}
++		}
++	}
++	if(wthread==NULL)
++	{
++		return ESRCH;
++	}
++	if(curthread->proc->pid!=wthread->ppid)
++	return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check=wthread->exitcode;
++	err=copyout(&check,(userptr_t)status,sizeof(check));
++	if(err)
++	{
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i]=NULL;
++
++	*retval=pid;
++	//panic("After dereferencing");
++	return 0;
++
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode)
++{
++pid_t pid=curthread->proc->pid;
++pid_t i=PID_MIN;
++struct process* ethread;
++//pid_t parent;
++//if(pid!=2)
++//{
++for(i=0;i<=16;i++)
++{
++	if(p_table[i]!=NULL)
++	{
++	if(p_table[i]->pid==pid)
++	{
++			ethread=p_table[i];
++			break;
++	}
++	}
++}
++
++//parent=ethread->ppid;
++if(ethread!=NULL)
++{
++lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++ethread->exitcode=_MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++ethread->exited=1;
++//p_table[i]=ethread;
++cv_broadcast(ethread->wcv,ethread->tlock);
++//kfree(curthread->t_filetable);
++lock_release(ethread->tlock);
++}
++//}
++i=0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++thread_exit();
++}
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..ab0197b 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,39 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++len++;
++int padding = len % 4;
++stackptr -= len + (4 - padding);
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..df129b9 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +357,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +377,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +532,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +811,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..35359e4
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,8869 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..c8d768b
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,741 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro)
+++{
+++	//lock_acquire(mypro->tlock);
+++	while(!mypro->exited)
+++	{
+++		cv_wait(mypro->wcv,mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++
+++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
+++{
+++	(void)adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
+++	bzero(copyt,sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt,tf,sizeof(struct trapframe));
+++	flag=as_copy(curthread->t_addrspace,&adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++		//curthread->pid=PID_MIN;
+++	//}
+++    if(flag)
+++    {
+++    	kfree(copyt);
+++    	return flag;
+++    }
+++
+++    //we need to allocate pid for our new process
+++
+++    //pid_t cpid;
+++    for(childid=0;childid<=16;childid++)
+++    {
+++     if(p_table[childid]==NULL)
+++     {
+++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
+++    	p_table[childid]->full=1;
+++    	pidcount++;
+++    	p_table[childid]->pid=pidcount;
+++    	p_table[childid]->ppid=curthread->pid;
+++    	//p_table[childid]->exitsem=sem_create("process",0);
+++    	p_table[childid]->tlock=lock_create("My Lock");
+++    	p_table[childid]->wcv=cv_create("My CV");
+++    	p_table[childid]->self=NULL;
+++    	break;
+++     }
+++    }
+++    if(childid>PID_MAX)
+++    {
+++    	*retval=1;
+++    	return EMPROC;
+++    }
+++    //int i;
+++
+++    copyt->tf_a0=(int)p_table[childid]->pid;
+++    //kprintf("Ret:%d\n",copyt->tf_a0);
+++    struct thread *new_proc;
+++    //curthread->t_addrspace=(struct addrspace*)adrcopy;
+++    //int s=splhigh();
+++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
+++    //kprintf("Out of thread fork:%d\n",flag);
+++    if(flag)
+++    {
+++    	kfree(copyt);
+++    	as_destroy(adrcopy);
+++
+++    	return flag;
+++    }
+++
+++    //new_proc->pid=(pid_t)childid;
+++    //new_proc=p_table[childid];
+++
+++    new_proc->pid=p_table[childid]->pid;
+++    new_proc->proc=p_table[childid];
+++   // new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++    //if (new_proc->t_filetable == NULL) {
+++    //return ENOMEM;
+++    //}
+++    p_table[childid]->self=new_proc;
+++
+++    //new_proc->pid=p_table[childid]->pid;
+++    //new_proc->proc->pid=p_table[childid]->pid;
+++    //kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++
+++   //kprintf("Child id:%d",new_proc->pid);
+++    //new_proc->t_filetable->
+++    //for(i=0;i<128;i++)
+++    //{
+++    flag=filetable_copy(&new_proc->t_filetable);
+++    //}
+++    //splx(s);
+++   // kprintf("Fork over!");
+++
+++    *retval=p_table[childid]->pid;
+++    //kprintf("Return val in fork:%d",*retval);
+++    return 0;
+++
+++    //flag=
+++     //flag=thread_fork=
+++}
+++
+++/*
+++
+++int sys_execv(char* progname,char** arguments,int *retval)
+++{
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size=0;
+++	char *namedes;
+++
+++
+++	if(progname==NULL)
+++	{
+++		return EFAULT;
+++	}
+++	if(progname=="")
+++	{
+++		return EINVAL;
+++	}
+++
+++
+++	namedes=(char*)kmalloc(PATH_MAX);
+++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
+++	if(flag!=0)
+++	{
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if(strlen(namedes)==0)
+++	{
+++		*retval=1;
+++		return EISDIR;
+++	}
+++
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
+++	if(flag)
+++	{
+++		return flag;
+++	}
+++	actual_size=0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if(arguments==NULL)
+++	{
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag=copyin((userptr_t)arguments,&addr,sizeof(int));
+++	if(flag)
+++	{
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++		//return err;
+++	//}
+++
+++	numargs=0;
+++	while(arguments[numargs]!=NULL)
+++	{
+++		//kprintf("%");
+++		numargs=numargs+1;
+++	}
+++
+++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
+++	int i;
+++	for(i=0;i<numargs;i++)
+++	{
+++		actual_size=0;
+++		kargv[i]=(char*)kmalloc(PATH_MAX);
+++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
+++		if(flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size=0;
+++
+++
+++	// same as runprogram
+++
+++	curthread->t_addrspace=as_create();
+++	if(curthread->t_addrspace==NULL)
+++	{
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++		if (flag) {
+++			// thread_exit destroys curthread->t_addrspace
+++			vfs_close(vn);
+++			return flag;
+++		}
+++
+++	vfs_close(vn);
+++
+++// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++		if (flag) {
+++			 //thread_exit destroys curthread->t_addrspace
+++			return flag;
+++		}
+++		//i=0;
+++
+++		for(i=numargs-1;i>=0;i--)
+++		{
+++			actual_size=0;
+++			int length=strlen(kargv[i])+1;
+++			//int length=strlen(kargv[i]);
+++			int padder=length%4;
+++			if(padder!=0)
+++			length=length+padder;
+++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
+++			//stackptr=stackptr+length;
+++			stackptr=stackptr-length;
+++
+++
+++		}
+++		for(i = numargs; i >= 0; i--)
+++		{
+++		stackptr -= sizeof(vaddr_t);
+++		flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++		if(result)
+++		{
+++		for(j = 0; j < argc; j++)
+++		{
+++		kfree(kargv[j]);
+++		}
+++		kfree(kargv);
+++		kfree(filename);
+++		return result;
+++		}
+++		}
+++
+++		vaddr_t stackptrv[argc+1];
+++		for(i = argc-1; i >= 0; i--)
+++		{
+++		int len = strlen(kargv[i]);
+++		len++;
+++		int padding = len % 4;
+++		stackptr -= len + (4 - padding);
+++		result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
+++		if(result)
+++		{
+++		for(j = 0; j < argc; j++)
+++		{
+++		kfree(kargv[j]);
+++		}
+++		kfree(kargv);
+++		kfree(namedes);
+++		return flag;
+++		}
+++		stackptrv[i] = stackptr;
+++		}
+++		stackptrv[numargs] = 0;
+++		enter_new_process(numargs,(userptr_t)stackptr,
+++					  stackptr, entrypoint);
+++		//pt_getthread();
+++
+++
+++			//enter_new_process does not return.
+++			panic("enter_new_process returned\n");
+++			return EINVAL;
+++}
+++*/
+++
+++
+++
+++
+++
+++int
+++sys_execv(char *progname, char **argv)
+++{
+++struct vnode *v;
+++vaddr_t entrypoint, stackptr;
+++char **kargv;
+++int result;
+++int i;
+++int j;
+++int testAddress;
+++int argc = 0;
+++size_t actual;
+++
+++if(progname == NULL)
+++{
+++return EFAULT;
+++}
+++
+++char *filename = (char *)kmalloc(PATH_MAX);
+++result = copyinstr((const_userptr_t)progname, filename, (size_t)NAME_MAX, &actual);
+++if(result)
+++{
+++kfree(filename);
+++return result;
+++}
+++if(strlen(filename) == 0)
+++{
+++return EINVAL;
+++}
+++
+++if(argv != NULL)
+++{
+++/* test to see that argv is a valid address */
+++result = copyin((const_userptr_t)argv, &testAddress, sizeof(int));
+++if(result)
+++{
+++kfree(filename);
+++return result;
+++}
+++
+++/* Get argc */
+++while(argv[argc] != NULL)
+++{
+++argc++;
+++}
+++/* Create kargv and safely copy in string arguments. */
+++kargv = (char **)kmalloc(sizeof(char *) * argc);
+++for(i = 0; i < argc; i++)
+++{
+++kargv[i] = (char *)kmalloc(PATH_MAX);
+++result = copyinstr((const_userptr_t)argv[i], kargv[i], PATH_MAX, &actual);
+++if(result)
+++{
+++/* In here I'm just freeing the char *
+++* that I've already kmalloc'ed. Not sure
+++* if this is correct
+++*/
+++for(j = 0; j < i; j++)
+++{
+++kfree(kargv[j]);
+++}
+++kfree(kargv[i]);
+++kfree(kargv);
+++kfree(filename);
+++return result;
+++}
+++}
+++}
+++/* open the file with filename */
+++result = vfs_open(filename, O_RDONLY,0,&v);
+++if(result)
+++{
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++/* Destroy current address space */
+++if(curthread->t_addrspace)
+++{
+++as_destroy(curthread->t_addrspace);
+++curthread->t_addrspace = NULL;
+++}
+++
+++KASSERT(curthread->t_addrspace == NULL);
+++
+++/* Create new address space */
+++curthread->t_addrspace = as_create();
+++if(curthread->t_addrspace == NULL)
+++{
+++vfs_close(v);
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++
+++/* Activate the address space */
+++as_activate(curthread->t_addrspace);
+++
+++/* Load the executable. */
+++result = load_elf(v, &entrypoint);
+++if (result)
+++{
+++vfs_close(v);
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++/* Done with the file now. */
+++vfs_close(v);
+++
+++/* Define the user stack in the address space */
+++result = as_define_stack(curthread->t_addrspace, &stackptr);
+++if (result) {
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++
+++//if(argv != NULL)
+++//{
+++/* This hopefully safely copies from kargv into
+++* the user stack
+++*/
+++vaddr_t stackptrv[argc+1];
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(kargv[i]);
+++len++;
+++int padding = len % 4;
+++stackptr -= len + (4 - padding);
+++result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++for(j = 0; j < argc; j++)
+++{
+++kfree(kargv[j]);
+++}
+++kfree(kargv);
+++kfree(filename);
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++
+++/* This copies the actual stack addresses of the arguments
+++* into the stack. Hopefully.
+++*/
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++for(j = 0; j < argc; j++)
+++{
+++kfree(kargv[j]);
+++}
+++kfree(kargv);
+++kfree(filename);
+++return result;
+++}
+++//}
+++
+++/* Free everything we have kmalloc'ed */
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++
+++/* Warp to user mode */
+++//md_usermode(argc, (userptr_t)stackptr, stackptr, entrypoint);
+++enter_new_process(argc,(userptr_t)stackptr,
+++					  stackptr, entrypoint);
+++		//pt_getthread();
+++
+++/* md_usermode does not return */
+++panic("md_usermode returned\n");
+++return EINVAL;
+++}
+++
+++
+++
+++int sys_getpid(pid_t *retval)
+++{
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval=curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
+++{
+++	struct process* wthread=NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if(status==NULL)
+++		return EFAULT;
+++	if(options!=0)
+++		return EINVAL;
+++	if (pid==curthread->pid)
+++		return ECHILD;
+++	if (pid<PID_MIN||pid>PID_MAX)
+++		return ESRCH;
+++	if (status==NULL)
+++		return EFAULT;
+++	if(pid==curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++				//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++		//return EFAULT;
+++	//}
+++
+++
+++	//if()
+++
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++		//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++		//if (result) {
+++			//return result;
+++		//}
+++		//int addr=(int)&status;
+++		//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++		//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for(i=0;i<=16;i++)
+++	{
+++		if(p_table[i]!=NULL)
+++		{
+++		if(p_table[i]->pid==pid)
+++		{
+++			wthread=p_table[i];
+++			break;
+++		}
+++		}
+++	}
+++	if(wthread==NULL)
+++	{
+++		return ESRCH;
+++	}
+++	if(curthread->proc->pid!=wthread->ppid)
+++	return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check=wthread->exitcode;
+++	err=copyout(&check,(userptr_t)status,sizeof(check));
+++	if(err)
+++	{
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i]=NULL;
+++
+++	*retval=pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode)
+++{
+++pid_t pid=curthread->proc->pid;
+++pid_t i=PID_MIN;
+++struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++for(i=0;i<=16;i++)
+++{
+++	if(p_table[i]!=NULL)
+++	{
+++	if(p_table[i]->pid==pid)
+++	{
+++			ethread=p_table[i];
+++			break;
+++	}
+++	}
+++}
+++
+++//parent=ethread->ppid;
+++if(ethread!=NULL)
+++{
+++lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++ethread->exitcode=_MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++ethread->exited=1;
+++//p_table[i]=ethread;
+++cv_broadcast(ethread->wcv,ethread->tlock);
+++//kfree(curthread->t_filetable);
+++lock_release(ethread->tlock);
+++}
+++//}
+++i=0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++thread_exit();
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..ab0197b 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,39 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++len++;
+++int padding = len % 4;
+++stackptr -= len + (4 - padding);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index 5b8099e..60108d3 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -798,6 +801,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..8e688a0
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,4353 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..33b99ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,11 +32,14 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <addrspace.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
+++ 
++++
+++ /*
+++  * System call dispatcher.
+++  *
+++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++                break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++			break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_fork:
++++	    	err=0;
++++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++++	    	break;
++++	    case SYS_execv:
++++	    	err=0;
++++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++++	    	break;
++++	    case SYS_getpid:
++++	    	err=0;
++++	    	err=sys_getpid(&retval);
++++	    	break;
++++	    case SYS_waitpid:
++++	    	err=0;
++++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++	    	//panic("Waitpid over");
++++	    	break;
++++	    case SYS__exit:
++++	    	sys_exit((int)tf->tf_a0);
++++	    	break;
++++
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+++  *
+++  * Thus, you can trash it and do things another way if you prefer.
+++  */
+++-void
+++-enter_forked_process(struct trapframe *tf)
++++//void
++++//enter_forked_process(struct trapframe *tf)
++++//{
++++	//(void)tf;
++++//}
++++
++++void enter_forked_process(void*tf,unsigned long adrspace)
+++ {
+++-	(void)tf;
++++	tf=(struct trapframe*)tf;
++++	struct trapframe newtf;
++++	int flag;
++++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++++	if(flag)
++++	{
++++		newtf.tf_v0=ENOMEM;
++++		newtf.tf_a3=1;
++++	}
++++
++++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++++	kfree(tf);
++++	//tf=NULL;
++++	//int flag;
++++
++++	curthread->pid=newtf.tf_a0;
++++
++++	as_activate(curthread->t_addrspace);
++++
++++
++++
++++	newtf.tf_v0=0;
++++	newtf.tf_a3=0;
++++	newtf.tf_epc+=4;
++++	mips_usermode(&newtf);
+++ }
+++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+++new file mode 100644
+++index 0000000..3e8d5b9
+++--- /dev/null
++++++ b/kern/arch/mips/syscall/syscall.c~
+++@@ -0,0 +1,165 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/syscall.h>
++++#include <lib.h>
++++#include <mips/trapframe.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <syscall.h>
++++
++++
++++/*
++++ * System call dispatcher.
++++ *
++++ * A pointer to the trapframe created during exception entry (in
++++ * exception.S) is passed in.
++++ *
++++ * The calling conventions for syscalls are as follows: Like ordinary
++++ * function calls, the first 4 32-bit arguments are passed in the 4
++++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++++ * unused.
++++ *
++++ * This much is the same as the calling conventions for ordinary
++++ * function calls. In addition, the system call number is passed in
++++ * the v0 register.
++++ *
++++ * On successful return, the return value is passed back in the v0
++++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++++ * function call, and additionally the a3 register is also set to 0 to
++++ * indicate success.
++++ *
++++ * On an error return, the error code is passed back in the v0
++++ * register, and the a3 register is set to 1 to indicate failure.
++++ * (Userlevel code takes care of storing the error code in errno and
++++ * returning the value -1 from the actual userlevel syscall function.
++++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++++ *
++++ * Upon syscall return the program counter stored in the trapframe
++++ * must be incremented by one instruction; otherwise the exception
++++ * return code will restart the "syscall" instruction and the system
++++ * call will repeat forever.
++++ *
++++ * If you run out of registers (which happens quickly with 64-bit
++++ * values) further arguments must be fetched from the user-level
++++ * stack, starting at sp+16 to skip over the slots for the
++++ * registerized values, with copyin().
++++ */
++++void
++++syscall(struct trapframe *tf)
++++{
++++	int callno;
++++	int32_t retval;
++++	int err;
++++
++++	KASSERT(curthread != NULL);
++++	KASSERT(curthread->t_curspl == 0);
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++
++++	callno = tf->tf_v0;
++++
++++	/*
++++	 * Initialize retval to 0. Many of the system calls don't
++++	 * really return a value, just 0 for success and -1 on
++++	 * error. Since retval is the value returned on success,
++++	 * initialize it to 0 by default; thus it's not necessary to
++++	 * deal with it except for calls that return other values, 
++++	 * like write.
++++	 */
++++
++++	retval = 0;
++++
++++	switch (callno) {
++++	    case SYS_reboot:
++++		err = sys_reboot(tf->tf_a0);
++++		break;
++++
++++	    case SYS___time:
++++		err = sys___time((userptr_t)tf->tf_a0,
++++				 (userptr_t)tf->tf_a1);
++++		break;
++++		
++++	    case SYS_open:
++++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++++	    break;
++++
++++	    /* Add stuff here */
++++ 
++++	    default:
++++		kprintf("Unknown syscall %d\n", callno);
++++		err = ENOSYS;
++++		break;
++++	}
++++
++++
++++	if (err) {
++++		/*
++++		 * Return the error code. This gets converted at
++++		 * userlevel to a return value of -1 and the error
++++		 * code in errno.
++++		 */
++++		tf->tf_v0 = err;
++++		tf->tf_a3 = 1;      /* signal an error */
++++	}
++++	else {
++++		/* Success. */
++++		tf->tf_v0 = retval;
++++		tf->tf_a3 = 0;      /* signal no error */
++++	}
++++	
++++	/*
++++	 * Now, advance the program counter, to avoid restarting
++++	 * the syscall over and over again.
++++	 */
++++	
++++	tf->tf_epc += 4;
++++
++++	/* Make sure the syscall code didn't forget to lower spl */
++++	KASSERT(curthread->t_curspl == 0);
++++	/* ...or leak any spinlocks */
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++}
++++
++++/*
++++ * Enter user mode for a newly forked process.
++++ *
++++ * This function is provided as a reminder. You need to write
++++ * both it and the code that calls it.
++++ *
++++ * Thus, you can trash it and do things another way if you prefer.
++++ */
++++void
++++enter_forked_process(struct trapframe *tf)
++++{
++++	(void)tf;
++++}
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..7d5df71 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,9 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
++++file	  syscall/proc_sys.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/limits.h b/kern/include/limits.h
+++index 01684c4..3a54e24 100644
+++--- a/kern/include/limits.h
++++++ b/kern/include/limits.h
+++@@ -48,5 +48,6 @@
+++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+++ #define OPEN_MAX        __OPEN_MAX
+++ #define IOV_MAX         __IOV_MAX
++++//#define OPEN_MAX        64
+++ 
+++ #endif /* _LIMITS_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..df9fe64 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,11 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        //struct spinlock cv_lock;
++++        struct wchan *cv_wchan;
++++        //volatile int hold;
++++        //struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ 
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int res_count;
++++        struct wchan *rd_wchan;
++++        struct wchan *wr_wchan;
++++        struct semaphore *rw_sem;
++++        struct lock *rw_lock;
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+++new file mode 100644
+++index 0000000..d98aeb7
+++--- /dev/null
++++++ b/kern/include/synch.h~
+++@@ -0,0 +1,161 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _SYNCH_H_
++++#define _SYNCH_H_
++++
++++/*
++++ * Header file for synchronization primitives.
++++ */
++++
++++
++++#include <spinlock.h>
++++
++++/*
++++ * Dijkstra-style semaphore.
++++ *
++++ * The name field is for easier debugging. A copy of the name is made
++++ * internally.
++++ */
++++struct semaphore {
++++        char *sem_name;
++++	struct wchan *sem_wchan;
++++	struct spinlock sem_lock;
++++        volatile int sem_count;
++++};
++++
++++struct semaphore *sem_create(const char *name, int initial_count);
++++void sem_destroy(struct semaphore *);
++++
++++/*
++++ * Operations (both atomic):
++++ *     P (proberen): decrement count. If the count is 0, block until
++++ *                   the count is 1 again before decrementing.
++++ *     V (verhogen): increment count.
++++ */
++++void P(struct semaphore *);
++++void V(struct semaphore *);
++++
++++
++++/*
++++ * Simple lock for mutual exclusion.
++++ *
++++ * When the lock is created, no thread should be holding it. Likewise,
++++ * when the lock is destroyed, no thread should be holding it.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++struct lock {
++++        char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct lock *lock_create(const char *name);
++++void lock_acquire(struct lock *);
++++
++++/*
++++ * Operations:
++++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++++ *                   same time.
++++ *    lock_release - Free the lock. Only the thread holding the lock may do
++++ *                   this.
++++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++++ *                   false otherwise.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void lock_release(struct lock *);
++++bool lock_do_i_hold(struct lock *);
++++void lock_destroy(struct lock *);
++++
++++
++++/*
++++ * Condition variable.
++++ *
++++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++++ * to wait until a variable meets a particular condition, but there's no
++++ * actual variable, as such, in the CV.
++++ *
++++ * These CVs are expected to support Mesa semantics, that is, no
++++ * guarantees are made about scheduling.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++
++++struct cv {
++++        char *cv_name;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct cv *cv_create(const char *name);
++++void cv_destroy(struct cv *);
++++
++++/*
++++ * Operations:
++++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++++ *                   waking up again, re-acquire the lock.
++++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++++ *
++++ * For all three operations, the current thread must hold the lock passed 
++++ * in. Note that under normal circumstances the same lock should be used
++++ * on all operations with any particular CV.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void cv_wait(struct cv *cv, struct lock *lock);
++++void cv_signal(struct cv *cv, struct lock *lock);
++++void cv_broadcast(struct cv *cv, struct lock *lock);
++++
++++/*
++++ * 13 Feb 2012 : GWA : Reader-writer locks.
++++ */
++++
++++struct rwlock {
++++        char *rwlock_name;
++++};
++++
++++struct rwlock * rwlock_create(const char *);
++++void rwlock_destroy(struct rwlock *);
++++
++++void rwlock_acquire_read(struct rwlock *);
++++void rwlock_release_read(struct rwlock *);
++++void rwlock_acquire_write(struct rwlock *);
++++void rwlock_release_write(struct rwlock *);
++++
++++#endif /* _SYNCH_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..ea96700 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -26,6 +26,7 @@
+++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++  * SUCH DAMAGE.
+++  */
++++#include<thread.h>
+++ 
+++ #ifndef _SYSCALL_H_
+++ #define _SYSCALL_H_
+++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+++  * Support functions.
+++  */
+++ 
++++
+++ /* Helper for fork(). You write this. */
+++-void enter_forked_process(struct trapframe *tf);
++++void enter_forked_process(void *tf,unsigned long adrspace);
+++ 
+++ /* Enter user mode. Does not return. */
+++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++++int sys_execv(char* progname,char** arguments);
++++int sys_getpid(pid_t *retval);
++++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++++void sys_exit(int exitcode);
++++int mywait(struct process* mypro);
+++ 
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/test.h b/kern/include/test.h
+++index 240d583..84f60fc 100644
+++--- a/kern/include/test.h
++++++ b/kern/include/test.h
+++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+++ int nettest(int, char **);
+++ 
+++ /* Routine for running a user-level program. */
+++-int runprogram(char *progname);
++++int runprogram(char *progname,char** argv,unsigned long argc);
+++ 
+++ /* Kernel menu system. */
+++ void menu(char *argstr);
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..77a3515 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -73,7 +73,10 @@ struct thread {
+++ 	 */
+++ 	char *t_name;			/* Name of this thread */
+++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+++-	threadstate_t t_state;		/* State this thread is in */
++++	threadstate_t t_state;
++++	/* State this thread is in */
++++
++++	pid_t pid;
+++ 
+++ 	/*
+++ 	 * Thread subsystem internal fields.
+++@@ -104,7 +107,7 @@ struct thread {
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++-
++++	struct process* proc;
+++ 	/* VM */
+++ 	struct addrspace *t_addrspace;	/* virtual address space */
+++ 
+++@@ -112,6 +115,19 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
++++};
++++
++++struct process {
++++	int full;
++++	pid_t pid;
++++    pid_t ppid;
++++    //struct semaphore* exitsem;
++++    struct lock* tlock;
++++    struct cv* wcv;
++++    bool exited;
++++    int exitcode;
++++    struct thread* self;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..4d8e7e2 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -100,7 +100,7 @@ boot(void)
+++ 	kprintf("%s", harvard_copyright);
+++ 	kprintf("\n");
+++ 
+++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++ 		GROUP_VERSION, buildconfig, buildversion);
+++ 	kprintf("\n");
+++ 
+++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+++new file mode 100644
+++index 0000000..4d8e7e2
+++--- /dev/null
++++++ b/kern/startup/main.c~
+++@@ -0,0 +1,211 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Main.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/reboot.h>
++++#include <kern/unistd.h>
++++#include <lib.h>
++++#include <spl.h>
++++#include <clock.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++#include <vm.h>
++++#include <mainbus.h>
++++#include <vfs.h>
++++#include <device.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <version.h>
++++#include "autoconf.h"  // for pseudoconfig
++++
++++
++++/*
++++ * These two pieces of data are maintained by the makefiles and build system.
++++ * buildconfig is the name of the config file the kernel was configured with.
++++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++++ *
++++ * The purpose is not to show off how many kernels you've linked, but
++++ * to make it easy to make sure that the kernel you just booted is the
++++ * same one you just built.
++++ */
++++extern const int buildversion;
++++extern const char buildconfig[];
++++
++++/*
++++ * Copyright message for the OS/161 base code.
++++ */
++++static const char harvard_copyright[] =
++++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++++
++++
++++/*
++++ * Initial boot sequence.
++++ */
++++static
++++void
++++boot(void)
++++{
++++	/*
++++	 * The order of these is important!
++++	 * Don't go changing it without thinking about the consequences.
++++	 *
++++	 * Among other things, be aware that console output gets
++++	 * buffered up at first and does not actually appear until
++++	 * mainbus_bootstrap() attaches the console device. This can
++++	 * be remarkably confusing if a bug occurs at this point. So
++++	 * don't put new code before mainbus_bootstrap if you don't
++++	 * absolutely have to.
++++	 *
++++	 * Also note that the buffer for this is only 1k. If you
++++	 * overflow it, the system will crash without printing
++++	 * anything at all. You can make it larger though (it's in
++++	 * dev/generic/console.c).
++++	 */
++++
++++	kprintf("\n");
++++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++++	kprintf("%s", harvard_copyright);
++++	kprintf("\n");
++++
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++++		GROUP_VERSION, buildconfig, buildversion);
++++	kprintf("\n");
++++
++++	/* Early initialization. */
++++	ram_bootstrap();
++++	thread_bootstrap();
++++	hardclock_bootstrap();
++++	vfs_bootstrap();
++++
++++	/* Probe and initialize devices. Interrupts should come on. */
++++	kprintf("Device probe...\n");
++++	KASSERT(curthread->t_curspl > 0);
++++	mainbus_bootstrap();
++++	KASSERT(curthread->t_curspl == 0);
++++	/* Now do pseudo-devices. */
++++	pseudoconfig();
++++	kprintf("\n");
++++
++++	/* Late phase of initialization. */
++++	vm_bootstrap();
++++	kprintf_bootstrap();
++++	thread_start_cpus();
++++
++++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++++	vfs_setbootfs("emu0");
++++
++++
++++	/*
++++	 * Make sure various things aren't screwed up.
++++	 */
++++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++++}
++++
++++/*
++++ * Shutdown sequence. Opposite to boot().
++++ */
++++static
++++void
++++shutdown(void)
++++{
++++
++++	kprintf("Shutting down.\n");
++++	
++++	vfs_clearbootfs();
++++	vfs_clearcurdir();
++++	vfs_unmountall();
++++
++++	thread_shutdown();
++++
++++	splhigh();
++++}
++++
++++/*****************************************/
++++
++++/*
++++ * reboot() system call.
++++ *
++++ * Note: this is here because it's directly related to the code above,
++++ * not because this is where system call code should go. Other syscall
++++ * code should probably live in the "syscall" directory.
++++ */
++++int
++++sys_reboot(int code)
++++{
++++	switch (code) {
++++	    case RB_REBOOT:
++++	    case RB_HALT:
++++	    case RB_POWEROFF:
++++		break;
++++	    default:
++++		return EINVAL;
++++	}
++++
++++	shutdown();
++++
++++	switch (code) {
++++	    case RB_HALT:
++++		kprintf("The system is halted.\n");
++++		mainbus_halt();
++++		break;
++++	    case RB_REBOOT:
++++		kprintf("Rebooting...\n");
++++		mainbus_reboot();
++++		break;
++++	    case RB_POWEROFF:
++++		kprintf("The system is halted.\n");
++++		mainbus_poweroff();
++++		break;
++++	}
++++
++++	panic("reboot operation failed\n");
++++	return 0;
++++}
++++
++++/*
++++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++++ * request, and then shut down.
++++ */
++++void
++++kmain(char *arguments)
++++{
++++	boot();
++++
++++	menu(arguments);
++++
++++	/* Should not get here */
++++}
+++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+++index 6c71551..a4c2750 100644
+++--- a/kern/startup/menu.c
++++++ b/kern/startup/menu.c
+++@@ -40,9 +40,13 @@
+++ #include <sfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include<thread.h>
++++#include<synch.h>
+++ #include "opt-synchprobs.h"
+++ #include "opt-sfs.h"
+++ #include "opt-net.h"
++++#include <copyinout.h>
++++//#include "proc_sys.c"
+++ 
+++ /*
+++  * In-kernel menu and command dispatcher.
+++@@ -51,6 +55,7 @@
+++ #define _PATH_SHELL "/bin/sh"
+++ 
+++ #define MAXMENUARGS  16
++++extern struct process* p_table[17];
+++ 
+++ // XXX this should not be in this file
+++ void
+++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+++ 
+++ 	strcpy(progname, args[0]);
+++ 
+++-	result = runprogram(progname);
++++	result = runprogram(progname,args,nargs);
+++ 	if (result) {
+++ 		kprintf("Running program %s failed: %s\n", args[0],
+++ 			strerror(result));
+++@@ -127,6 +132,8 @@ int
+++ common_prog(int nargs, char **args)
+++ {
+++ 	int result;
++++	struct thread* fthread;
++++	//int err;
+++ 
+++ #if OPT_SYNCHPROBS
+++ 	kprintf("Warning: this probably won't work with a "
+++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+++ 	result = thread_fork(args[0] /* thread name */,
+++ 			cmd_progthread /* thread function */,
+++ 			args /* thread arg */, nargs /* thread arg */,
+++-			NULL);
++++			&fthread);
++++	//fthread->
++++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++++
++++	fthread->pid=PID_MIN;
++++	fthread->proc->pid=PID_MIN;
++++
++++	fthread->proc->self=fthread;
++++	fthread->proc->wcv=cv_create("First CV");
++++	fthread->proc->tlock=lock_create("First Lock");
++++	p_table[0]=fthread->proc;
++++
++++	lock_acquire(p_table[0]->tlock);
++++	mywait(p_table[0]);
++++	lock_release(p_table[0]->tlock);
++++
++++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++
++++	//fthread->proc->
++++	//while(!p_table[0]->exited)
++++
++++
+++ 	if (result) {
+++ 		kprintf("thread_fork failed: %s\n", strerror(result));
+++ 		return result;
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..6c0bb3f 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -43,11 +43,25 @@
+++  * You should implement your solution to the whalemating problem below.
+++  */
+++ 
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++-// the top of the corresponding driver code.
++++// the top of the corresponding driver code
++++
++++struct semaphore *male_sem;
++++struct semaphore *female_sem;
++++struct lock *hold;
++++struct cv* mate_cv;
++++volatile int male_count;
++++volatile int female_count;
+++ 
+++ void whalemating_init() {
++++ hold=lock_create("My lock");
++++ male_sem=sem_create("Male Semaphore",0);
++++ female_sem=sem_create("Female Semaphore",0);
++++mate_cv=cv_create("mating cv");
++++male_count=0;
++++female_count=0;
+++   return;
+++ }
+++ 
+++@@ -55,6 +69,11 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++
++++	sem_destroy(male_sem);
++++	sem_destroy(female_sem);
++++	lock_destroy(hold);
++++	cv_destroy(mate_cv);
+++   return;
+++ }
+++ 
+++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+++   (void)which;
+++   
+++   male_start();
++++
++++  lock_acquire(hold);
++++
++++  V(male_sem);
++++  male_count++;
++++  if(female_count!=0)
++++  cv_signal(mate_cv,hold);
++++  else
++++	  cv_wait(mate_cv,hold);
++++  lock_release(hold);
++++
+++ 	// Implement this function 
+++   male_end();
+++ 
+++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
++++  lock_acquire(hold);
++++   V(female_sem);
++++   female_count++;
++++   if(male_count!=0)
++++   cv_signal(mate_cv,hold);
++++   else
++++	   cv_wait(mate_cv,hold);
++++  lock_release(hold);
+++ 	// Implement this function 
+++   female_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
++++  lock_acquire(hold);
++++ P(male_sem);
++++ male_count--;
++++ lock_release(hold);
++++ lock_acquire(hold);
++++  P(female_sem);
++++  female_count--;
++++  lock_release(hold);
+++ 	// Implement this function 
+++   matchmaker_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
++++
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
++++struct lock* intersect_lock;
++++struct cv* intersect_cv;
++++volatile int cur_poss[4];// an array to store the possible positions of the car
++++//currently
+++ 
+++ void stoplight_init() {
++++	intersect_cv=cv_create("Intersection Condition Variable");
++++	if(intersect_cv==NULL)
++++	{
++++		///return NULL;
++++		panic("condition variable not created");
++++	}
++++	intersect_lock=lock_create("A lock on the intersection");
++++	if(intersect_lock==NULL)
++++	{
++++		//return NULL;
++++		panic("Lock could not be created");
++++	}
++++	
++++	
+++   return;
+++ }
+++ 
+++@@ -145,6 +210,8 @@ void stoplight_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
++++	cv_destroy(intersect_cv);
++++	lock_destroy(intersect_lock);
+++   return;
+++ }
+++ 
+++@@ -152,8 +219,29 @@ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++  //(void)direction;
++++	int sec_quad=(direction+3)%4;
++++	lock_acquire(intersect_lock);
++++	// So while any of the two possible quadrants are already set, It means some 
++++	//thread is waiting...Hopefully
++++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++++		cv_wait(intersect_cv,intersect_lock);
++++	cur_poss[direction]=1;
++++	cur_poss[sec_quad]=1;
++++	inQuadrant(direction);
++++	lock_release(intersect_lock);
++++	lock_acquire(intersect_lock);
++++    cur_poss[direction]=0;
++++    //while(curr_p)
++++    //cv_broadcast(intersect_cv);
++++    inQuadrant(sec_quad);
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++    cur_poss[sec_quad]=0;
++++    leaveIntersection();
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
++++  int sec_quad=(direction+3)%4;
++++  int third_quad=(direction+2)%4;
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  cur_poss[sec_quad]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++  lock_acquire(intersect_lock);
++++  cur_poss[direction]=0;
+++   
++++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++++  //cv_wait(intersect_cv,intersect_lock);
++++      cur_poss[third_quad]=1;
++++      //while(curr_p)
++++      //cv_broadcast(intersect_cv);
++++      inQuadrant(sec_quad);
++++      cv_broadcast(intersect_cv,intersect_lock);
++++      lock_release(intersect_lock);
++++        lock_acquire(intersect_lock);
++++            //currposs[direction]=0;
++++            cur_poss[sec_quad]=0;
++++            //while(curr_p)
++++            //cv_broadcast(intersect_cv);
++++            inQuadrant(third_quad);
++++            cv_broadcast(intersect_cv,intersect_lock);
++++                //cur_poss[third_quad]=0;
++++            lock_release(intersect_lock);
++++              lock_acquire(intersect_lock);
++++                leaveIntersection();
++++                cur_poss[third_quad]=0;
++++                cv_broadcast(intersect_cv,intersect_lock);
++++                lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
+++-
++++  // Easy coz the vehicle is in same lane!!
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++  leaveIntersection();
++++  cur_poss[direction]=0;
++++  cv_broadcast(intersect_cv,intersect_lock);
++++  lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+++new file mode 100644
+++index 0000000..c8d768b
+++--- /dev/null
++++++ b/kern/syscall/proc_sys.c
+++@@ -0,0 +1,741 @@
++++/*
++++
++++ * proc_sys.c
++++ *
++++ *  Created on: Mar 7, 2014
++++ *      Author: trinity
++++ */
++++
++++#include <types.h>
++++#include<mips/trapframe.h>
++++#include <kern/errno.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <addrspace.h>
++++#include <vm.h>
++++#include <vfs.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <file.h>
++++#include <synch.h>
++++#include<copyinout.h>
++++#include <spl.h>
++++#include<kern/wait.h>
++++
++++extern struct process* p_table[17];
++++
++++//struct cv* wcv;
++++
++++extern pid_t pidcount;
++++int mywait(struct process* mypro)
++++{
++++	//lock_acquire(mypro->tlock);
++++	while(!mypro->exited)
++++	{
++++		cv_wait(mypro->wcv,mypro->tlock);
++++	}
++++	//*status=mypro->exitcode;
++++	//lock_release(mypro->tlock);
++++	//int test = mypro->exitcode;
++++	//test++;
++++	return 0;
++++}
++++
++++
++++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
++++{
++++	(void)adrs;
++++	int flag;
++++	pid_t childid;
++++	struct addrspace *adrcopy;
++++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
++++	bzero(copyt,sizeof(struct trapframe));
++++
++++	//struct filetable* copyft;
++++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++++
++++	memcpy(copyt,tf,sizeof(struct trapframe));
++++	flag=as_copy(curthread->t_addrspace,&adrcopy);
++++	//if(curthread->pid==0)
++++	//{
++++		//curthread->pid=PID_MIN;
++++	//}
++++    if(flag)
++++    {
++++    	kfree(copyt);
++++    	return flag;
++++    }
++++
++++    //we need to allocate pid for our new process
++++
++++    //pid_t cpid;
++++    for(childid=0;childid<=16;childid++)
++++    {
++++     if(p_table[childid]==NULL)
++++     {
++++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
++++    	p_table[childid]->full=1;
++++    	pidcount++;
++++    	p_table[childid]->pid=pidcount;
++++    	p_table[childid]->ppid=curthread->pid;
++++    	//p_table[childid]->exitsem=sem_create("process",0);
++++    	p_table[childid]->tlock=lock_create("My Lock");
++++    	p_table[childid]->wcv=cv_create("My CV");
++++    	p_table[childid]->self=NULL;
++++    	break;
++++     }
++++    }
++++    if(childid>PID_MAX)
++++    {
++++    	*retval=1;
++++    	return EMPROC;
++++    }
++++    //int i;
++++
++++    copyt->tf_a0=(int)p_table[childid]->pid;
++++    //kprintf("Ret:%d\n",copyt->tf_a0);
++++    struct thread *new_proc;
++++    //curthread->t_addrspace=(struct addrspace*)adrcopy;
++++    //int s=splhigh();
++++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
++++    //kprintf("Out of thread fork:%d\n",flag);
++++    if(flag)
++++    {
++++    	kfree(copyt);
++++    	as_destroy(adrcopy);
++++
++++    	return flag;
++++    }
++++
++++    //new_proc->pid=(pid_t)childid;
++++    //new_proc=p_table[childid];
++++
++++    new_proc->pid=p_table[childid]->pid;
++++    new_proc->proc=p_table[childid];
++++   // new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++++    //if (new_proc->t_filetable == NULL) {
++++    //return ENOMEM;
++++    //}
++++    p_table[childid]->self=new_proc;
++++
++++    //new_proc->pid=p_table[childid]->pid;
++++    //new_proc->proc->pid=p_table[childid]->pid;
++++    //kprintf("Child id in fork: %d\n",new_proc->pid);
++++
++++
++++   //kprintf("Child id:%d",new_proc->pid);
++++    //new_proc->t_filetable->
++++    //for(i=0;i<128;i++)
++++    //{
++++    flag=filetable_copy(&new_proc->t_filetable);
++++    //}
++++    //splx(s);
++++   // kprintf("Fork over!");
++++
++++    *retval=p_table[childid]->pid;
++++    //kprintf("Return val in fork:%d",*retval);
++++    return 0;
++++
++++    //flag=
++++     //flag=thread_fork=
++++}
++++
++++/*
++++
++++int sys_execv(char* progname,char** arguments,int *retval)
++++{
++++	int flag;
++++	int numargs;
++++	int addr;
++++	int i;
++++	// first we need to copy the program name to the kernel space
++++	// then we go for arguments. Path size unknown
++++
++++	size_t actual_size=0;
++++	char *namedes;
++++
++++
++++	if(progname==NULL)
++++	{
++++		return EFAULT;
++++	}
++++	if(progname=="")
++++	{
++++		return EINVAL;
++++	}
++++
++++
++++	namedes=(char*)kmalloc(PATH_MAX);
++++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
++++	if(flag!=0)
++++	{
++++		kfree(namedes);
++++		return flag;
++++	}
++++	//namedes[actual_size]
++++	if(strlen(namedes)==0)
++++	{
++++		*retval=1;
++++		return EISDIR;
++++	}
++++
++++
++++	// now we open file using vfs_open. Same as runprogram
++++	struct vnode* vn;
++++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
++++	if(flag)
++++	{
++++		return flag;
++++	}
++++	actual_size=0;
++++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++++
++++	//char** kargv=(char**)kmalloc(sizeof(char));
++++	// get the number of arguments
++++	if(arguments==NULL)
++++	{
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++	flag=copyin((userptr_t)arguments,&addr,sizeof(int));
++++	if(flag)
++++	{
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++
++++	//check=wthread->exitcode;
++++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++++	//if(err)
++++	//{
++++	//	lock_release(p_table[i]->tlock);
++++		//return err;
++++	//}
++++
++++	numargs=0;
++++	while(arguments[numargs]!=NULL)
++++	{
++++		//kprintf("%");
++++		numargs=numargs+1;
++++	}
++++
++++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
++++	int i;
++++	for(i=0;i<numargs;i++)
++++	{
++++		actual_size=0;
++++		kargv[i]=(char*)kmalloc(PATH_MAX);
++++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
++++		if(flag)
++++		{
++++			kfree(kargv);
++++			kfree(namedes);
++++			return EFAULT;
++++		}
++++
++++	}
++++	actual_size=0;
++++
++++
++++	// same as runprogram
++++
++++	curthread->t_addrspace=as_create();
++++	if(curthread->t_addrspace==NULL)
++++	{
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	vaddr_t entrypoint, stackptr;
++++	as_activate(curthread->t_addrspace);
++++	flag = load_elf(vn, &entrypoint);
++++		if (flag) {
++++			// thread_exit destroys curthread->t_addrspace
++++			vfs_close(vn);
++++			return flag;
++++		}
++++
++++	vfs_close(vn);
++++
++++// now set up the user stack with the arguments
++++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++++		if (flag) {
++++			 //thread_exit destroys curthread->t_addrspace
++++			return flag;
++++		}
++++		//i=0;
++++
++++		for(i=numargs-1;i>=0;i--)
++++		{
++++			actual_size=0;
++++			int length=strlen(kargv[i])+1;
++++			//int length=strlen(kargv[i]);
++++			int padder=length%4;
++++			if(padder!=0)
++++			length=length+padder;
++++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
++++			//stackptr=stackptr+length;
++++			stackptr=stackptr-length;
++++
++++
++++		}
++++		for(i = numargs; i >= 0; i--)
++++		{
++++		stackptr -= sizeof(vaddr_t);
++++		flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++		if(result)
++++		{
++++		for(j = 0; j < argc; j++)
++++		{
++++		kfree(kargv[j]);
++++		}
++++		kfree(kargv);
++++		kfree(filename);
++++		return result;
++++		}
++++		}
++++
++++		vaddr_t stackptrv[argc+1];
++++		for(i = argc-1; i >= 0; i--)
++++		{
++++		int len = strlen(kargv[i]);
++++		len++;
++++		int padding = len % 4;
++++		stackptr -= len + (4 - padding);
++++		result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
++++		if(result)
++++		{
++++		for(j = 0; j < argc; j++)
++++		{
++++		kfree(kargv[j]);
++++		}
++++		kfree(kargv);
++++		kfree(namedes);
++++		return flag;
++++		}
++++		stackptrv[i] = stackptr;
++++		}
++++		stackptrv[numargs] = 0;
++++		enter_new_process(numargs,(userptr_t)stackptr,
++++					  stackptr, entrypoint);
++++		//pt_getthread();
++++
++++
++++			//enter_new_process does not return.
++++			panic("enter_new_process returned\n");
++++			return EINVAL;
++++}
++++*/
++++
++++
++++
++++
++++
++++int
++++sys_execv(char *progname, char **argv)
++++{
++++struct vnode *v;
++++vaddr_t entrypoint, stackptr;
++++char **kargv;
++++int result;
++++int i;
++++int j;
++++int testAddress;
++++int argc = 0;
++++size_t actual;
++++
++++if(progname == NULL)
++++{
++++return EFAULT;
++++}
++++
++++char *filename = (char *)kmalloc(PATH_MAX);
++++result = copyinstr((const_userptr_t)progname, filename, (size_t)NAME_MAX, &actual);
++++if(result)
++++{
++++kfree(filename);
++++return result;
++++}
++++if(strlen(filename) == 0)
++++{
++++return EINVAL;
++++}
++++
++++if(argv != NULL)
++++{
++++/* test to see that argv is a valid address */
++++result = copyin((const_userptr_t)argv, &testAddress, sizeof(int));
++++if(result)
++++{
++++kfree(filename);
++++return result;
++++}
++++
++++/* Get argc */
++++while(argv[argc] != NULL)
++++{
++++argc++;
++++}
++++/* Create kargv and safely copy in string arguments. */
++++kargv = (char **)kmalloc(sizeof(char *) * argc);
++++for(i = 0; i < argc; i++)
++++{
++++kargv[i] = (char *)kmalloc(PATH_MAX);
++++result = copyinstr((const_userptr_t)argv[i], kargv[i], PATH_MAX, &actual);
++++if(result)
++++{
++++/* In here I'm just freeing the char *
++++* that I've already kmalloc'ed. Not sure
++++* if this is correct
++++*/
++++for(j = 0; j < i; j++)
++++{
++++kfree(kargv[j]);
++++}
++++kfree(kargv[i]);
++++kfree(kargv);
++++kfree(filename);
++++return result;
++++}
++++}
++++}
++++/* open the file with filename */
++++result = vfs_open(filename, O_RDONLY,0,&v);
++++if(result)
++++{
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++/* Destroy current address space */
++++if(curthread->t_addrspace)
++++{
++++as_destroy(curthread->t_addrspace);
++++curthread->t_addrspace = NULL;
++++}
++++
++++KASSERT(curthread->t_addrspace == NULL);
++++
++++/* Create new address space */
++++curthread->t_addrspace = as_create();
++++if(curthread->t_addrspace == NULL)
++++{
++++vfs_close(v);
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++
++++/* Activate the address space */
++++as_activate(curthread->t_addrspace);
++++
++++/* Load the executable. */
++++result = load_elf(v, &entrypoint);
++++if (result)
++++{
++++vfs_close(v);
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++/* Done with the file now. */
++++vfs_close(v);
++++
++++/* Define the user stack in the address space */
++++result = as_define_stack(curthread->t_addrspace, &stackptr);
++++if (result) {
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++
++++//if(argv != NULL)
++++//{
++++/* This hopefully safely copies from kargv into
++++* the user stack
++++*/
++++vaddr_t stackptrv[argc+1];
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(kargv[i]);
++++len++;
++++int padding = len % 4;
++++stackptr -= len + (4 - padding);
++++result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++for(j = 0; j < argc; j++)
++++{
++++kfree(kargv[j]);
++++}
++++kfree(kargv);
++++kfree(filename);
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++
++++/* This copies the actual stack addresses of the arguments
++++* into the stack. Hopefully.
++++*/
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++for(j = 0; j < argc; j++)
++++{
++++kfree(kargv[j]);
++++}
++++kfree(kargv);
++++kfree(filename);
++++return result;
++++}
++++//}
++++
++++/* Free everything we have kmalloc'ed */
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++
++++/* Warp to user mode */
++++//md_usermode(argc, (userptr_t)stackptr, stackptr, entrypoint);
++++enter_new_process(argc,(userptr_t)stackptr,
++++					  stackptr, entrypoint);
++++		//pt_getthread();
++++
++++/* md_usermode does not return */
++++panic("md_usermode returned\n");
++++return EINVAL;
++++}
++++
++++
++++
++++int sys_getpid(pid_t *retval)
++++{
++++	//kprintf("In get pid:%d\n",curthread->pid);
++++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++++
++++	*retval=curthread->proc->pid;
++++	return 0;
++++}
++++
++++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
++++{
++++	struct process* wthread=NULL;
++++	int check;
++++	int err;
++++	pid_t i;
++++	//kprintf("PID in wait pid:%d\n",pid);
++++	if(status==NULL)
++++		return EFAULT;
++++	if(options!=0)
++++		return EINVAL;
++++	if (pid==curthread->pid)
++++		return ECHILD;
++++	if (pid<PID_MIN||pid>PID_MAX)
++++		return ESRCH;
++++	if (status==NULL)
++++		return EFAULT;
++++	if(pid==curthread->proc->ppid)
++++		return ECHILD;
++++	//int *shit;
++++	//*shit=(int)&status;
++++	//kprintf("%d\n",*shit);
++++	//if(curthread->)
++++	//if(pid!=curthread->)
++++	//char* argv=(char*)(status);
++++	//int length=strlen(argv)+1;
++++				//int length=strlen(kargv[i])+1;
++++	//int padder=length%4;
++++	//kprintf("Hai:%d\n",padder);
++++	//if(padder!=0)
++++	//{
++++		//return EFAULT;
++++	//}
++++
++++
++++	//if()
++++
++++
++++	//char pathbuf[PATH_MAX];
++++	//int *buffer;
++++	//int result;
++++
++++		//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++++		//if (result) {
++++			//return result;
++++		//}
++++		//int addr=(int)&status;
++++		//kprintf("Status:%d\n",addr);
++++	//int *addr=&status;
++++	//if(addr%4!=0)
++++	//{
++++		//return EFAULT;
++++	//}
++++	//kprintf("Got Here\n");
++++	for(i=0;i<=16;i++)
++++	{
++++		if(p_table[i]!=NULL)
++++		{
++++		if(p_table[i]->pid==pid)
++++		{
++++			wthread=p_table[i];
++++			break;
++++		}
++++		}
++++	}
++++	if(wthread==NULL)
++++	{
++++		return ESRCH;
++++	}
++++	if(curthread->proc->pid!=wthread->ppid)
++++	return ECHILD;
++++	//panic("We are here");
++++
++++	lock_acquire(p_table[i]->tlock);
++++
++++	//while(!wthread->exited)
++++	//{
++++//
++++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++++	//}
++++	mywait(wthread);
++++
++++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++++	//kprintf("We are here!");
++++
++++	check=wthread->exitcode;
++++	err=copyout(&check,(userptr_t)status,sizeof(check));
++++	if(err)
++++	{
++++		lock_release(p_table[i]->tlock);
++++		return err;
++++	}
++++	//kprintf("Exit code After waiting:%d\n",*status);
++++	//kfree(p_table[i]->exitsem);
++++	//p_table[i]=NULL;
++++
++++	//panic("After kfree");
++++	//p_table[i]=NULL;
++++	lock_release(p_table[i]->tlock);
++++	//filetable_destroy(p_table[i]->self->t_filetable);
++++	//lock_destroy(p_table[i]->tlock);
++++	//cv_destroy(p_table[i]->wcv);
++++	//kfree(p_table[i]);
++++	p_table[i]=NULL;
++++
++++	*retval=pid;
++++	//panic("After dereferencing");
++++	return 0;
++++
++++
++++	//return -1;
++++	//return 0;
++++}
++++
++++void sys_exit(int exitcode)
++++{
++++pid_t pid=curthread->proc->pid;
++++pid_t i=PID_MIN;
++++struct process* ethread;
++++//pid_t parent;
++++//if(pid!=2)
++++//{
++++for(i=0;i<=16;i++)
++++{
++++	if(p_table[i]!=NULL)
++++	{
++++	if(p_table[i]->pid==pid)
++++	{
++++			ethread=p_table[i];
++++			break;
++++	}
++++	}
++++}
++++
++++//parent=ethread->ppid;
++++if(ethread!=NULL)
++++{
++++lock_acquire(ethread->tlock);
++++//kprintf("Exit code Before:%d\n",exitcode);
++++
++++ethread->exitcode=_MKWAIT_EXIT(exitcode);
++++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++++ethread->exited=1;
++++//p_table[i]=ethread;
++++cv_broadcast(ethread->wcv,ethread->tlock);
++++//kfree(curthread->t_filetable);
++++lock_release(ethread->tlock);
++++}
++++//}
++++i=0;
++++//
++++//kprintf("Before hanging");
++++//filetable_destroy(curthread->t_filetable);
++++//kfree(curthread->p);
++++
++++thread_exit();
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..ab0197b 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,8 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
++++#include<copyinout.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -52,7 +54,7 @@
+++  * Calls vfs_open on progname and thus may destroy it.
+++  */
+++ int
+++-runprogram(char *progname)
++++runprogram(char *progname,char**argv,unsigned long argc)
+++ {
+++ 	struct vnode *v;
+++ 	vaddr_t entrypoint, stackptr;
+++@@ -66,6 +68,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	curthread->t_filetable=NULL;
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++@@ -94,9 +103,39 @@ runprogram(char *progname)
+++ 		/* thread_exit destroys curthread->t_addrspace */
+++ 		return result;
+++ 	}
++++	vaddr_t stackptrv[argc+1];
++++int i;
++++size_t actual;
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(argv[i]);
++++len++;
++++int padding = len % 4;
++++stackptr -= len + (4 - padding);
++++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++return result;
++++}
++++}
++++
++++
++++
+++ 
+++ 	/* Warp to user mode. */
+++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++++	enter_new_process(argc, (userptr_t)stackptr,
+++ 			  stackptr, entrypoint);
+++ 	
+++ 	/* enter_new_process does not return. */
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..851f9ea 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -40,6 +40,8 @@
+++ #include <current.h>
+++ #include <synch.h>
+++ 
++++#define MAXREADERS 20;
++++
+++ ////////////////////////////////////////////////////////////
+++ //
+++ // Semaphore.
+++@@ -162,9 +164,17 @@ lock_create(const char *name)
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
+++-        // add stuff here as needed
+++-        
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
+++         return lock;
+++ }
+++ 
+++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+++ 
+++         // add stuff here as needed
+++         
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
+++         kfree(lock->lk_name);
+++         kfree(lock);
+++ }
+++@@ -183,26 +195,78 @@ void
+++ lock_acquire(struct lock *lock)
+++ {
+++         // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(&lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -225,7 +289,18 @@ cv_create(const char *name)
+++                 kfree(cv);
+++                 return NULL;
+++         }
+++-        
++++        cv->cv_wchan = wchan_create(cv->cv_name);
++++                	if (cv->cv_wchan == NULL) {
++++                		kfree(cv->cv_name);
++++                		kfree(cv);
++++                		return NULL;
++++                	}
++++
++++                	//spinlock_init(&cv->cv_lock);
++++                        //lock->hold = 0;
++++        		//lock->holder=NULL;
++++                //lock->=NULL
++++                return cv;
+++         // add stuff here as needed
+++         
+++         return cv;
+++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+++ 
+++         // add stuff here as needed
+++         
++++        //spinlock_cleanup(&cv->cv_lock);
++++        
++++        wchan_destroy(cv->cv_wchan);
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++ }
+++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	//KASSERT(lock_do_i_hold(lock));
++++	wchan_lock(cv->cv_wchan);
++++	lock_release(lock);
++++	
++++	wchan_sleep(cv->cv_wchan);
++++	lock_acquire(lock);
++++	
++++    // Write this
++++    //(void)cv;    // suppress warning until code gets written
++++    //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++         // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeone(cv->cv_wchan);
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeall(cv->cv_wchan);
++++		
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
++++}
++++
++++struct rwlock *rwlock_create(const char *name)
++++{
++++	struct rwlock *rw;
++++	rw=kmalloc(sizeof(struct rwlock));
++++	if(rw==NULL)
++++	{
++++		return NULL;
++++	}
++++	rw->rwlock_name=kstrdup(name);
++++	if(rw->rwlock_name==NULL)
++++	{
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++++	if(rw->rd_wchan==NULL)
++++	{
++++		kfree(rw->rwlock_name);
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++++		if(rw->wr_wchan==NULL)
++++		{
++++			kfree(rw->rwlock_name);
++++			kfree(rw);
++++			return NULL;
++++		}
++++		rw->rw_sem=sem_create("mysem",20);
++++		rw->rw_lock=lock_create("mylock");
++++	///rw->res_count=MAXREADERS;
++++	return rw;
++++	
++++}
++++void rwlock_destroy(struct rwlock *rw)
++++{
++++		KASSERT(rw != NULL);
++++		
++++		wchan_destroy(rw->rd_wchan);
++++		wchan_destroy(rw->wr_wchan);
++++		sem_destroy(rw->rw_sem);
++++		lock_destroy(rw->rw_lock);
++++	    kfree(rw->rwlock_name);
++++        kfree(rw);	
++++}
++++
++++void rwlock_acquire_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	P(rw->rw_sem);
++++	lock_release(rw->rw_lock);
++++}
++++void rwlock_release_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	V(rw->rw_sem);
++++	//lock_release(rw->rw_lock);
++++}
++++void rwlock_acquire_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	//rwlock->rw_sem->V();
++++	for(i=0;i<20;i++)
++++	{
++++	P(rw->rw_sem);
++++	}	
++++	lock_release(rw->rw_lock);
++++	
++++	
+++ }
++++void rwlock_release_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	for(i=0;i<20;i++)
++++	{
++++	V(rw->rw_sem);
++++	}	
++++	//lock_release(rw->rw_lock);
++++	
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+++new file mode 100644
+++index 0000000..b9680d1
+++--- /dev/null
++++++ b/kern/thread/synch.c~
+++@@ -0,0 +1,329 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Synchronization primitives.
++++ * The specifications of the functions are in synch.h.
++++ */
++++
++++#include <types.h>
++++#include <lib.h>
++++#include <spinlock.h>
++++#include <wchan.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Semaphore.
++++
++++struct semaphore *
++++sem_create(const char *name, int initial_count)
++++{
++++        struct semaphore *sem;
++++
++++        KASSERT(initial_count >= 0);
++++
++++        sem = kmalloc(sizeof(struct semaphore));
++++        if (sem == NULL) {
++++                return NULL;
++++        }
++++
++++        sem->sem_name = kstrdup(name);
++++        if (sem->sem_name == NULL) {
++++                kfree(sem);
++++                return NULL;
++++        }
++++
++++	sem->sem_wchan = wchan_create(sem->sem_name);
++++	if (sem->sem_wchan == NULL) {
++++		kfree(sem->sem_name);
++++		kfree(sem);
++++		return NULL;
++++	}
++++
++++	spinlock_init(&sem->sem_lock);
++++        sem->sem_count = initial_count;
++++
++++        return sem;
++++}
++++
++++void
++++sem_destroy(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	/* wchan_cleanup will assert if anyone's waiting on it */
++++	spinlock_cleanup(&sem->sem_lock);
++++	wchan_destroy(sem->sem_wchan);
++++        kfree(sem->sem_name);
++++        kfree(sem);
++++}
++++
++++void 
++++P(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++        /*
++++         * May not block in an interrupt handler.
++++         *
++++         * For robustness, always check, even if we can actually
++++         * complete the P without blocking.
++++         */
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++        while (sem->sem_count == 0) {
++++		/*
++++		 * Bridge to the wchan lock, so if someone else comes
++++		 * along in V right this instant the wakeup can't go
++++		 * through on the wchan until we've finished going to
++++		 * sleep. Note that wchan_sleep unlocks the wchan.
++++		 *
++++		 * Note that we don't maintain strict FIFO ordering of
++++		 * threads going through the semaphore; that is, we
++++		 * might "get" it on the first try even if other
++++		 * threads are waiting. Apparently according to some
++++		 * textbooks semaphores must for some reason have
++++		 * strict ordering. Too bad. :-)
++++		 *
++++		 * Exercise: how would you implement strict FIFO
++++		 * ordering?
++++		 */
++++		wchan_lock(sem->sem_wchan);
++++		spinlock_release(&sem->sem_lock);
++++                wchan_sleep(sem->sem_wchan);
++++
++++		spinlock_acquire(&sem->sem_lock);
++++        }
++++        KASSERT(sem->sem_count > 0);
++++        sem->sem_count--;
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++void
++++V(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++
++++        sem->sem_count++;
++++        KASSERT(sem->sem_count > 0);
++++	wchan_wakeone(sem->sem_wchan);
++++
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Lock.
++++
++++struct lock *
++++lock_create(const char *name)
++++{
++++        struct lock *lock;
++++
++++        lock = kmalloc(sizeof(struct lock));
++++        if (lock == NULL) {
++++                return NULL;
++++        }
++++
++++        lock->lk_name = kstrdup(name);
++++        if (lock->lk_name == NULL) {
++++                kfree(lock);
++++                return NULL;
++++        }
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
++++        return lock;
++++}
++++
++++void
++++lock_destroy(struct lock *lock)
++++{
++++        KASSERT(lock != NULL);
++++
++++        // add stuff here as needed
++++        
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
++++        kfree(lock->lk_name);
++++        kfree(lock);
++++}
++++
++++void
++++lock_acquire(struct lock *lock)
++++{
++++        // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
++++
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++lock_release(struct lock *lock)
++++{
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
++++        // Write this
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++bool
++++lock_do_i_hold(struct lock *lock)
++++{
++++        // Write this
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// CV
++++
++++
++++struct cv *
++++cv_create(const char *name)
++++{
++++        struct cv *cv;
++++
++++        cv = kmalloc(sizeof(struct cv));
++++        if (cv == NULL) {
++++                return NULL;
++++        }
++++
++++        cv->cv_name = kstrdup(name);
++++        if (cv->cv_name==NULL) {
++++                kfree(cv);
++++                return NULL;
++++        }
++++        
++++        // add stuff here as needed
++++        
++++        return cv;
++++}
++++
++++void
++++cv_destroy(struct cv *cv)
++++{
++++        KASSERT(cv != NULL);
++++
++++        // add stuff here as needed
++++        
++++        kfree(cv->cv_name);
++++        kfree(cv);
++++}
++++
++++void
++++cv_wait(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++        (void)cv;    // suppress warning until code gets written
++++        (void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_signal(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_broadcast(struct cv *cv, struct lock *lock)
++++{
++++	// Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..df129b9 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+++ 
+++ /* Used to wait for secondary CPUs to come online. */
+++ static struct semaphore *cpu_startup_sem;
++++pid_t pidcount;
++++struct process* p_table[17];
+++ 
+++ ////////////////////////////////////////////////////////////
+++ 
+++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -352,8 +357,15 @@ thread_bootstrap(void)
+++ {
+++ 	struct cpu *bootcpu;
+++ 	struct thread *bootthread;
++++	int i;
+++ 
+++ 	cpuarray_init(&allcpus);
++++	pidcount=PID_MIN;
++++
++++	for(i=0;i<=16;i++)
++++	{
++++		p_table[i]=NULL;
++++	}
+++ 
+++ 	/*
+++ 	 * Create the cpu structure for the bootup CPU, the one we're
+++@@ -365,6 +377,7 @@ thread_bootstrap(void)
+++ 	 */
+++ 	bootcpu = cpu_create(0);
+++ 	bootthread = bootcpu->c_curthread;
++++	//bootthread->pid=PID_MIN;
+++ 
+++ 	/*
+++ 	 * Initializing curcpu and curthread is machine-dependent
+++@@ -519,7 +532,7 @@ thread_fork(const char *name,
+++ 	 * for the spllower() that will be done releasing it.
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++-
++++	//newthread->pid=pidcount++;
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 	switch (newstate) {
+++ 	    case S_RUN:
+++ 		panic("Illegal S_RUN in thread_switch\n");
+++-		break;
+++ 	    case S_READY:
+++ 		thread_make_runnable(cur, true /*have lock*/);
+++ 		break;
+++@@ -799,6 +811,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
+++diff --git a/single10.patch b/single10.patch
+++new file mode 100644
+++index 0000000..2267436
+++--- /dev/null
++++++ b/single10.patch
+++@@ -0,0 +1,915 @@
++++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++++index 0f773bd..68c73ff 100644
++++--- a/kern/arch/mips/syscall/syscall.c
+++++++ b/kern/arch/mips/syscall/syscall.c
++++@@ -32,6 +32,7 @@
++++ #include <kern/syscall.h>
++++ #include <lib.h>
++++ #include <mips/trapframe.h>
+++++#include <copyinout.h>
++++ #include <thread.h>
++++ #include <current.h>
++++ #include <syscall.h>
++++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++++ {
++++ 	int callno;
++++ 	int32_t retval;
+++++        int32_t retvalv1 = 0;
+++++        int64_t retval64;
++++ 	int err;
+++++        int32_t stackarg1;
++++ 
++++ 	KASSERT(curthread != NULL);
++++ 	KASSERT(curthread->t_curspl == 0);
++++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++++ 		err = sys___time((userptr_t)tf->tf_a0,
++++ 				 (userptr_t)tf->tf_a1);
++++ 		break;
+++++            case SYS_open:
+++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_read:
+++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_write:
+++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++				&retval);
+++++		break;
+++++	    case SYS_close:
+++++		err = sys_close(tf->tf_a0);
+++++		break;
+++++	    case SYS_lseek:
+++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++++                                stackarg1, &retval64);
+++++                retval = retval64 >> 32;
+++++                retvalv1 = (int) retval64;
+++++		break;
+++++	    case SYS_dup2:
+++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
+++++	    case SYS_chdir:
+++++		err = sys_chdir((userptr_t)tf->tf_a0);
+++++		break;
+++++	    case SYS___getcwd:
+++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
++++ 
++++ 	    /* Add stuff here */
++++  
++++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++++ 	else {
++++ 		/* Success. */
++++ 		tf->tf_v0 = retval;
+++++                tf->tf_v1 = retvalv1;
++++ 		tf->tf_a3 = 0;      /* signal no error */
++++ 	}
++++ 	
++++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++++index d527f61..e1d7682 100644
++++--- a/kern/conf/conf.kern
+++++++ b/kern/conf/conf.kern
++++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++++ file      syscall/loadelf.c
++++ file      syscall/runprogram.c
++++ file      syscall/time_syscalls.c
+++++file      syscall/file_syscalls.c
+++++file      syscall/file.c
++++ 
++++ #
++++ # Startup and initialization
++++diff --git a/kern/include/file.h b/kern/include/file.h
++++new file mode 100644
++++index 0000000..2c63bc2
++++--- /dev/null
+++++++ b/kern/include/file.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Declarations for file handle and file table management.
+++++ * New for SOL2.
+++++ */
+++++
+++++#ifndef _FILE_H_
+++++#define _FILE_H_
+++++
+++++#include <limits.h>
+++++
+++++struct lock;
+++++struct vnode;
+++++
+++++/*** openfile section ***/
+++++
+++++/* 
+++++ * openfile struct 
+++++ * note that there's not too much to keep track of, since the vnode does most
+++++ * of that.  note that it does require synchronization, because a single
+++++ * openfile can be shared between processes (filetable inheritance).
+++++ */
+++++struct openfile {
+++++	struct vnode *of_vnode;
+++++	
+++++	struct lock *of_lock;
+++++	off_t of_offset;
+++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++++	int of_refcount;
+++++};
+++++
+++++/* opens a file (must be kernel pointers in the args) */
+++++int file_open(char *filename, int flags, int mode, int *retfd);
+++++
+++++/* closes a file */
+++++int file_close(int fd);
+++++
+++++
+++++/*** file table section ***/
+++++
+++++/*
+++++ * filetable struct
+++++ * just an array of open files.  nice and simple.  doesn't require
+++++ * synchronization, because a table can only be owned by a single process (on
+++++ * inheritance in fork, the table is copied).
+++++ */
+++++struct filetable {
+++++	struct openfile *ft_openfiles[OPEN_MAX];
+++++};
+++++
+++++/* these all have an implicit arg of the curthread's filetable */
+++++int filetable_init(const char *inpath, const char *outpath, 
+++++		   const char *errpath);
+++++int filetable_copy(struct filetable **copy);
+++++int filetable_placefile(struct openfile *file, int *fd);
+++++int filetable_findfile(int fd, struct openfile **file);
+++++int filetable_dup2file(int oldfd, int newfd);
+++++void filetable_destroy(struct filetable *ft);
+++++
+++++#endif /* _FILE_H_ */
++++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++++index befd3d8..f3a01ad 100644
++++--- a/kern/include/syscall.h
+++++++ b/kern/include/syscall.h
++++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++++  * Prototypes for IN-KERNEL entry points for system call implementations.
++++  */
++++ 
+++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_close(int fd);
+++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++++int sys_dup2(int oldfd, int newfd, int *retval);
+++++int sys_chdir(userptr_t path);
+++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++++
++++ int sys_reboot(int code);
++++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++ 
++++diff --git a/kern/include/thread.h b/kern/include/thread.h
++++index 86706ca..08b8f8c 100644
++++--- a/kern/include/thread.h
+++++++ b/kern/include/thread.h
++++@@ -112,6 +112,7 @@ struct thread {
++++ 	struct vnode *t_cwd;		/* current working directory */
++++ 
++++ 	/* add more here as needed */
+++++  struct filetable *t_filetable;
++++ };
++++ 
++++ /* Call once during system startup to allocate data structures. */
++++diff --git a/kern/include/uio.h b/kern/include/uio.h
++++index 5d97c48..c9124e8 100644
++++--- a/kern/include/uio.h
+++++++ b/kern/include/uio.h
++++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++++ void uio_kinit(struct iovec *, struct uio *,
++++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++++ 
+++++void uio_uinit(struct iovec *, struct uio *,
+++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++++
++++ 
++++ #endif /* _UIO_H_ */
++++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++++index 594fe96..83ea620 100644
++++--- a/kern/lib/uio.c
+++++++ b/kern/lib/uio.c
++++@@ -153,6 +153,7 @@ void
++++ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++++ {
+++++	KASSERT(u);
++++ 	iov->iov_kbase = kbuf;
++++ 	iov->iov_len = len;
++++ 	u->uio_iov = iov;
++++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	u->uio_rw = rw;
++++ 	u->uio_space = NULL;
++++ }
+++++
+++++void
+++++uio_uinit(struct iovec *iov, struct uio *u,
+++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++++{
+++++	KASSERT(u);
+++++	iov->iov_ubase = ubuf;
+++++	iov->iov_len = len;
+++++  u->uio_iov = iov;
+++++	u->uio_iovcnt = 1;
+++++	u->uio_offset = pos;
+++++	u->uio_resid = len;
+++++	u->uio_segflg = UIO_USERSPACE;
+++++	u->uio_rw = rw;
+++++	u->uio_space = curthread->t_addrspace;
+++++}
++++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++++new file mode 100644
++++index 0000000..dc5ffe5
++++--- /dev/null
+++++++ b/kern/syscall/file.c
++++@@ -0,0 +1,341 @@
+++++/*
+++++ * File handles and file tables.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++
+++++/*** openfile functions ***/
+++++
+++++/*
+++++ * file_open
+++++ * opens a file, places it in the filetable, sets RETFD to the file
+++++ * descriptor. the pointer arguments must be kernel pointers.
+++++ * NOTE -- the passed in filename must be a mutable string.
+++++ */
+++++int
+++++file_open(char *filename, int flags, int mode, int *retfd)
+++++{
+++++	struct vnode *vn;
+++++	struct openfile *file;
+++++	int result;
+++++	
+++++	result = vfs_open(filename, flags, mode, &vn);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	file = kmalloc(sizeof(struct openfile));
+++++	if (file == NULL) {
+++++		vfs_close(vn);
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* initialize the file struct */
+++++	file->of_lock = lock_create("file lock");
+++++	if (file->of_lock == NULL) {
+++++		vfs_close(vn);
+++++		kfree(file);
+++++		return ENOMEM;
+++++	}
+++++	file->of_vnode = vn;
+++++	file->of_offset = 0;
+++++	file->of_accmode = flags & O_ACCMODE;
+++++	file->of_refcount = 1;
+++++
+++++	/* vfs_open checks for invalid access modes */
+++++	KASSERT(file->of_accmode==O_RDONLY ||
+++++	        file->of_accmode==O_WRONLY ||
+++++	        file->of_accmode==O_RDWR);
+++++
+++++	/* place the file in the filetable, getting the file descriptor */
+++++	result = filetable_placefile(file, retfd);
+++++	if (result) {
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++		vfs_close(vn);
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * file_doclose
+++++ * shared code for file_close and filetable_destroy
+++++ */
+++++static
+++++int
+++++file_doclose(struct openfile *file)
+++++{
+++++	lock_acquire(file->of_lock);
+++++
+++++	/* if this is the last close of this file, free it up */
+++++	if (file->of_refcount == 1) {
+++++		vfs_close(file->of_vnode);
+++++		lock_release(file->of_lock);
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++	}
+++++	else {
+++++		KASSERT(file->of_refcount > 1);
+++++		file->of_refcount--;
+++++		lock_release(file->of_lock);
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * file_close
+++++ * knock off the refcount, freeing the memory if it goes to 0.
+++++ */
+++++int
+++++file_close(int fd)
+++++{
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* find the file in the filetable */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	result = file_doclose(file);
+++++	if (result) {
+++++		/* leave file open for possible retry */
+++++		return result;
+++++	}
+++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++
+++++	return 0;
+++++}
+++++
+++++/*** filetable functions ***/
+++++
+++++/* 
+++++ * filetable_init
+++++ * pretty straightforward -- allocate the space, initialize to NULL.
+++++ * note that the one careful thing is to open the std i/o in order to
+++++ * get
+++++ * stdin  == 0
+++++ * stdout == 1
+++++ * stderr == 2
+++++ */
+++++int
+++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++++{
+++++	/* the filenames come from the kernel; assume reasonable length */
+++++	char path[32];
+++++	int result;
+++++	int fd;
+++++
+++++	/* make sure we can fit these */
+++++	KASSERT(strlen(inpath) < sizeof(path));
+++++	KASSERT(strlen(outpath) < sizeof(path));
+++++	KASSERT(strlen(errpath) < sizeof(path));
+++++	
+++++	/* catch memory leaks, repeated calls */
+++++	KASSERT(curthread->t_filetable == NULL);
+++++
+++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++++	if (curthread->t_filetable == NULL) {
+++++		return ENOMEM;
+++++	}
+++++	
+++++	/* NULL-out the table */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++	}
+++++
+++++	/*
+++++	 * open the std fds.  note that the names must be copied into
+++++	 * the path buffer so that they're mutable.
+++++	 */
+++++	strcpy(path, inpath);
+++++	result = file_open(path, O_RDONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, outpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, errpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_copy
+++++ * again, pretty straightforward.  the subtle business here is that instead of
+++++ * copying the openfile structure, we just increment the refcount.  this means
+++++ * that openfile structs will, in fact, be shared between processes, as in
+++++ * Unix.
+++++ */
+++++int
+++++filetable_copy(struct filetable **copy)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int fd;
+++++
+++++	/* waste of a call, really */
+++++	if (ft == NULL) {
+++++		*copy = NULL;
+++++		return 0;
+++++	}
+++++	
+++++	*copy = kmalloc(sizeof(struct filetable));
+++++	
+++++	if (*copy == NULL) {
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* copy over the entries */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd] != NULL) {
+++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++++			ft->ft_openfiles[fd]->of_refcount++;
+++++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++++		} 
+++++		else {
+++++			(*copy)->ft_openfiles[fd] = NULL;
+++++		}
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_destroy
+++++ * closes the files in the file table, frees the table.
+++++ */
+++++void
+++++filetable_destroy(struct filetable *ft)
+++++{
+++++	int fd, result;
+++++
+++++	KASSERT(ft != NULL);
+++++
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd]) {
+++++			result = file_doclose(ft->ft_openfiles[fd]);
+++++			KASSERT(result==0);
+++++		}
+++++	}
+++++	
+++++	kfree(ft);
+++++}	
+++++
+++++/* 
+++++ * filetable_placefile
+++++ * finds the smallest available file descriptor, places the file at the point,
+++++ * sets FD to it.
+++++ */
+++++int
+++++filetable_placefile(struct openfile *file, int *fd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int i;
+++++	
+++++	for (i = 0; i < OPEN_MAX; i++) {
+++++		if (ft->ft_openfiles[i] == NULL) {
+++++			ft->ft_openfiles[i] = file;
+++++			*fd = i;
+++++			return 0;
+++++		}
+++++	}
+++++
+++++	return EMFILE;
+++++}
+++++
+++++/*
+++++ * filetable_findfile
+++++ * verifies that the file descriptor is valid and actually references an
+++++ * open file, setting the FILE to the file at that index if it's there.
+++++ */
+++++int
+++++filetable_findfile(int fd, struct openfile **file)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++
+++++	if (fd < 0 || fd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++	
+++++	*file = ft->ft_openfiles[fd];
+++++	if (*file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_dup2file
+++++ * verifies that both file descriptors are valid, and that the OLDFD is
+++++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++++ */
+++++int
+++++filetable_dup2file(int oldfd, int newfd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++
+++++	file = ft->ft_openfiles[oldfd];
+++++	if (file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++++	if (oldfd == newfd) {
+++++		return 0;
+++++	}
+++++
+++++	/* closes the newfd if it's open */
+++++	if (ft->ft_openfiles[newfd] != NULL) {
+++++		result = file_close(newfd);
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
+++++
+++++	/* up the refcount */
+++++	lock_acquire(file->of_lock);
+++++	file->of_refcount++;
+++++	lock_release(file->of_lock);
+++++
+++++	/* doesn't need to be synchronized because it's just changing the ft */
+++++	ft->ft_openfiles[newfd] = file;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++++new file mode 100644
++++index 0000000..8aa024c
++++--- /dev/null
+++++++ b/kern/syscall/file_syscalls.c
++++@@ -0,0 +1,270 @@
+++++/*
+++++ * File-related system call implementations.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <kern/seek.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++#include <copyinout.h>
+++++
+++++/*
+++++ * sys_open
+++++ * just copies in the filename, then passes work to file_open.
+++++ */
+++++int
+++++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++++{
+++++	char fname[PATH_MAX];
+++++	int result;
+++++
+++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return file_open(fname, flags, mode, retval);
+++++}
+++++
+++++/*
+++++ * sys_read
+++++ * translates the fd into its openfile, then calls VOP_READ.
+++++ */
+++++int
+++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* better be a valid file descriptor */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_WRONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++++  
+++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++++
+++++	/* does the read */
+++++	result = VOP_READ(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++	
+++++	/*
+++++	 * The amount read is the size of the buffer originally, minus
+++++	 * how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * sys_write
+++++ * translates the fd into its openfile, then calls VOP_WRITE.
+++++ */
+++++int
+++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_RDONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++++	
+++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++++
+++++	/* does the write */
+++++	result = VOP_WRITE(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	/*
+++++	 * the amount written is the size of the buffer originally,
+++++	 * minus how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_close
+++++ * just pass off the work to file_close.
+++++ */
+++++int
+++++sys_close(int fd)
+++++{
+++++	return file_close(fd);
+++++}
+++++
+++++/*
+++++ * sys_lseek
+++++ * translates the fd into its openfile, then based on the type of seek,
+++++ * figure out the new offset, try the seek, if that succeeds, update the
+++++ * openfile.
+++++ */
+++++int
+++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++++{
+++++	struct stat info;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++	
+++++	/* based on the type of seek, set the retval */ 
+++++	switch (whence) {
+++++	    case SEEK_SET:
+++++		*retval = offset;
+++++		break;
+++++	    case SEEK_CUR:
+++++		*retval = file->of_offset + offset;
+++++		break;
+++++	    case SEEK_END:
+++++		result = VOP_STAT(file->of_vnode, &info);
+++++		if (result) {
+++++			lock_release(file->of_lock);
+++++			return result;
+++++		}
+++++		*retval = info.st_size + offset;
+++++		break;
+++++	    default:
+++++		lock_release(file->of_lock);
+++++		return EINVAL;
+++++	}
+++++
+++++	/* try the seek -- if it fails, return */
+++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++	
+++++	/* success -- update the file structure */
+++++	file->of_offset = *retval;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_dup2
+++++ * just pass the work off to the filetable
+++++ */
+++++int
+++++sys_dup2(int oldfd, int newfd, int *retval)
+++++{
+++++	int result;
+++++
+++++	result = filetable_dup2file(oldfd, newfd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = newfd;
+++++	return 0;
+++++}
+++++
+++++/* really not "file" calls, per se, but might as well put it here */
+++++
+++++/*
+++++ * sys_chdir
+++++ * copyin the path and pass it off to vfs.
+++++ */
+++++int
+++++sys_chdir(userptr_t path)
+++++{
+++++	char pathbuf[PATH_MAX];
+++++	int result;
+++++	
+++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return vfs_chdir(pathbuf);
+++++}
+++++
+++++/*
+++++ * sys___getcwd
+++++ * just use vfs_getcwd.
+++++ */
+++++int
+++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	int result;
+++++  
+++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	result = vfs_getcwd(&useruio);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = buflen - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++++index a6f45c8..4ba181a 100644
++++--- a/kern/syscall/runprogram.c
+++++++ b/kern/syscall/runprogram.c
++++@@ -44,6 +44,7 @@
++++ #include <vfs.h>
++++ #include <syscall.h>
++++ #include <test.h>
+++++#include <file.h>
++++ 
++++ /*
++++  * Load program "progname" and start running it in usermode.
++++@@ -66,6 +67,13 @@ runprogram(char *progname)
++++ 
++++ 	/* We should be a new thread. */
++++ 	KASSERT(curthread->t_addrspace == NULL);
+++++	
+++++  if (curthread->t_filetable == NULL) {
+++++		result = filetable_init("con:", "con:", "con:");
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
++++ 
++++ 	/* Create a new address s
++\ No newline at end of file
++diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
++index 287a678..db31b89 100644
++--- a/user/testbin/badcall/bad_execv.c
+++++ b/user/testbin/badcall/bad_execv.c
++@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
++ 		return;
++ 	}
++ 
+++
++ 	rv = execv("/bin/true", args);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	exit(MAGIC_STATUS);
++diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
++index 809c68c..8eb69c3 100644
++--- a/user/testbin/badcall/bad_waitpid.c
+++++ b/user/testbin/badcall/bad_waitpid.c
++@@ -36,6 +36,7 @@
++ #include <unistd.h>
++ #include <errno.h>
++ #include <err.h>
+++#include<stdio.h>
++ 
++ #include "config.h"
++ #include "test.h"
++@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Hello:%d",(int)ptr);
++ 
++ 	rv = waitpid(pid, ptr, 0);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	waitpid(pid, &x, 0);
++ }
++ 
+++
++ static
++ void
++ wait_unaligned(void)
++@@ -85,13 +88,16 @@ wait_unaligned(void)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Aligned int:%d",&status);
++ 
++ 	/* start with proper integer alignment */
++ 	ptr = (char *)(&status[0]);
++-
+++	//printf("Aligned:%c\n",*ptr);
++ 	/* generate improper alignment on platforms with restrictions*/
++ 	ptr++;
++ 
+++	//Print("UnAligned:%c\n",*ptr);
+++
++ 	rv = waitpid(pid, (int *)ptr, 0);
++ 	report_survival(rv, errno, "wait with unaligned status");
++ 	if (rv<0) {
++diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
++new file mode 100644
++index 0000000..fe21882
++--- /dev/null
+++++ b/user/testbin/myforktest/Makefile
++@@ -0,0 +1,11 @@
+++# Makefile for forktest
+++
+++TOP=../../..
+++.include "$(TOP)/mk/os161.config.mk"
+++
+++PROG=myforktest
+++SRCS=myforktest.c
+++BINDIR=/testbin
+++
+++.include "$(TOP)/mk/os161.prog.mk"
+++
++diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
++new file mode 100644
++index 0000000..7bd6663
++--- /dev/null
+++++ b/user/testbin/myforktest/myforktest.c
++@@ -0,0 +1,33 @@
+++#include <unistd.h>
+++#include <string.h>
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <err.h>
+++
+++int main()
+++{
+++	int status;
+++	int pid;
+++	int childpid;
+++	int parent;
+++	int returnCode=fork();
+++
+++	if(returnCode==0)
+++	{
+++		childpid=getpid();
+++		printf("I am child:%d\n",childpid);
+++		return -10;
+++	}
+++	else
+++	{
+++		//printf("Return:%d",returnCode);
+++		//printf("Wait for child\n");
+++		parent=getpid();
+++		printf("I am parent:%d\n",parent);
+++		pid=waitpid(returnCode,&status,0);
+++		printf("Child id returned" "%d",pid);
+++		printf(" Return code: %d\n",status);
+++
+++	}
+++	return 0;
+++}
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/submit4.patch b/submit4.patch
new file mode 100644
index 0000000..4a39a2a
--- /dev/null
+++ b/submit4.patch
@@ -0,0 +1,13154 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..33b99ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	int flag;
++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	if(flag)
++	{
++		newtf.tf_v0=ENOMEM;
++		newtf.tf_a3=1;
++	}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	curthread->pid=newtf.tf_a0;
++
++	as_activate(curthread->t_addrspace);
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..a4c2750 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	fthread->proc->tlock=lock_create("First Lock");
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..04b1396
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,511 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro)
++{
++	//lock_acquire(mypro->tlock);
++	while(!mypro->exited)
++	{
++		cv_wait(mypro->wcv,mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++
++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
++{
++	(void)adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
++	bzero(copyt,sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt,tf,sizeof(struct trapframe));
++	flag=as_copy(curthread->t_addrspace,&adrcopy);
++	//if(curthread->pid==0)
++	//{
++		//curthread->pid=PID_MIN;
++	//}
++    if(flag)
++    {
++    	kfree(copyt);
++    	return flag;
++    }
++
++    //we need to allocate pid for our new process
++
++    //pid_t cpid;
++    for(childid=0;childid<=16;childid++)
++    {
++     if(p_table[childid]==NULL)
++     {
++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
++    	p_table[childid]->full=1;
++    	pidcount++;
++    	p_table[childid]->pid=pidcount;
++    	p_table[childid]->ppid=curthread->pid;
++    	//p_table[childid]->exitsem=sem_create("process",0);
++    	p_table[childid]->tlock=lock_create("My Lock");
++    	p_table[childid]->wcv=cv_create("My CV");
++    	p_table[childid]->self=NULL;
++    	break;
++     }
++    }
++    if(childid>PID_MAX)
++    {
++    	*retval=1;
++    	return EMPROC;
++    }
++    //int i;
++
++    copyt->tf_a0=(int)p_table[childid]->pid;
++    //kprintf("Ret:%d\n",copyt->tf_a0);
++    struct thread *new_proc;
++    //curthread->t_addrspace=(struct addrspace*)adrcopy;
++    //int s=splhigh();
++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
++    //kprintf("Out of thread fork:%d\n",flag);
++    if(flag)
++    {
++    	kfree(copyt);
++    	as_destroy(adrcopy);
++
++    	return flag;
++    }
++
++    //new_proc->pid=(pid_t)childid;
++    //new_proc=p_table[childid];
++
++    new_proc->pid=p_table[childid]->pid;
++    new_proc->proc=p_table[childid];
++   // new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++    //if (new_proc->t_filetable == NULL) {
++    //return ENOMEM;
++    //}
++    p_table[childid]->self=new_proc;
++
++    //new_proc->pid=p_table[childid]->pid;
++    //new_proc->proc->pid=p_table[childid]->pid;
++    //kprintf("Child id in fork: %d\n",new_proc->pid);
++
++
++   //kprintf("Child id:%d",new_proc->pid);
++    //new_proc->t_filetable->
++    //for(i=0;i<128;i++)
++    //{
++    flag=filetable_copy(&new_proc->t_filetable);
++    //}
++    //splx(s);
++   // kprintf("Fork over!");
++
++    *retval=p_table[childid]->pid;
++    //kprintf("Return val in fork:%d",*retval);
++    return 0;
++
++    //flag=
++     //flag=thread_fork=
++}
++
++int sys_execv(char *progname,char** arguments)
++{
++
++	int flag;
++		int numargs;
++		int addr;
++		int i;
++		// first we need to copy the program name to the kernel space
++		// then we go for arguments. Path size unknown
++
++		size_t actual_size=0;
++		char *namedes;
++
++
++		if(progname==NULL)
++		{
++			return EFAULT;
++		}
++		if(progname=="")
++		{
++			return EINVAL;
++		}
++
++
++		namedes=(char*)kmalloc(PATH_MAX);
++		flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
++		if(flag!=0)
++		{
++			kfree(namedes);
++			return flag;
++		}
++		//namedes[actual_size]
++		if(strlen(namedes)==0)
++		{
++			//*retval=1;
++			return EISDIR;
++		}
++
++
++		// now we open file using vfs_open. Same as runprogram
++		struct vnode* vn;
++		flag=vfs_open(namedes,O_RDONLY,0,&vn);
++		if(flag)
++		{
++			return flag;
++		}
++		actual_size=0;
++		// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++		//char** kargv=(char**)kmalloc(sizeof(char));
++		// get the number of arguments
++		if(arguments==NULL)
++		{
++			kfree(namedes);
++			return EFAULT;
++		}
++		flag=copyin((userptr_t)arguments,&addr,sizeof(int));
++			if(flag)
++			{
++				kfree(namedes);
++				return EFAULT;
++			}
++
++			//check=wthread->exitcode;
++			//err=copyout(&check,(userptr_t)status,sizeof(check));
++			//if(err)
++			//{
++			//	lock_release(p_table[i]->tlock);
++				//return err;
++			//}
++
++			numargs=0;
++			while(arguments[numargs]!=NULL)
++			{
++				//kprintf("%");
++				numargs=numargs+1;
++			}
++
++			char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
++			//int i;
++			for(i=0;i<numargs;i++)
++			{
++				actual_size=0;
++				kargv[i]=(char*)kmalloc(PATH_MAX);
++				flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
++				if(flag)
++				{
++					kfree(kargv);
++					kfree(namedes);
++					return EFAULT;
++				}
++
++			}
++			actual_size=0;
++
++
++			curthread->t_addrspace=as_create();
++				if(curthread->t_addrspace==NULL)
++				{
++					vfs_close(vn);
++					return ENOMEM;
++				}
++
++				vaddr_t entrypoint, stackptr;
++				as_activate(curthread->t_addrspace);
++				flag = load_elf(vn, &entrypoint);
++					if (flag) {
++						// thread_exit destroys curthread->t_addrspace
++						vfs_close(vn);
++						return flag;
++					}
++
++				vfs_close(vn);
++
++			// now set up the user stack with the arguments
++				flag = as_define_stack(curthread->t_addrspace, &stackptr);
++					if (flag) {
++						 //thread_exit destroys curthread->t_addrspace
++						return flag;
++					}
++					int j;
++					//i=0;
++					vaddr_t stackptrv[numargs+1];
++					for(i = numargs-1; i >= 0; i--)
++					{
++					int len = strlen(kargv[i]);
++					len++;
++					int padding = len % 4;
++					stackptr -= len + (4 - padding);
++					flag = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual_size);
++					if(flag)
++					{
++					for(j = 0; j < numargs; j++)
++					{
++					kfree(kargv[j]);
++					}
++					kfree(kargv);
++					kfree(namedes);
++					return flag;
++					}
++					stackptrv[i] = stackptr;
++					}
++					stackptrv[numargs] = 0;
++
++					//This copies the actual stack addresses of the arguments
++					//* into the stack. Hopefully.
++
++					for(i = numargs; i >= 0; i--)
++					{
++					stackptr -= sizeof(vaddr_t);
++					flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++					if(flag)
++					{
++					for(j = 0; j <numargs ; j++)
++					{
++					kfree(kargv[j]);
++					}
++					kfree(kargv);
++					kfree(namedes);
++					return flag;
++					}
++					}
++					enter_new_process(numargs,(userptr_t)stackptr,
++										  stackptr, entrypoint);
++							//pt_getthread();
++
++
++								//enter_new_process does not return.
++								panic("enter_new_process returned\n");
++								return EINVAL;
++
++}
++
++
++
++int sys_getpid(pid_t *retval)
++{
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval=curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
++{
++	struct process* wthread=NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if(status==NULL)
++		return EFAULT;
++	if(options!=0)
++		return EINVAL;
++	if (pid==curthread->pid)
++		return ECHILD;
++	if (pid<PID_MIN||pid>PID_MAX)
++		return ESRCH;
++	if (status==NULL)
++		return EFAULT;
++	if(pid==curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++				//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++		//return EFAULT;
++	//}
++
++
++	//if()
++
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++		//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++		//if (result) {
++			//return result;
++		//}
++		//int addr=(int)&status;
++		//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++		//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for(i=0;i<=16;i++)
++	{
++		if(p_table[i]!=NULL)
++		{
++		if(p_table[i]->pid==pid)
++		{
++			wthread=p_table[i];
++			break;
++		}
++		}
++	}
++	if(wthread==NULL)
++	{
++		return ESRCH;
++	}
++	if(curthread->proc->pid!=wthread->ppid)
++	return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check=wthread->exitcode;
++	err=copyout(&check,(userptr_t)status,sizeof(check));
++	if(err)
++	{
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i]=NULL;
++
++	*retval=pid;
++	//panic("After dereferencing");
++	return 0;
++
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode)
++{
++pid_t pid=curthread->proc->pid;
++pid_t i=PID_MIN;
++struct process* ethread;
++//pid_t parent;
++//if(pid!=2)
++//{
++for(i=0;i<=16;i++)
++{
++	if(p_table[i]!=NULL)
++	{
++	if(p_table[i]->pid==pid)
++	{
++			ethread=p_table[i];
++			break;
++	}
++	}
++}
++
++//parent=ethread->ppid;
++if(ethread!=NULL)
++{
++lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++ethread->exitcode=_MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++ethread->exited=1;
++//p_table[i]=ethread;
++cv_broadcast(ethread->wcv,ethread->tlock);
++//kfree(curthread->t_filetable);
++lock_release(ethread->tlock);
++}
++//}
++i=0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++thread_exit();
++}
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..ab0197b 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,39 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++len++;
++int padding = len % 4;
++stackptr -= len + (4 - padding);
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..df129b9 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +357,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +377,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +532,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +811,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..35359e4
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,8869 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..c8d768b
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,741 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro)
+++{
+++	//lock_acquire(mypro->tlock);
+++	while(!mypro->exited)
+++	{
+++		cv_wait(mypro->wcv,mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++
+++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
+++{
+++	(void)adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
+++	bzero(copyt,sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt,tf,sizeof(struct trapframe));
+++	flag=as_copy(curthread->t_addrspace,&adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++		//curthread->pid=PID_MIN;
+++	//}
+++    if(flag)
+++    {
+++    	kfree(copyt);
+++    	return flag;
+++    }
+++
+++    //we need to allocate pid for our new process
+++
+++    //pid_t cpid;
+++    for(childid=0;childid<=16;childid++)
+++    {
+++     if(p_table[childid]==NULL)
+++     {
+++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
+++    	p_table[childid]->full=1;
+++    	pidcount++;
+++    	p_table[childid]->pid=pidcount;
+++    	p_table[childid]->ppid=curthread->pid;
+++    	//p_table[childid]->exitsem=sem_create("process",0);
+++    	p_table[childid]->tlock=lock_create("My Lock");
+++    	p_table[childid]->wcv=cv_create("My CV");
+++    	p_table[childid]->self=NULL;
+++    	break;
+++     }
+++    }
+++    if(childid>PID_MAX)
+++    {
+++    	*retval=1;
+++    	return EMPROC;
+++    }
+++    //int i;
+++
+++    copyt->tf_a0=(int)p_table[childid]->pid;
+++    //kprintf("Ret:%d\n",copyt->tf_a0);
+++    struct thread *new_proc;
+++    //curthread->t_addrspace=(struct addrspace*)adrcopy;
+++    //int s=splhigh();
+++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
+++    //kprintf("Out of thread fork:%d\n",flag);
+++    if(flag)
+++    {
+++    	kfree(copyt);
+++    	as_destroy(adrcopy);
+++
+++    	return flag;
+++    }
+++
+++    //new_proc->pid=(pid_t)childid;
+++    //new_proc=p_table[childid];
+++
+++    new_proc->pid=p_table[childid]->pid;
+++    new_proc->proc=p_table[childid];
+++   // new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++    //if (new_proc->t_filetable == NULL) {
+++    //return ENOMEM;
+++    //}
+++    p_table[childid]->self=new_proc;
+++
+++    //new_proc->pid=p_table[childid]->pid;
+++    //new_proc->proc->pid=p_table[childid]->pid;
+++    //kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++
+++   //kprintf("Child id:%d",new_proc->pid);
+++    //new_proc->t_filetable->
+++    //for(i=0;i<128;i++)
+++    //{
+++    flag=filetable_copy(&new_proc->t_filetable);
+++    //}
+++    //splx(s);
+++   // kprintf("Fork over!");
+++
+++    *retval=p_table[childid]->pid;
+++    //kprintf("Return val in fork:%d",*retval);
+++    return 0;
+++
+++    //flag=
+++     //flag=thread_fork=
+++}
+++
+++/*
+++
+++int sys_execv(char* progname,char** arguments,int *retval)
+++{
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size=0;
+++	char *namedes;
+++
+++
+++	if(progname==NULL)
+++	{
+++		return EFAULT;
+++	}
+++	if(progname=="")
+++	{
+++		return EINVAL;
+++	}
+++
+++
+++	namedes=(char*)kmalloc(PATH_MAX);
+++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
+++	if(flag!=0)
+++	{
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if(strlen(namedes)==0)
+++	{
+++		*retval=1;
+++		return EISDIR;
+++	}
+++
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
+++	if(flag)
+++	{
+++		return flag;
+++	}
+++	actual_size=0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if(arguments==NULL)
+++	{
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag=copyin((userptr_t)arguments,&addr,sizeof(int));
+++	if(flag)
+++	{
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++		//return err;
+++	//}
+++
+++	numargs=0;
+++	while(arguments[numargs]!=NULL)
+++	{
+++		//kprintf("%");
+++		numargs=numargs+1;
+++	}
+++
+++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
+++	int i;
+++	for(i=0;i<numargs;i++)
+++	{
+++		actual_size=0;
+++		kargv[i]=(char*)kmalloc(PATH_MAX);
+++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
+++		if(flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size=0;
+++
+++
+++	// same as runprogram
+++
+++	curthread->t_addrspace=as_create();
+++	if(curthread->t_addrspace==NULL)
+++	{
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++		if (flag) {
+++			// thread_exit destroys curthread->t_addrspace
+++			vfs_close(vn);
+++			return flag;
+++		}
+++
+++	vfs_close(vn);
+++
+++// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++		if (flag) {
+++			 //thread_exit destroys curthread->t_addrspace
+++			return flag;
+++		}
+++		//i=0;
+++
+++		for(i=numargs-1;i>=0;i--)
+++		{
+++			actual_size=0;
+++			int length=strlen(kargv[i])+1;
+++			//int length=strlen(kargv[i]);
+++			int padder=length%4;
+++			if(padder!=0)
+++			length=length+padder;
+++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
+++			//stackptr=stackptr+length;
+++			stackptr=stackptr-length;
+++
+++
+++		}
+++		for(i = numargs; i >= 0; i--)
+++		{
+++		stackptr -= sizeof(vaddr_t);
+++		flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++		if(result)
+++		{
+++		for(j = 0; j < argc; j++)
+++		{
+++		kfree(kargv[j]);
+++		}
+++		kfree(kargv);
+++		kfree(filename);
+++		return result;
+++		}
+++		}
+++
+++		vaddr_t stackptrv[argc+1];
+++		for(i = argc-1; i >= 0; i--)
+++		{
+++		int len = strlen(kargv[i]);
+++		len++;
+++		int padding = len % 4;
+++		stackptr -= len + (4 - padding);
+++		result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
+++		if(result)
+++		{
+++		for(j = 0; j < argc; j++)
+++		{
+++		kfree(kargv[j]);
+++		}
+++		kfree(kargv);
+++		kfree(namedes);
+++		return flag;
+++		}
+++		stackptrv[i] = stackptr;
+++		}
+++		stackptrv[numargs] = 0;
+++		enter_new_process(numargs,(userptr_t)stackptr,
+++					  stackptr, entrypoint);
+++		//pt_getthread();
+++
+++
+++			//enter_new_process does not return.
+++			panic("enter_new_process returned\n");
+++			return EINVAL;
+++}
+++*/
+++
+++
+++
+++
+++
+++int
+++sys_execv(char *progname, char **argv)
+++{
+++struct vnode *v;
+++vaddr_t entrypoint, stackptr;
+++char **kargv;
+++int result;
+++int i;
+++int j;
+++int testAddress;
+++int argc = 0;
+++size_t actual;
+++
+++if(progname == NULL)
+++{
+++return EFAULT;
+++}
+++
+++char *filename = (char *)kmalloc(PATH_MAX);
+++result = copyinstr((const_userptr_t)progname, filename, (size_t)NAME_MAX, &actual);
+++if(result)
+++{
+++kfree(filename);
+++return result;
+++}
+++if(strlen(filename) == 0)
+++{
+++return EINVAL;
+++}
+++
+++if(argv != NULL)
+++{
+++/* test to see that argv is a valid address */
+++result = copyin((const_userptr_t)argv, &testAddress, sizeof(int));
+++if(result)
+++{
+++kfree(filename);
+++return result;
+++}
+++
+++/* Get argc */
+++while(argv[argc] != NULL)
+++{
+++argc++;
+++}
+++/* Create kargv and safely copy in string arguments. */
+++kargv = (char **)kmalloc(sizeof(char *) * argc);
+++for(i = 0; i < argc; i++)
+++{
+++kargv[i] = (char *)kmalloc(PATH_MAX);
+++result = copyinstr((const_userptr_t)argv[i], kargv[i], PATH_MAX, &actual);
+++if(result)
+++{
+++/* In here I'm just freeing the char *
+++* that I've already kmalloc'ed. Not sure
+++* if this is correct
+++*/
+++for(j = 0; j < i; j++)
+++{
+++kfree(kargv[j]);
+++}
+++kfree(kargv[i]);
+++kfree(kargv);
+++kfree(filename);
+++return result;
+++}
+++}
+++}
+++/* open the file with filename */
+++result = vfs_open(filename, O_RDONLY,0,&v);
+++if(result)
+++{
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++/* Destroy current address space */
+++if(curthread->t_addrspace)
+++{
+++as_destroy(curthread->t_addrspace);
+++curthread->t_addrspace = NULL;
+++}
+++
+++KASSERT(curthread->t_addrspace == NULL);
+++
+++/* Create new address space */
+++curthread->t_addrspace = as_create();
+++if(curthread->t_addrspace == NULL)
+++{
+++vfs_close(v);
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++
+++/* Activate the address space */
+++as_activate(curthread->t_addrspace);
+++
+++/* Load the executable. */
+++result = load_elf(v, &entrypoint);
+++if (result)
+++{
+++vfs_close(v);
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++/* Done with the file now. */
+++vfs_close(v);
+++
+++/* Define the user stack in the address space */
+++result = as_define_stack(curthread->t_addrspace, &stackptr);
+++if (result) {
+++if(argv != NULL)
+++{
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++return result;
+++}
+++
+++//if(argv != NULL)
+++//{
+++/* This hopefully safely copies from kargv into
+++* the user stack
+++*/
+++vaddr_t stackptrv[argc+1];
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(kargv[i]);
+++len++;
+++int padding = len % 4;
+++stackptr -= len + (4 - padding);
+++result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++for(j = 0; j < argc; j++)
+++{
+++kfree(kargv[j]);
+++}
+++kfree(kargv);
+++kfree(filename);
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++
+++/* This copies the actual stack addresses of the arguments
+++* into the stack. Hopefully.
+++*/
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++for(j = 0; j < argc; j++)
+++{
+++kfree(kargv[j]);
+++}
+++kfree(kargv);
+++kfree(filename);
+++return result;
+++}
+++//}
+++
+++/* Free everything we have kmalloc'ed */
+++for(i = 0; i < argc; i++)
+++{
+++kfree(kargv[i]);
+++}
+++kfree(kargv);
+++}
+++kfree(filename);
+++
+++/* Warp to user mode */
+++//md_usermode(argc, (userptr_t)stackptr, stackptr, entrypoint);
+++enter_new_process(argc,(userptr_t)stackptr,
+++					  stackptr, entrypoint);
+++		//pt_getthread();
+++
+++/* md_usermode does not return */
+++panic("md_usermode returned\n");
+++return EINVAL;
+++}
+++
+++
+++
+++int sys_getpid(pid_t *retval)
+++{
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval=curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
+++{
+++	struct process* wthread=NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if(status==NULL)
+++		return EFAULT;
+++	if(options!=0)
+++		return EINVAL;
+++	if (pid==curthread->pid)
+++		return ECHILD;
+++	if (pid<PID_MIN||pid>PID_MAX)
+++		return ESRCH;
+++	if (status==NULL)
+++		return EFAULT;
+++	if(pid==curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++				//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++		//return EFAULT;
+++	//}
+++
+++
+++	//if()
+++
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++		//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++		//if (result) {
+++			//return result;
+++		//}
+++		//int addr=(int)&status;
+++		//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++		//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for(i=0;i<=16;i++)
+++	{
+++		if(p_table[i]!=NULL)
+++		{
+++		if(p_table[i]->pid==pid)
+++		{
+++			wthread=p_table[i];
+++			break;
+++		}
+++		}
+++	}
+++	if(wthread==NULL)
+++	{
+++		return ESRCH;
+++	}
+++	if(curthread->proc->pid!=wthread->ppid)
+++	return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check=wthread->exitcode;
+++	err=copyout(&check,(userptr_t)status,sizeof(check));
+++	if(err)
+++	{
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i]=NULL;
+++
+++	*retval=pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode)
+++{
+++pid_t pid=curthread->proc->pid;
+++pid_t i=PID_MIN;
+++struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++for(i=0;i<=16;i++)
+++{
+++	if(p_table[i]!=NULL)
+++	{
+++	if(p_table[i]->pid==pid)
+++	{
+++			ethread=p_table[i];
+++			break;
+++	}
+++	}
+++}
+++
+++//parent=ethread->ppid;
+++if(ethread!=NULL)
+++{
+++lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++ethread->exitcode=_MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++ethread->exited=1;
+++//p_table[i]=ethread;
+++cv_broadcast(ethread->wcv,ethread->tlock);
+++//kfree(curthread->t_filetable);
+++lock_release(ethread->tlock);
+++}
+++//}
+++i=0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++thread_exit();
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..ab0197b 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,39 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++len++;
+++int padding = len % 4;
+++stackptr -= len + (4 - padding);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index 5b8099e..60108d3 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -798,6 +801,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..8e688a0
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,4353 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..33b99ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,11 +32,14 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <addrspace.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
+++ 
++++
+++ /*
+++  * System call dispatcher.
+++  *
+++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++                break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++			break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_fork:
++++	    	err=0;
++++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++++	    	break;
++++	    case SYS_execv:
++++	    	err=0;
++++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++++	    	break;
++++	    case SYS_getpid:
++++	    	err=0;
++++	    	err=sys_getpid(&retval);
++++	    	break;
++++	    case SYS_waitpid:
++++	    	err=0;
++++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++	    	//panic("Waitpid over");
++++	    	break;
++++	    case SYS__exit:
++++	    	sys_exit((int)tf->tf_a0);
++++	    	break;
++++
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+++  *
+++  * Thus, you can trash it and do things another way if you prefer.
+++  */
+++-void
+++-enter_forked_process(struct trapframe *tf)
++++//void
++++//enter_forked_process(struct trapframe *tf)
++++//{
++++	//(void)tf;
++++//}
++++
++++void enter_forked_process(void*tf,unsigned long adrspace)
+++ {
+++-	(void)tf;
++++	tf=(struct trapframe*)tf;
++++	struct trapframe newtf;
++++	int flag;
++++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++++	if(flag)
++++	{
++++		newtf.tf_v0=ENOMEM;
++++		newtf.tf_a3=1;
++++	}
++++
++++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++++	kfree(tf);
++++	//tf=NULL;
++++	//int flag;
++++
++++	curthread->pid=newtf.tf_a0;
++++
++++	as_activate(curthread->t_addrspace);
++++
++++
++++
++++	newtf.tf_v0=0;
++++	newtf.tf_a3=0;
++++	newtf.tf_epc+=4;
++++	mips_usermode(&newtf);
+++ }
+++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+++new file mode 100644
+++index 0000000..3e8d5b9
+++--- /dev/null
++++++ b/kern/arch/mips/syscall/syscall.c~
+++@@ -0,0 +1,165 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/syscall.h>
++++#include <lib.h>
++++#include <mips/trapframe.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <syscall.h>
++++
++++
++++/*
++++ * System call dispatcher.
++++ *
++++ * A pointer to the trapframe created during exception entry (in
++++ * exception.S) is passed in.
++++ *
++++ * The calling conventions for syscalls are as follows: Like ordinary
++++ * function calls, the first 4 32-bit arguments are passed in the 4
++++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++++ * unused.
++++ *
++++ * This much is the same as the calling conventions for ordinary
++++ * function calls. In addition, the system call number is passed in
++++ * the v0 register.
++++ *
++++ * On successful return, the return value is passed back in the v0
++++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++++ * function call, and additionally the a3 register is also set to 0 to
++++ * indicate success.
++++ *
++++ * On an error return, the error code is passed back in the v0
++++ * register, and the a3 register is set to 1 to indicate failure.
++++ * (Userlevel code takes care of storing the error code in errno and
++++ * returning the value -1 from the actual userlevel syscall function.
++++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++++ *
++++ * Upon syscall return the program counter stored in the trapframe
++++ * must be incremented by one instruction; otherwise the exception
++++ * return code will restart the "syscall" instruction and the system
++++ * call will repeat forever.
++++ *
++++ * If you run out of registers (which happens quickly with 64-bit
++++ * values) further arguments must be fetched from the user-level
++++ * stack, starting at sp+16 to skip over the slots for the
++++ * registerized values, with copyin().
++++ */
++++void
++++syscall(struct trapframe *tf)
++++{
++++	int callno;
++++	int32_t retval;
++++	int err;
++++
++++	KASSERT(curthread != NULL);
++++	KASSERT(curthread->t_curspl == 0);
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++
++++	callno = tf->tf_v0;
++++
++++	/*
++++	 * Initialize retval to 0. Many of the system calls don't
++++	 * really return a value, just 0 for success and -1 on
++++	 * error. Since retval is the value returned on success,
++++	 * initialize it to 0 by default; thus it's not necessary to
++++	 * deal with it except for calls that return other values, 
++++	 * like write.
++++	 */
++++
++++	retval = 0;
++++
++++	switch (callno) {
++++	    case SYS_reboot:
++++		err = sys_reboot(tf->tf_a0);
++++		break;
++++
++++	    case SYS___time:
++++		err = sys___time((userptr_t)tf->tf_a0,
++++				 (userptr_t)tf->tf_a1);
++++		break;
++++		
++++	    case SYS_open:
++++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++++	    break;
++++
++++	    /* Add stuff here */
++++ 
++++	    default:
++++		kprintf("Unknown syscall %d\n", callno);
++++		err = ENOSYS;
++++		break;
++++	}
++++
++++
++++	if (err) {
++++		/*
++++		 * Return the error code. This gets converted at
++++		 * userlevel to a return value of -1 and the error
++++		 * code in errno.
++++		 */
++++		tf->tf_v0 = err;
++++		tf->tf_a3 = 1;      /* signal an error */
++++	}
++++	else {
++++		/* Success. */
++++		tf->tf_v0 = retval;
++++		tf->tf_a3 = 0;      /* signal no error */
++++	}
++++	
++++	/*
++++	 * Now, advance the program counter, to avoid restarting
++++	 * the syscall over and over again.
++++	 */
++++	
++++	tf->tf_epc += 4;
++++
++++	/* Make sure the syscall code didn't forget to lower spl */
++++	KASSERT(curthread->t_curspl == 0);
++++	/* ...or leak any spinlocks */
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++}
++++
++++/*
++++ * Enter user mode for a newly forked process.
++++ *
++++ * This function is provided as a reminder. You need to write
++++ * both it and the code that calls it.
++++ *
++++ * Thus, you can trash it and do things another way if you prefer.
++++ */
++++void
++++enter_forked_process(struct trapframe *tf)
++++{
++++	(void)tf;
++++}
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..7d5df71 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,9 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
++++file	  syscall/proc_sys.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/limits.h b/kern/include/limits.h
+++index 01684c4..3a54e24 100644
+++--- a/kern/include/limits.h
++++++ b/kern/include/limits.h
+++@@ -48,5 +48,6 @@
+++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+++ #define OPEN_MAX        __OPEN_MAX
+++ #define IOV_MAX         __IOV_MAX
++++//#define OPEN_MAX        64
+++ 
+++ #endif /* _LIMITS_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..df9fe64 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,11 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        //struct spinlock cv_lock;
++++        struct wchan *cv_wchan;
++++        //volatile int hold;
++++        //struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ 
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int res_count;
++++        struct wchan *rd_wchan;
++++        struct wchan *wr_wchan;
++++        struct semaphore *rw_sem;
++++        struct lock *rw_lock;
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+++new file mode 100644
+++index 0000000..d98aeb7
+++--- /dev/null
++++++ b/kern/include/synch.h~
+++@@ -0,0 +1,161 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _SYNCH_H_
++++#define _SYNCH_H_
++++
++++/*
++++ * Header file for synchronization primitives.
++++ */
++++
++++
++++#include <spinlock.h>
++++
++++/*
++++ * Dijkstra-style semaphore.
++++ *
++++ * The name field is for easier debugging. A copy of the name is made
++++ * internally.
++++ */
++++struct semaphore {
++++        char *sem_name;
++++	struct wchan *sem_wchan;
++++	struct spinlock sem_lock;
++++        volatile int sem_count;
++++};
++++
++++struct semaphore *sem_create(const char *name, int initial_count);
++++void sem_destroy(struct semaphore *);
++++
++++/*
++++ * Operations (both atomic):
++++ *     P (proberen): decrement count. If the count is 0, block until
++++ *                   the count is 1 again before decrementing.
++++ *     V (verhogen): increment count.
++++ */
++++void P(struct semaphore *);
++++void V(struct semaphore *);
++++
++++
++++/*
++++ * Simple lock for mutual exclusion.
++++ *
++++ * When the lock is created, no thread should be holding it. Likewise,
++++ * when the lock is destroyed, no thread should be holding it.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++struct lock {
++++        char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct lock *lock_create(const char *name);
++++void lock_acquire(struct lock *);
++++
++++/*
++++ * Operations:
++++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++++ *                   same time.
++++ *    lock_release - Free the lock. Only the thread holding the lock may do
++++ *                   this.
++++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++++ *                   false otherwise.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void lock_release(struct lock *);
++++bool lock_do_i_hold(struct lock *);
++++void lock_destroy(struct lock *);
++++
++++
++++/*
++++ * Condition variable.
++++ *
++++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++++ * to wait until a variable meets a particular condition, but there's no
++++ * actual variable, as such, in the CV.
++++ *
++++ * These CVs are expected to support Mesa semantics, that is, no
++++ * guarantees are made about scheduling.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++
++++struct cv {
++++        char *cv_name;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct cv *cv_create(const char *name);
++++void cv_destroy(struct cv *);
++++
++++/*
++++ * Operations:
++++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++++ *                   waking up again, re-acquire the lock.
++++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++++ *
++++ * For all three operations, the current thread must hold the lock passed 
++++ * in. Note that under normal circumstances the same lock should be used
++++ * on all operations with any particular CV.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void cv_wait(struct cv *cv, struct lock *lock);
++++void cv_signal(struct cv *cv, struct lock *lock);
++++void cv_broadcast(struct cv *cv, struct lock *lock);
++++
++++/*
++++ * 13 Feb 2012 : GWA : Reader-writer locks.
++++ */
++++
++++struct rwlock {
++++        char *rwlock_name;
++++};
++++
++++struct rwlock * rwlock_create(const char *);
++++void rwlock_destroy(struct rwlock *);
++++
++++void rwlock_acquire_read(struct rwlock *);
++++void rwlock_release_read(struct rwlock *);
++++void rwlock_acquire_write(struct rwlock *);
++++void rwlock_release_write(struct rwlock *);
++++
++++#endif /* _SYNCH_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..ea96700 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -26,6 +26,7 @@
+++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++  * SUCH DAMAGE.
+++  */
++++#include<thread.h>
+++ 
+++ #ifndef _SYSCALL_H_
+++ #define _SYSCALL_H_
+++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+++  * Support functions.
+++  */
+++ 
++++
+++ /* Helper for fork(). You write this. */
+++-void enter_forked_process(struct trapframe *tf);
++++void enter_forked_process(void *tf,unsigned long adrspace);
+++ 
+++ /* Enter user mode. Does not return. */
+++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++++int sys_execv(char* progname,char** arguments);
++++int sys_getpid(pid_t *retval);
++++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++++void sys_exit(int exitcode);
++++int mywait(struct process* mypro);
+++ 
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/test.h b/kern/include/test.h
+++index 240d583..84f60fc 100644
+++--- a/kern/include/test.h
++++++ b/kern/include/test.h
+++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+++ int nettest(int, char **);
+++ 
+++ /* Routine for running a user-level program. */
+++-int runprogram(char *progname);
++++int runprogram(char *progname,char** argv,unsigned long argc);
+++ 
+++ /* Kernel menu system. */
+++ void menu(char *argstr);
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..77a3515 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -73,7 +73,10 @@ struct thread {
+++ 	 */
+++ 	char *t_name;			/* Name of this thread */
+++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+++-	threadstate_t t_state;		/* State this thread is in */
++++	threadstate_t t_state;
++++	/* State this thread is in */
++++
++++	pid_t pid;
+++ 
+++ 	/*
+++ 	 * Thread subsystem internal fields.
+++@@ -104,7 +107,7 @@ struct thread {
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++-
++++	struct process* proc;
+++ 	/* VM */
+++ 	struct addrspace *t_addrspace;	/* virtual address space */
+++ 
+++@@ -112,6 +115,19 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
++++};
++++
++++struct process {
++++	int full;
++++	pid_t pid;
++++    pid_t ppid;
++++    //struct semaphore* exitsem;
++++    struct lock* tlock;
++++    struct cv* wcv;
++++    bool exited;
++++    int exitcode;
++++    struct thread* self;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..4d8e7e2 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -100,7 +100,7 @@ boot(void)
+++ 	kprintf("%s", harvard_copyright);
+++ 	kprintf("\n");
+++ 
+++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++ 		GROUP_VERSION, buildconfig, buildversion);
+++ 	kprintf("\n");
+++ 
+++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+++new file mode 100644
+++index 0000000..4d8e7e2
+++--- /dev/null
++++++ b/kern/startup/main.c~
+++@@ -0,0 +1,211 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Main.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/reboot.h>
++++#include <kern/unistd.h>
++++#include <lib.h>
++++#include <spl.h>
++++#include <clock.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++#include <vm.h>
++++#include <mainbus.h>
++++#include <vfs.h>
++++#include <device.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <version.h>
++++#include "autoconf.h"  // for pseudoconfig
++++
++++
++++/*
++++ * These two pieces of data are maintained by the makefiles and build system.
++++ * buildconfig is the name of the config file the kernel was configured with.
++++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++++ *
++++ * The purpose is not to show off how many kernels you've linked, but
++++ * to make it easy to make sure that the kernel you just booted is the
++++ * same one you just built.
++++ */
++++extern const int buildversion;
++++extern const char buildconfig[];
++++
++++/*
++++ * Copyright message for the OS/161 base code.
++++ */
++++static const char harvard_copyright[] =
++++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++++
++++
++++/*
++++ * Initial boot sequence.
++++ */
++++static
++++void
++++boot(void)
++++{
++++	/*
++++	 * The order of these is important!
++++	 * Don't go changing it without thinking about the consequences.
++++	 *
++++	 * Among other things, be aware that console output gets
++++	 * buffered up at first and does not actually appear until
++++	 * mainbus_bootstrap() attaches the console device. This can
++++	 * be remarkably confusing if a bug occurs at this point. So
++++	 * don't put new code before mainbus_bootstrap if you don't
++++	 * absolutely have to.
++++	 *
++++	 * Also note that the buffer for this is only 1k. If you
++++	 * overflow it, the system will crash without printing
++++	 * anything at all. You can make it larger though (it's in
++++	 * dev/generic/console.c).
++++	 */
++++
++++	kprintf("\n");
++++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++++	kprintf("%s", harvard_copyright);
++++	kprintf("\n");
++++
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++++		GROUP_VERSION, buildconfig, buildversion);
++++	kprintf("\n");
++++
++++	/* Early initialization. */
++++	ram_bootstrap();
++++	thread_bootstrap();
++++	hardclock_bootstrap();
++++	vfs_bootstrap();
++++
++++	/* Probe and initialize devices. Interrupts should come on. */
++++	kprintf("Device probe...\n");
++++	KASSERT(curthread->t_curspl > 0);
++++	mainbus_bootstrap();
++++	KASSERT(curthread->t_curspl == 0);
++++	/* Now do pseudo-devices. */
++++	pseudoconfig();
++++	kprintf("\n");
++++
++++	/* Late phase of initialization. */
++++	vm_bootstrap();
++++	kprintf_bootstrap();
++++	thread_start_cpus();
++++
++++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++++	vfs_setbootfs("emu0");
++++
++++
++++	/*
++++	 * Make sure various things aren't screwed up.
++++	 */
++++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++++}
++++
++++/*
++++ * Shutdown sequence. Opposite to boot().
++++ */
++++static
++++void
++++shutdown(void)
++++{
++++
++++	kprintf("Shutting down.\n");
++++	
++++	vfs_clearbootfs();
++++	vfs_clearcurdir();
++++	vfs_unmountall();
++++
++++	thread_shutdown();
++++
++++	splhigh();
++++}
++++
++++/*****************************************/
++++
++++/*
++++ * reboot() system call.
++++ *
++++ * Note: this is here because it's directly related to the code above,
++++ * not because this is where system call code should go. Other syscall
++++ * code should probably live in the "syscall" directory.
++++ */
++++int
++++sys_reboot(int code)
++++{
++++	switch (code) {
++++	    case RB_REBOOT:
++++	    case RB_HALT:
++++	    case RB_POWEROFF:
++++		break;
++++	    default:
++++		return EINVAL;
++++	}
++++
++++	shutdown();
++++
++++	switch (code) {
++++	    case RB_HALT:
++++		kprintf("The system is halted.\n");
++++		mainbus_halt();
++++		break;
++++	    case RB_REBOOT:
++++		kprintf("Rebooting...\n");
++++		mainbus_reboot();
++++		break;
++++	    case RB_POWEROFF:
++++		kprintf("The system is halted.\n");
++++		mainbus_poweroff();
++++		break;
++++	}
++++
++++	panic("reboot operation failed\n");
++++	return 0;
++++}
++++
++++/*
++++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++++ * request, and then shut down.
++++ */
++++void
++++kmain(char *arguments)
++++{
++++	boot();
++++
++++	menu(arguments);
++++
++++	/* Should not get here */
++++}
+++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+++index 6c71551..a4c2750 100644
+++--- a/kern/startup/menu.c
++++++ b/kern/startup/menu.c
+++@@ -40,9 +40,13 @@
+++ #include <sfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include<thread.h>
++++#include<synch.h>
+++ #include "opt-synchprobs.h"
+++ #include "opt-sfs.h"
+++ #include "opt-net.h"
++++#include <copyinout.h>
++++//#include "proc_sys.c"
+++ 
+++ /*
+++  * In-kernel menu and command dispatcher.
+++@@ -51,6 +55,7 @@
+++ #define _PATH_SHELL "/bin/sh"
+++ 
+++ #define MAXMENUARGS  16
++++extern struct process* p_table[17];
+++ 
+++ // XXX this should not be in this file
+++ void
+++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+++ 
+++ 	strcpy(progname, args[0]);
+++ 
+++-	result = runprogram(progname);
++++	result = runprogram(progname,args,nargs);
+++ 	if (result) {
+++ 		kprintf("Running program %s failed: %s\n", args[0],
+++ 			strerror(result));
+++@@ -127,6 +132,8 @@ int
+++ common_prog(int nargs, char **args)
+++ {
+++ 	int result;
++++	struct thread* fthread;
++++	//int err;
+++ 
+++ #if OPT_SYNCHPROBS
+++ 	kprintf("Warning: this probably won't work with a "
+++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+++ 	result = thread_fork(args[0] /* thread name */,
+++ 			cmd_progthread /* thread function */,
+++ 			args /* thread arg */, nargs /* thread arg */,
+++-			NULL);
++++			&fthread);
++++	//fthread->
++++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++++
++++	fthread->pid=PID_MIN;
++++	fthread->proc->pid=PID_MIN;
++++
++++	fthread->proc->self=fthread;
++++	fthread->proc->wcv=cv_create("First CV");
++++	fthread->proc->tlock=lock_create("First Lock");
++++	p_table[0]=fthread->proc;
++++
++++	lock_acquire(p_table[0]->tlock);
++++	mywait(p_table[0]);
++++	lock_release(p_table[0]->tlock);
++++
++++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++
++++	//fthread->proc->
++++	//while(!p_table[0]->exited)
++++
++++
+++ 	if (result) {
+++ 		kprintf("thread_fork failed: %s\n", strerror(result));
+++ 		return result;
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..6c0bb3f 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -43,11 +43,25 @@
+++  * You should implement your solution to the whalemating problem below.
+++  */
+++ 
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++-// the top of the corresponding driver code.
++++// the top of the corresponding driver code
++++
++++struct semaphore *male_sem;
++++struct semaphore *female_sem;
++++struct lock *hold;
++++struct cv* mate_cv;
++++volatile int male_count;
++++volatile int female_count;
+++ 
+++ void whalemating_init() {
++++ hold=lock_create("My lock");
++++ male_sem=sem_create("Male Semaphore",0);
++++ female_sem=sem_create("Female Semaphore",0);
++++mate_cv=cv_create("mating cv");
++++male_count=0;
++++female_count=0;
+++   return;
+++ }
+++ 
+++@@ -55,6 +69,11 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++
++++	sem_destroy(male_sem);
++++	sem_destroy(female_sem);
++++	lock_destroy(hold);
++++	cv_destroy(mate_cv);
+++   return;
+++ }
+++ 
+++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+++   (void)which;
+++   
+++   male_start();
++++
++++  lock_acquire(hold);
++++
++++  V(male_sem);
++++  male_count++;
++++  if(female_count!=0)
++++  cv_signal(mate_cv,hold);
++++  else
++++	  cv_wait(mate_cv,hold);
++++  lock_release(hold);
++++
+++ 	// Implement this function 
+++   male_end();
+++ 
+++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
++++  lock_acquire(hold);
++++   V(female_sem);
++++   female_count++;
++++   if(male_count!=0)
++++   cv_signal(mate_cv,hold);
++++   else
++++	   cv_wait(mate_cv,hold);
++++  lock_release(hold);
+++ 	// Implement this function 
+++   female_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
++++  lock_acquire(hold);
++++ P(male_sem);
++++ male_count--;
++++ lock_release(hold);
++++ lock_acquire(hold);
++++  P(female_sem);
++++  female_count--;
++++  lock_release(hold);
+++ 	// Implement this function 
+++   matchmaker_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
++++
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
++++struct lock* intersect_lock;
++++struct cv* intersect_cv;
++++volatile int cur_poss[4];// an array to store the possible positions of the car
++++//currently
+++ 
+++ void stoplight_init() {
++++	intersect_cv=cv_create("Intersection Condition Variable");
++++	if(intersect_cv==NULL)
++++	{
++++		///return NULL;
++++		panic("condition variable not created");
++++	}
++++	intersect_lock=lock_create("A lock on the intersection");
++++	if(intersect_lock==NULL)
++++	{
++++		//return NULL;
++++		panic("Lock could not be created");
++++	}
++++	
++++	
+++   return;
+++ }
+++ 
+++@@ -145,6 +210,8 @@ void stoplight_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
++++	cv_destroy(intersect_cv);
++++	lock_destroy(intersect_lock);
+++   return;
+++ }
+++ 
+++@@ -152,8 +219,29 @@ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++  //(void)direction;
++++	int sec_quad=(direction+3)%4;
++++	lock_acquire(intersect_lock);
++++	// So while any of the two possible quadrants are already set, It means some 
++++	//thread is waiting...Hopefully
++++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++++		cv_wait(intersect_cv,intersect_lock);
++++	cur_poss[direction]=1;
++++	cur_poss[sec_quad]=1;
++++	inQuadrant(direction);
++++	lock_release(intersect_lock);
++++	lock_acquire(intersect_lock);
++++    cur_poss[direction]=0;
++++    //while(curr_p)
++++    //cv_broadcast(intersect_cv);
++++    inQuadrant(sec_quad);
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++    cur_poss[sec_quad]=0;
++++    leaveIntersection();
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
++++  int sec_quad=(direction+3)%4;
++++  int third_quad=(direction+2)%4;
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  cur_poss[sec_quad]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++  lock_acquire(intersect_lock);
++++  cur_poss[direction]=0;
+++   
++++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++++  //cv_wait(intersect_cv,intersect_lock);
++++      cur_poss[third_quad]=1;
++++      //while(curr_p)
++++      //cv_broadcast(intersect_cv);
++++      inQuadrant(sec_quad);
++++      cv_broadcast(intersect_cv,intersect_lock);
++++      lock_release(intersect_lock);
++++        lock_acquire(intersect_lock);
++++            //currposs[direction]=0;
++++            cur_poss[sec_quad]=0;
++++            //while(curr_p)
++++            //cv_broadcast(intersect_cv);
++++            inQuadrant(third_quad);
++++            cv_broadcast(intersect_cv,intersect_lock);
++++                //cur_poss[third_quad]=0;
++++            lock_release(intersect_lock);
++++              lock_acquire(intersect_lock);
++++                leaveIntersection();
++++                cur_poss[third_quad]=0;
++++                cv_broadcast(intersect_cv,intersect_lock);
++++                lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
+++-
++++  // Easy coz the vehicle is in same lane!!
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++  leaveIntersection();
++++  cur_poss[direction]=0;
++++  cv_broadcast(intersect_cv,intersect_lock);
++++  lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+++new file mode 100644
+++index 0000000..c8d768b
+++--- /dev/null
++++++ b/kern/syscall/proc_sys.c
+++@@ -0,0 +1,741 @@
++++/*
++++
++++ * proc_sys.c
++++ *
++++ *  Created on: Mar 7, 2014
++++ *      Author: trinity
++++ */
++++
++++#include <types.h>
++++#include<mips/trapframe.h>
++++#include <kern/errno.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <addrspace.h>
++++#include <vm.h>
++++#include <vfs.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <file.h>
++++#include <synch.h>
++++#include<copyinout.h>
++++#include <spl.h>
++++#include<kern/wait.h>
++++
++++extern struct process* p_table[17];
++++
++++//struct cv* wcv;
++++
++++extern pid_t pidcount;
++++int mywait(struct process* mypro)
++++{
++++	//lock_acquire(mypro->tlock);
++++	while(!mypro->exited)
++++	{
++++		cv_wait(mypro->wcv,mypro->tlock);
++++	}
++++	//*status=mypro->exitcode;
++++	//lock_release(mypro->tlock);
++++	//int test = mypro->exitcode;
++++	//test++;
++++	return 0;
++++}
++++
++++
++++int sys_fork(struct trapframe* tf,unsigned long adrs,int *retval)
++++{
++++	(void)adrs;
++++	int flag;
++++	pid_t childid;
++++	struct addrspace *adrcopy;
++++	struct trapframe* copyt=(struct trapframe*) kmalloc(sizeof(struct trapframe));
++++	bzero(copyt,sizeof(struct trapframe));
++++
++++	//struct filetable* copyft;
++++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++++
++++	memcpy(copyt,tf,sizeof(struct trapframe));
++++	flag=as_copy(curthread->t_addrspace,&adrcopy);
++++	//if(curthread->pid==0)
++++	//{
++++		//curthread->pid=PID_MIN;
++++	//}
++++    if(flag)
++++    {
++++    	kfree(copyt);
++++    	return flag;
++++    }
++++
++++    //we need to allocate pid for our new process
++++
++++    //pid_t cpid;
++++    for(childid=0;childid<=16;childid++)
++++    {
++++     if(p_table[childid]==NULL)
++++     {
++++    	p_table[childid]=(struct process*)kmalloc(sizeof(struct process));
++++    	p_table[childid]->full=1;
++++    	pidcount++;
++++    	p_table[childid]->pid=pidcount;
++++    	p_table[childid]->ppid=curthread->pid;
++++    	//p_table[childid]->exitsem=sem_create("process",0);
++++    	p_table[childid]->tlock=lock_create("My Lock");
++++    	p_table[childid]->wcv=cv_create("My CV");
++++    	p_table[childid]->self=NULL;
++++    	break;
++++     }
++++    }
++++    if(childid>PID_MAX)
++++    {
++++    	*retval=1;
++++    	return EMPROC;
++++    }
++++    //int i;
++++
++++    copyt->tf_a0=(int)p_table[childid]->pid;
++++    //kprintf("Ret:%d\n",copyt->tf_a0);
++++    struct thread *new_proc;
++++    //curthread->t_addrspace=(struct addrspace*)adrcopy;
++++    //int s=splhigh();
++++    flag=thread_fork("newproc",enter_forked_process,(void *)copyt,(unsigned long)adrcopy,&new_proc);
++++    //kprintf("Out of thread fork:%d\n",flag);
++++    if(flag)
++++    {
++++    	kfree(copyt);
++++    	as_destroy(adrcopy);
++++
++++    	return flag;
++++    }
++++
++++    //new_proc->pid=(pid_t)childid;
++++    //new_proc=p_table[childid];
++++
++++    new_proc->pid=p_table[childid]->pid;
++++    new_proc->proc=p_table[childid];
++++   // new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++++    //if (new_proc->t_filetable == NULL) {
++++    //return ENOMEM;
++++    //}
++++    p_table[childid]->self=new_proc;
++++
++++    //new_proc->pid=p_table[childid]->pid;
++++    //new_proc->proc->pid=p_table[childid]->pid;
++++    //kprintf("Child id in fork: %d\n",new_proc->pid);
++++
++++
++++   //kprintf("Child id:%d",new_proc->pid);
++++    //new_proc->t_filetable->
++++    //for(i=0;i<128;i++)
++++    //{
++++    flag=filetable_copy(&new_proc->t_filetable);
++++    //}
++++    //splx(s);
++++   // kprintf("Fork over!");
++++
++++    *retval=p_table[childid]->pid;
++++    //kprintf("Return val in fork:%d",*retval);
++++    return 0;
++++
++++    //flag=
++++     //flag=thread_fork=
++++}
++++
++++/*
++++
++++int sys_execv(char* progname,char** arguments,int *retval)
++++{
++++	int flag;
++++	int numargs;
++++	int addr;
++++	int i;
++++	// first we need to copy the program name to the kernel space
++++	// then we go for arguments. Path size unknown
++++
++++	size_t actual_size=0;
++++	char *namedes;
++++
++++
++++	if(progname==NULL)
++++	{
++++		return EFAULT;
++++	}
++++	if(progname=="")
++++	{
++++		return EINVAL;
++++	}
++++
++++
++++	namedes=(char*)kmalloc(PATH_MAX);
++++	flag=copyinstr((const_userptr_t)progname,namedes,PATH_MAX,&actual_size);
++++	if(flag!=0)
++++	{
++++		kfree(namedes);
++++		return flag;
++++	}
++++	//namedes[actual_size]
++++	if(strlen(namedes)==0)
++++	{
++++		*retval=1;
++++		return EISDIR;
++++	}
++++
++++
++++	// now we open file using vfs_open. Same as runprogram
++++	struct vnode* vn;
++++	flag=vfs_open(namedes,O_RDONLY,0,&vn);
++++	if(flag)
++++	{
++++		return flag;
++++	}
++++	actual_size=0;
++++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++++
++++	//char** kargv=(char**)kmalloc(sizeof(char));
++++	// get the number of arguments
++++	if(arguments==NULL)
++++	{
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++	flag=copyin((userptr_t)arguments,&addr,sizeof(int));
++++	if(flag)
++++	{
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++
++++	//check=wthread->exitcode;
++++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++++	//if(err)
++++	//{
++++	//	lock_release(p_table[i]->tlock);
++++		//return err;
++++	//}
++++
++++	numargs=0;
++++	while(arguments[numargs]!=NULL)
++++	{
++++		//kprintf("%");
++++		numargs=numargs+1;
++++	}
++++
++++	char** kargv=(char**)kmalloc(sizeof(char*)*numargs);
++++	int i;
++++	for(i=0;i<numargs;i++)
++++	{
++++		actual_size=0;
++++		kargv[i]=(char*)kmalloc(PATH_MAX);
++++		flag=copyinstr((userptr_t)arguments[i],kargv[i],PATH_MAX,&actual_size);
++++		if(flag)
++++		{
++++			kfree(kargv);
++++			kfree(namedes);
++++			return EFAULT;
++++		}
++++
++++	}
++++	actual_size=0;
++++
++++
++++	// same as runprogram
++++
++++	curthread->t_addrspace=as_create();
++++	if(curthread->t_addrspace==NULL)
++++	{
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	vaddr_t entrypoint, stackptr;
++++	as_activate(curthread->t_addrspace);
++++	flag = load_elf(vn, &entrypoint);
++++		if (flag) {
++++			// thread_exit destroys curthread->t_addrspace
++++			vfs_close(vn);
++++			return flag;
++++		}
++++
++++	vfs_close(vn);
++++
++++// now set up the user stack with the arguments
++++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++++		if (flag) {
++++			 //thread_exit destroys curthread->t_addrspace
++++			return flag;
++++		}
++++		//i=0;
++++
++++		for(i=numargs-1;i>=0;i--)
++++		{
++++			actual_size=0;
++++			int length=strlen(kargv[i])+1;
++++			//int length=strlen(kargv[i]);
++++			int padder=length%4;
++++			if(padder!=0)
++++			length=length+padder;
++++			copyoutstr(kargv[i],(userptr_t)stackptr,length,&actual_size);
++++			//stackptr=stackptr+length;
++++			stackptr=stackptr-length;
++++
++++
++++		}
++++		for(i = numargs; i >= 0; i--)
++++		{
++++		stackptr -= sizeof(vaddr_t);
++++		flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++		if(result)
++++		{
++++		for(j = 0; j < argc; j++)
++++		{
++++		kfree(kargv[j]);
++++		}
++++		kfree(kargv);
++++		kfree(filename);
++++		return result;
++++		}
++++		}
++++
++++		vaddr_t stackptrv[argc+1];
++++		for(i = argc-1; i >= 0; i--)
++++		{
++++		int len = strlen(kargv[i]);
++++		len++;
++++		int padding = len % 4;
++++		stackptr -= len + (4 - padding);
++++		result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
++++		if(result)
++++		{
++++		for(j = 0; j < argc; j++)
++++		{
++++		kfree(kargv[j]);
++++		}
++++		kfree(kargv);
++++		kfree(namedes);
++++		return flag;
++++		}
++++		stackptrv[i] = stackptr;
++++		}
++++		stackptrv[numargs] = 0;
++++		enter_new_process(numargs,(userptr_t)stackptr,
++++					  stackptr, entrypoint);
++++		//pt_getthread();
++++
++++
++++			//enter_new_process does not return.
++++			panic("enter_new_process returned\n");
++++			return EINVAL;
++++}
++++*/
++++
++++
++++
++++
++++
++++int
++++sys_execv(char *progname, char **argv)
++++{
++++struct vnode *v;
++++vaddr_t entrypoint, stackptr;
++++char **kargv;
++++int result;
++++int i;
++++int j;
++++int testAddress;
++++int argc = 0;
++++size_t actual;
++++
++++if(progname == NULL)
++++{
++++return EFAULT;
++++}
++++
++++char *filename = (char *)kmalloc(PATH_MAX);
++++result = copyinstr((const_userptr_t)progname, filename, (size_t)NAME_MAX, &actual);
++++if(result)
++++{
++++kfree(filename);
++++return result;
++++}
++++if(strlen(filename) == 0)
++++{
++++return EINVAL;
++++}
++++
++++if(argv != NULL)
++++{
++++/* test to see that argv is a valid address */
++++result = copyin((const_userptr_t)argv, &testAddress, sizeof(int));
++++if(result)
++++{
++++kfree(filename);
++++return result;
++++}
++++
++++/* Get argc */
++++while(argv[argc] != NULL)
++++{
++++argc++;
++++}
++++/* Create kargv and safely copy in string arguments. */
++++kargv = (char **)kmalloc(sizeof(char *) * argc);
++++for(i = 0; i < argc; i++)
++++{
++++kargv[i] = (char *)kmalloc(PATH_MAX);
++++result = copyinstr((const_userptr_t)argv[i], kargv[i], PATH_MAX, &actual);
++++if(result)
++++{
++++/* In here I'm just freeing the char *
++++* that I've already kmalloc'ed. Not sure
++++* if this is correct
++++*/
++++for(j = 0; j < i; j++)
++++{
++++kfree(kargv[j]);
++++}
++++kfree(kargv[i]);
++++kfree(kargv);
++++kfree(filename);
++++return result;
++++}
++++}
++++}
++++/* open the file with filename */
++++result = vfs_open(filename, O_RDONLY,0,&v);
++++if(result)
++++{
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++/* Destroy current address space */
++++if(curthread->t_addrspace)
++++{
++++as_destroy(curthread->t_addrspace);
++++curthread->t_addrspace = NULL;
++++}
++++
++++KASSERT(curthread->t_addrspace == NULL);
++++
++++/* Create new address space */
++++curthread->t_addrspace = as_create();
++++if(curthread->t_addrspace == NULL)
++++{
++++vfs_close(v);
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++
++++/* Activate the address space */
++++as_activate(curthread->t_addrspace);
++++
++++/* Load the executable. */
++++result = load_elf(v, &entrypoint);
++++if (result)
++++{
++++vfs_close(v);
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++/* Done with the file now. */
++++vfs_close(v);
++++
++++/* Define the user stack in the address space */
++++result = as_define_stack(curthread->t_addrspace, &stackptr);
++++if (result) {
++++if(argv != NULL)
++++{
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++return result;
++++}
++++
++++//if(argv != NULL)
++++//{
++++/* This hopefully safely copies from kargv into
++++* the user stack
++++*/
++++vaddr_t stackptrv[argc+1];
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(kargv[i]);
++++len++;
++++int padding = len % 4;
++++stackptr -= len + (4 - padding);
++++result = copyoutstr((const char *)kargv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++for(j = 0; j < argc; j++)
++++{
++++kfree(kargv[j]);
++++}
++++kfree(kargv);
++++kfree(filename);
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++
++++/* This copies the actual stack addresses of the arguments
++++* into the stack. Hopefully.
++++*/
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++for(j = 0; j < argc; j++)
++++{
++++kfree(kargv[j]);
++++}
++++kfree(kargv);
++++kfree(filename);
++++return result;
++++}
++++//}
++++
++++/* Free everything we have kmalloc'ed */
++++for(i = 0; i < argc; i++)
++++{
++++kfree(kargv[i]);
++++}
++++kfree(kargv);
++++}
++++kfree(filename);
++++
++++/* Warp to user mode */
++++//md_usermode(argc, (userptr_t)stackptr, stackptr, entrypoint);
++++enter_new_process(argc,(userptr_t)stackptr,
++++					  stackptr, entrypoint);
++++		//pt_getthread();
++++
++++/* md_usermode does not return */
++++panic("md_usermode returned\n");
++++return EINVAL;
++++}
++++
++++
++++
++++int sys_getpid(pid_t *retval)
++++{
++++	//kprintf("In get pid:%d\n",curthread->pid);
++++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++++
++++	*retval=curthread->proc->pid;
++++	return 0;
++++}
++++
++++int sys_waitpid(pid_t pid,int* status, int options,pid_t *retval)
++++{
++++	struct process* wthread=NULL;
++++	int check;
++++	int err;
++++	pid_t i;
++++	//kprintf("PID in wait pid:%d\n",pid);
++++	if(status==NULL)
++++		return EFAULT;
++++	if(options!=0)
++++		return EINVAL;
++++	if (pid==curthread->pid)
++++		return ECHILD;
++++	if (pid<PID_MIN||pid>PID_MAX)
++++		return ESRCH;
++++	if (status==NULL)
++++		return EFAULT;
++++	if(pid==curthread->proc->ppid)
++++		return ECHILD;
++++	//int *shit;
++++	//*shit=(int)&status;
++++	//kprintf("%d\n",*shit);
++++	//if(curthread->)
++++	//if(pid!=curthread->)
++++	//char* argv=(char*)(status);
++++	//int length=strlen(argv)+1;
++++				//int length=strlen(kargv[i])+1;
++++	//int padder=length%4;
++++	//kprintf("Hai:%d\n",padder);
++++	//if(padder!=0)
++++	//{
++++		//return EFAULT;
++++	//}
++++
++++
++++	//if()
++++
++++
++++	//char pathbuf[PATH_MAX];
++++	//int *buffer;
++++	//int result;
++++
++++		//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++++		//if (result) {
++++			//return result;
++++		//}
++++		//int addr=(int)&status;
++++		//kprintf("Status:%d\n",addr);
++++	//int *addr=&status;
++++	//if(addr%4!=0)
++++	//{
++++		//return EFAULT;
++++	//}
++++	//kprintf("Got Here\n");
++++	for(i=0;i<=16;i++)
++++	{
++++		if(p_table[i]!=NULL)
++++		{
++++		if(p_table[i]->pid==pid)
++++		{
++++			wthread=p_table[i];
++++			break;
++++		}
++++		}
++++	}
++++	if(wthread==NULL)
++++	{
++++		return ESRCH;
++++	}
++++	if(curthread->proc->pid!=wthread->ppid)
++++	return ECHILD;
++++	//panic("We are here");
++++
++++	lock_acquire(p_table[i]->tlock);
++++
++++	//while(!wthread->exited)
++++	//{
++++//
++++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++++	//}
++++	mywait(wthread);
++++
++++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++++	//kprintf("We are here!");
++++
++++	check=wthread->exitcode;
++++	err=copyout(&check,(userptr_t)status,sizeof(check));
++++	if(err)
++++	{
++++		lock_release(p_table[i]->tlock);
++++		return err;
++++	}
++++	//kprintf("Exit code After waiting:%d\n",*status);
++++	//kfree(p_table[i]->exitsem);
++++	//p_table[i]=NULL;
++++
++++	//panic("After kfree");
++++	//p_table[i]=NULL;
++++	lock_release(p_table[i]->tlock);
++++	//filetable_destroy(p_table[i]->self->t_filetable);
++++	//lock_destroy(p_table[i]->tlock);
++++	//cv_destroy(p_table[i]->wcv);
++++	//kfree(p_table[i]);
++++	p_table[i]=NULL;
++++
++++	*retval=pid;
++++	//panic("After dereferencing");
++++	return 0;
++++
++++
++++	//return -1;
++++	//return 0;
++++}
++++
++++void sys_exit(int exitcode)
++++{
++++pid_t pid=curthread->proc->pid;
++++pid_t i=PID_MIN;
++++struct process* ethread;
++++//pid_t parent;
++++//if(pid!=2)
++++//{
++++for(i=0;i<=16;i++)
++++{
++++	if(p_table[i]!=NULL)
++++	{
++++	if(p_table[i]->pid==pid)
++++	{
++++			ethread=p_table[i];
++++			break;
++++	}
++++	}
++++}
++++
++++//parent=ethread->ppid;
++++if(ethread!=NULL)
++++{
++++lock_acquire(ethread->tlock);
++++//kprintf("Exit code Before:%d\n",exitcode);
++++
++++ethread->exitcode=_MKWAIT_EXIT(exitcode);
++++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++++ethread->exited=1;
++++//p_table[i]=ethread;
++++cv_broadcast(ethread->wcv,ethread->tlock);
++++//kfree(curthread->t_filetable);
++++lock_release(ethread->tlock);
++++}
++++//}
++++i=0;
++++//
++++//kprintf("Before hanging");
++++//filetable_destroy(curthread->t_filetable);
++++//kfree(curthread->p);
++++
++++thread_exit();
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..ab0197b 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,8 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
++++#include<copyinout.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -52,7 +54,7 @@
+++  * Calls vfs_open on progname and thus may destroy it.
+++  */
+++ int
+++-runprogram(char *progname)
++++runprogram(char *progname,char**argv,unsigned long argc)
+++ {
+++ 	struct vnode *v;
+++ 	vaddr_t entrypoint, stackptr;
+++@@ -66,6 +68,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	curthread->t_filetable=NULL;
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++@@ -94,9 +103,39 @@ runprogram(char *progname)
+++ 		/* thread_exit destroys curthread->t_addrspace */
+++ 		return result;
+++ 	}
++++	vaddr_t stackptrv[argc+1];
++++int i;
++++size_t actual;
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(argv[i]);
++++len++;
++++int padding = len % 4;
++++stackptr -= len + (4 - padding);
++++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++return result;
++++}
++++}
++++
++++
++++
+++ 
+++ 	/* Warp to user mode. */
+++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++++	enter_new_process(argc, (userptr_t)stackptr,
+++ 			  stackptr, entrypoint);
+++ 	
+++ 	/* enter_new_process does not return. */
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..851f9ea 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -40,6 +40,8 @@
+++ #include <current.h>
+++ #include <synch.h>
+++ 
++++#define MAXREADERS 20;
++++
+++ ////////////////////////////////////////////////////////////
+++ //
+++ // Semaphore.
+++@@ -162,9 +164,17 @@ lock_create(const char *name)
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
+++-        // add stuff here as needed
+++-        
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
+++         return lock;
+++ }
+++ 
+++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+++ 
+++         // add stuff here as needed
+++         
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
+++         kfree(lock->lk_name);
+++         kfree(lock);
+++ }
+++@@ -183,26 +195,78 @@ void
+++ lock_acquire(struct lock *lock)
+++ {
+++         // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(&lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -225,7 +289,18 @@ cv_create(const char *name)
+++                 kfree(cv);
+++                 return NULL;
+++         }
+++-        
++++        cv->cv_wchan = wchan_create(cv->cv_name);
++++                	if (cv->cv_wchan == NULL) {
++++                		kfree(cv->cv_name);
++++                		kfree(cv);
++++                		return NULL;
++++                	}
++++
++++                	//spinlock_init(&cv->cv_lock);
++++                        //lock->hold = 0;
++++        		//lock->holder=NULL;
++++                //lock->=NULL
++++                return cv;
+++         // add stuff here as needed
+++         
+++         return cv;
+++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+++ 
+++         // add stuff here as needed
+++         
++++        //spinlock_cleanup(&cv->cv_lock);
++++        
++++        wchan_destroy(cv->cv_wchan);
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++ }
+++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	//KASSERT(lock_do_i_hold(lock));
++++	wchan_lock(cv->cv_wchan);
++++	lock_release(lock);
++++	
++++	wchan_sleep(cv->cv_wchan);
++++	lock_acquire(lock);
++++	
++++    // Write this
++++    //(void)cv;    // suppress warning until code gets written
++++    //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++         // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeone(cv->cv_wchan);
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeall(cv->cv_wchan);
++++		
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
++++}
++++
++++struct rwlock *rwlock_create(const char *name)
++++{
++++	struct rwlock *rw;
++++	rw=kmalloc(sizeof(struct rwlock));
++++	if(rw==NULL)
++++	{
++++		return NULL;
++++	}
++++	rw->rwlock_name=kstrdup(name);
++++	if(rw->rwlock_name==NULL)
++++	{
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++++	if(rw->rd_wchan==NULL)
++++	{
++++		kfree(rw->rwlock_name);
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++++		if(rw->wr_wchan==NULL)
++++		{
++++			kfree(rw->rwlock_name);
++++			kfree(rw);
++++			return NULL;
++++		}
++++		rw->rw_sem=sem_create("mysem",20);
++++		rw->rw_lock=lock_create("mylock");
++++	///rw->res_count=MAXREADERS;
++++	return rw;
++++	
++++}
++++void rwlock_destroy(struct rwlock *rw)
++++{
++++		KASSERT(rw != NULL);
++++		
++++		wchan_destroy(rw->rd_wchan);
++++		wchan_destroy(rw->wr_wchan);
++++		sem_destroy(rw->rw_sem);
++++		lock_destroy(rw->rw_lock);
++++	    kfree(rw->rwlock_name);
++++        kfree(rw);	
++++}
++++
++++void rwlock_acquire_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	P(rw->rw_sem);
++++	lock_release(rw->rw_lock);
++++}
++++void rwlock_release_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	V(rw->rw_sem);
++++	//lock_release(rw->rw_lock);
++++}
++++void rwlock_acquire_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	//rwlock->rw_sem->V();
++++	for(i=0;i<20;i++)
++++	{
++++	P(rw->rw_sem);
++++	}	
++++	lock_release(rw->rw_lock);
++++	
++++	
+++ }
++++void rwlock_release_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	for(i=0;i<20;i++)
++++	{
++++	V(rw->rw_sem);
++++	}	
++++	//lock_release(rw->rw_lock);
++++	
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+++new file mode 100644
+++index 0000000..b9680d1
+++--- /dev/null
++++++ b/kern/thread/synch.c~
+++@@ -0,0 +1,329 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Synchronization primitives.
++++ * The specifications of the functions are in synch.h.
++++ */
++++
++++#include <types.h>
++++#include <lib.h>
++++#include <spinlock.h>
++++#include <wchan.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Semaphore.
++++
++++struct semaphore *
++++sem_create(const char *name, int initial_count)
++++{
++++        struct semaphore *sem;
++++
++++        KASSERT(initial_count >= 0);
++++
++++        sem = kmalloc(sizeof(struct semaphore));
++++        if (sem == NULL) {
++++                return NULL;
++++        }
++++
++++        sem->sem_name = kstrdup(name);
++++        if (sem->sem_name == NULL) {
++++                kfree(sem);
++++                return NULL;
++++        }
++++
++++	sem->sem_wchan = wchan_create(sem->sem_name);
++++	if (sem->sem_wchan == NULL) {
++++		kfree(sem->sem_name);
++++		kfree(sem);
++++		return NULL;
++++	}
++++
++++	spinlock_init(&sem->sem_lock);
++++        sem->sem_count = initial_count;
++++
++++        return sem;
++++}
++++
++++void
++++sem_destroy(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	/* wchan_cleanup will assert if anyone's waiting on it */
++++	spinlock_cleanup(&sem->sem_lock);
++++	wchan_destroy(sem->sem_wchan);
++++        kfree(sem->sem_name);
++++        kfree(sem);
++++}
++++
++++void 
++++P(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++        /*
++++         * May not block in an interrupt handler.
++++         *
++++         * For robustness, always check, even if we can actually
++++         * complete the P without blocking.
++++         */
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++        while (sem->sem_count == 0) {
++++		/*
++++		 * Bridge to the wchan lock, so if someone else comes
++++		 * along in V right this instant the wakeup can't go
++++		 * through on the wchan until we've finished going to
++++		 * sleep. Note that wchan_sleep unlocks the wchan.
++++		 *
++++		 * Note that we don't maintain strict FIFO ordering of
++++		 * threads going through the semaphore; that is, we
++++		 * might "get" it on the first try even if other
++++		 * threads are waiting. Apparently according to some
++++		 * textbooks semaphores must for some reason have
++++		 * strict ordering. Too bad. :-)
++++		 *
++++		 * Exercise: how would you implement strict FIFO
++++		 * ordering?
++++		 */
++++		wchan_lock(sem->sem_wchan);
++++		spinlock_release(&sem->sem_lock);
++++                wchan_sleep(sem->sem_wchan);
++++
++++		spinlock_acquire(&sem->sem_lock);
++++        }
++++        KASSERT(sem->sem_count > 0);
++++        sem->sem_count--;
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++void
++++V(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++
++++        sem->sem_count++;
++++        KASSERT(sem->sem_count > 0);
++++	wchan_wakeone(sem->sem_wchan);
++++
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Lock.
++++
++++struct lock *
++++lock_create(const char *name)
++++{
++++        struct lock *lock;
++++
++++        lock = kmalloc(sizeof(struct lock));
++++        if (lock == NULL) {
++++                return NULL;
++++        }
++++
++++        lock->lk_name = kstrdup(name);
++++        if (lock->lk_name == NULL) {
++++                kfree(lock);
++++                return NULL;
++++        }
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
++++        return lock;
++++}
++++
++++void
++++lock_destroy(struct lock *lock)
++++{
++++        KASSERT(lock != NULL);
++++
++++        // add stuff here as needed
++++        
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
++++        kfree(lock->lk_name);
++++        kfree(lock);
++++}
++++
++++void
++++lock_acquire(struct lock *lock)
++++{
++++        // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
++++
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++lock_release(struct lock *lock)
++++{
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
++++        // Write this
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++bool
++++lock_do_i_hold(struct lock *lock)
++++{
++++        // Write this
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// CV
++++
++++
++++struct cv *
++++cv_create(const char *name)
++++{
++++        struct cv *cv;
++++
++++        cv = kmalloc(sizeof(struct cv));
++++        if (cv == NULL) {
++++                return NULL;
++++        }
++++
++++        cv->cv_name = kstrdup(name);
++++        if (cv->cv_name==NULL) {
++++                kfree(cv);
++++                return NULL;
++++        }
++++        
++++        // add stuff here as needed
++++        
++++        return cv;
++++}
++++
++++void
++++cv_destroy(struct cv *cv)
++++{
++++        KASSERT(cv != NULL);
++++
++++        // add stuff here as needed
++++        
++++        kfree(cv->cv_name);
++++        kfree(cv);
++++}
++++
++++void
++++cv_wait(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++        (void)cv;    // suppress warning until code gets written
++++        (void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_signal(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_broadcast(struct cv *cv, struct lock *lock)
++++{
++++	// Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..df129b9 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+++ 
+++ /* Used to wait for secondary CPUs to come online. */
+++ static struct semaphore *cpu_startup_sem;
++++pid_t pidcount;
++++struct process* p_table[17];
+++ 
+++ ////////////////////////////////////////////////////////////
+++ 
+++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -352,8 +357,15 @@ thread_bootstrap(void)
+++ {
+++ 	struct cpu *bootcpu;
+++ 	struct thread *bootthread;
++++	int i;
+++ 
+++ 	cpuarray_init(&allcpus);
++++	pidcount=PID_MIN;
++++
++++	for(i=0;i<=16;i++)
++++	{
++++		p_table[i]=NULL;
++++	}
+++ 
+++ 	/*
+++ 	 * Create the cpu structure for the bootup CPU, the one we're
+++@@ -365,6 +377,7 @@ thread_bootstrap(void)
+++ 	 */
+++ 	bootcpu = cpu_create(0);
+++ 	bootthread = bootcpu->c_curthread;
++++	//bootthread->pid=PID_MIN;
+++ 
+++ 	/*
+++ 	 * Initializing curcpu and curthread is machine-dependent
+++@@ -519,7 +532,7 @@ thread_fork(const char *name,
+++ 	 * for the spllower() that will be done releasing it.
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++-
++++	//newthread->pid=pidcount++;
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 	switch (newstate) {
+++ 	    case S_RUN:
+++ 		panic("Illegal S_RUN in thread_switch\n");
+++-		break;
+++ 	    case S_READY:
+++ 		thread_make_runnable(cur, true /*have lock*/);
+++ 		break;
+++@@ -799,6 +811,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
+++diff --git a/single10.patch b/single10.patch
+++new file mode 100644
+++index 0000000..2267436
+++--- /dev/null
++++++ b/single10.patch
+++@@ -0,0 +1,915 @@
++++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++++index 0f773bd..68c73ff 100644
++++--- a/kern/arch/mips/syscall/syscall.c
+++++++ b/kern/arch/mips/syscall/syscall.c
++++@@ -32,6 +32,7 @@
++++ #include <kern/syscall.h>
++++ #include <lib.h>
++++ #include <mips/trapframe.h>
+++++#include <copyinout.h>
++++ #include <thread.h>
++++ #include <current.h>
++++ #include <syscall.h>
++++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++++ {
++++ 	int callno;
++++ 	int32_t retval;
+++++        int32_t retvalv1 = 0;
+++++        int64_t retval64;
++++ 	int err;
+++++        int32_t stackarg1;
++++ 
++++ 	KASSERT(curthread != NULL);
++++ 	KASSERT(curthread->t_curspl == 0);
++++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++++ 		err = sys___time((userptr_t)tf->tf_a0,
++++ 				 (userptr_t)tf->tf_a1);
++++ 		break;
+++++            case SYS_open:
+++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_read:
+++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_write:
+++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++				&retval);
+++++		break;
+++++	    case SYS_close:
+++++		err = sys_close(tf->tf_a0);
+++++		break;
+++++	    case SYS_lseek:
+++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++++                                stackarg1, &retval64);
+++++                retval = retval64 >> 32;
+++++                retvalv1 = (int) retval64;
+++++		break;
+++++	    case SYS_dup2:
+++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
+++++	    case SYS_chdir:
+++++		err = sys_chdir((userptr_t)tf->tf_a0);
+++++		break;
+++++	    case SYS___getcwd:
+++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
++++ 
++++ 	    /* Add stuff here */
++++  
++++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++++ 	else {
++++ 		/* Success. */
++++ 		tf->tf_v0 = retval;
+++++                tf->tf_v1 = retvalv1;
++++ 		tf->tf_a3 = 0;      /* signal no error */
++++ 	}
++++ 	
++++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++++index d527f61..e1d7682 100644
++++--- a/kern/conf/conf.kern
+++++++ b/kern/conf/conf.kern
++++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++++ file      syscall/loadelf.c
++++ file      syscall/runprogram.c
++++ file      syscall/time_syscalls.c
+++++file      syscall/file_syscalls.c
+++++file      syscall/file.c
++++ 
++++ #
++++ # Startup and initialization
++++diff --git a/kern/include/file.h b/kern/include/file.h
++++new file mode 100644
++++index 0000000..2c63bc2
++++--- /dev/null
+++++++ b/kern/include/file.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Declarations for file handle and file table management.
+++++ * New for SOL2.
+++++ */
+++++
+++++#ifndef _FILE_H_
+++++#define _FILE_H_
+++++
+++++#include <limits.h>
+++++
+++++struct lock;
+++++struct vnode;
+++++
+++++/*** openfile section ***/
+++++
+++++/* 
+++++ * openfile struct 
+++++ * note that there's not too much to keep track of, since the vnode does most
+++++ * of that.  note that it does require synchronization, because a single
+++++ * openfile can be shared between processes (filetable inheritance).
+++++ */
+++++struct openfile {
+++++	struct vnode *of_vnode;
+++++	
+++++	struct lock *of_lock;
+++++	off_t of_offset;
+++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++++	int of_refcount;
+++++};
+++++
+++++/* opens a file (must be kernel pointers in the args) */
+++++int file_open(char *filename, int flags, int mode, int *retfd);
+++++
+++++/* closes a file */
+++++int file_close(int fd);
+++++
+++++
+++++/*** file table section ***/
+++++
+++++/*
+++++ * filetable struct
+++++ * just an array of open files.  nice and simple.  doesn't require
+++++ * synchronization, because a table can only be owned by a single process (on
+++++ * inheritance in fork, the table is copied).
+++++ */
+++++struct filetable {
+++++	struct openfile *ft_openfiles[OPEN_MAX];
+++++};
+++++
+++++/* these all have an implicit arg of the curthread's filetable */
+++++int filetable_init(const char *inpath, const char *outpath, 
+++++		   const char *errpath);
+++++int filetable_copy(struct filetable **copy);
+++++int filetable_placefile(struct openfile *file, int *fd);
+++++int filetable_findfile(int fd, struct openfile **file);
+++++int filetable_dup2file(int oldfd, int newfd);
+++++void filetable_destroy(struct filetable *ft);
+++++
+++++#endif /* _FILE_H_ */
++++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++++index befd3d8..f3a01ad 100644
++++--- a/kern/include/syscall.h
+++++++ b/kern/include/syscall.h
++++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++++  * Prototypes for IN-KERNEL entry points for system call implementations.
++++  */
++++ 
+++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_close(int fd);
+++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++++int sys_dup2(int oldfd, int newfd, int *retval);
+++++int sys_chdir(userptr_t path);
+++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++++
++++ int sys_reboot(int code);
++++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++ 
++++diff --git a/kern/include/thread.h b/kern/include/thread.h
++++index 86706ca..08b8f8c 100644
++++--- a/kern/include/thread.h
+++++++ b/kern/include/thread.h
++++@@ -112,6 +112,7 @@ struct thread {
++++ 	struct vnode *t_cwd;		/* current working directory */
++++ 
++++ 	/* add more here as needed */
+++++  struct filetable *t_filetable;
++++ };
++++ 
++++ /* Call once during system startup to allocate data structures. */
++++diff --git a/kern/include/uio.h b/kern/include/uio.h
++++index 5d97c48..c9124e8 100644
++++--- a/kern/include/uio.h
+++++++ b/kern/include/uio.h
++++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++++ void uio_kinit(struct iovec *, struct uio *,
++++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++++ 
+++++void uio_uinit(struct iovec *, struct uio *,
+++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++++
++++ 
++++ #endif /* _UIO_H_ */
++++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++++index 594fe96..83ea620 100644
++++--- a/kern/lib/uio.c
+++++++ b/kern/lib/uio.c
++++@@ -153,6 +153,7 @@ void
++++ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++++ {
+++++	KASSERT(u);
++++ 	iov->iov_kbase = kbuf;
++++ 	iov->iov_len = len;
++++ 	u->uio_iov = iov;
++++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	u->uio_rw = rw;
++++ 	u->uio_space = NULL;
++++ }
+++++
+++++void
+++++uio_uinit(struct iovec *iov, struct uio *u,
+++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++++{
+++++	KASSERT(u);
+++++	iov->iov_ubase = ubuf;
+++++	iov->iov_len = len;
+++++  u->uio_iov = iov;
+++++	u->uio_iovcnt = 1;
+++++	u->uio_offset = pos;
+++++	u->uio_resid = len;
+++++	u->uio_segflg = UIO_USERSPACE;
+++++	u->uio_rw = rw;
+++++	u->uio_space = curthread->t_addrspace;
+++++}
++++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++++new file mode 100644
++++index 0000000..dc5ffe5
++++--- /dev/null
+++++++ b/kern/syscall/file.c
++++@@ -0,0 +1,341 @@
+++++/*
+++++ * File handles and file tables.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++
+++++/*** openfile functions ***/
+++++
+++++/*
+++++ * file_open
+++++ * opens a file, places it in the filetable, sets RETFD to the file
+++++ * descriptor. the pointer arguments must be kernel pointers.
+++++ * NOTE -- the passed in filename must be a mutable string.
+++++ */
+++++int
+++++file_open(char *filename, int flags, int mode, int *retfd)
+++++{
+++++	struct vnode *vn;
+++++	struct openfile *file;
+++++	int result;
+++++	
+++++	result = vfs_open(filename, flags, mode, &vn);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	file = kmalloc(sizeof(struct openfile));
+++++	if (file == NULL) {
+++++		vfs_close(vn);
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* initialize the file struct */
+++++	file->of_lock = lock_create("file lock");
+++++	if (file->of_lock == NULL) {
+++++		vfs_close(vn);
+++++		kfree(file);
+++++		return ENOMEM;
+++++	}
+++++	file->of_vnode = vn;
+++++	file->of_offset = 0;
+++++	file->of_accmode = flags & O_ACCMODE;
+++++	file->of_refcount = 1;
+++++
+++++	/* vfs_open checks for invalid access modes */
+++++	KASSERT(file->of_accmode==O_RDONLY ||
+++++	        file->of_accmode==O_WRONLY ||
+++++	        file->of_accmode==O_RDWR);
+++++
+++++	/* place the file in the filetable, getting the file descriptor */
+++++	result = filetable_placefile(file, retfd);
+++++	if (result) {
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++		vfs_close(vn);
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * file_doclose
+++++ * shared code for file_close and filetable_destroy
+++++ */
+++++static
+++++int
+++++file_doclose(struct openfile *file)
+++++{
+++++	lock_acquire(file->of_lock);
+++++
+++++	/* if this is the last close of this file, free it up */
+++++	if (file->of_refcount == 1) {
+++++		vfs_close(file->of_vnode);
+++++		lock_release(file->of_lock);
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++	}
+++++	else {
+++++		KASSERT(file->of_refcount > 1);
+++++		file->of_refcount--;
+++++		lock_release(file->of_lock);
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * file_close
+++++ * knock off the refcount, freeing the memory if it goes to 0.
+++++ */
+++++int
+++++file_close(int fd)
+++++{
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* find the file in the filetable */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	result = file_doclose(file);
+++++	if (result) {
+++++		/* leave file open for possible retry */
+++++		return result;
+++++	}
+++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++
+++++	return 0;
+++++}
+++++
+++++/*** filetable functions ***/
+++++
+++++/* 
+++++ * filetable_init
+++++ * pretty straightforward -- allocate the space, initialize to NULL.
+++++ * note that the one careful thing is to open the std i/o in order to
+++++ * get
+++++ * stdin  == 0
+++++ * stdout == 1
+++++ * stderr == 2
+++++ */
+++++int
+++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++++{
+++++	/* the filenames come from the kernel; assume reasonable length */
+++++	char path[32];
+++++	int result;
+++++	int fd;
+++++
+++++	/* make sure we can fit these */
+++++	KASSERT(strlen(inpath) < sizeof(path));
+++++	KASSERT(strlen(outpath) < sizeof(path));
+++++	KASSERT(strlen(errpath) < sizeof(path));
+++++	
+++++	/* catch memory leaks, repeated calls */
+++++	KASSERT(curthread->t_filetable == NULL);
+++++
+++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++++	if (curthread->t_filetable == NULL) {
+++++		return ENOMEM;
+++++	}
+++++	
+++++	/* NULL-out the table */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++	}
+++++
+++++	/*
+++++	 * open the std fds.  note that the names must be copied into
+++++	 * the path buffer so that they're mutable.
+++++	 */
+++++	strcpy(path, inpath);
+++++	result = file_open(path, O_RDONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, outpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, errpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_copy
+++++ * again, pretty straightforward.  the subtle business here is that instead of
+++++ * copying the openfile structure, we just increment the refcount.  this means
+++++ * that openfile structs will, in fact, be shared between processes, as in
+++++ * Unix.
+++++ */
+++++int
+++++filetable_copy(struct filetable **copy)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int fd;
+++++
+++++	/* waste of a call, really */
+++++	if (ft == NULL) {
+++++		*copy = NULL;
+++++		return 0;
+++++	}
+++++	
+++++	*copy = kmalloc(sizeof(struct filetable));
+++++	
+++++	if (*copy == NULL) {
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* copy over the entries */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd] != NULL) {
+++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++++			ft->ft_openfiles[fd]->of_refcount++;
+++++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++++		} 
+++++		else {
+++++			(*copy)->ft_openfiles[fd] = NULL;
+++++		}
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_destroy
+++++ * closes the files in the file table, frees the table.
+++++ */
+++++void
+++++filetable_destroy(struct filetable *ft)
+++++{
+++++	int fd, result;
+++++
+++++	KASSERT(ft != NULL);
+++++
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd]) {
+++++			result = file_doclose(ft->ft_openfiles[fd]);
+++++			KASSERT(result==0);
+++++		}
+++++	}
+++++	
+++++	kfree(ft);
+++++}	
+++++
+++++/* 
+++++ * filetable_placefile
+++++ * finds the smallest available file descriptor, places the file at the point,
+++++ * sets FD to it.
+++++ */
+++++int
+++++filetable_placefile(struct openfile *file, int *fd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int i;
+++++	
+++++	for (i = 0; i < OPEN_MAX; i++) {
+++++		if (ft->ft_openfiles[i] == NULL) {
+++++			ft->ft_openfiles[i] = file;
+++++			*fd = i;
+++++			return 0;
+++++		}
+++++	}
+++++
+++++	return EMFILE;
+++++}
+++++
+++++/*
+++++ * filetable_findfile
+++++ * verifies that the file descriptor is valid and actually references an
+++++ * open file, setting the FILE to the file at that index if it's there.
+++++ */
+++++int
+++++filetable_findfile(int fd, struct openfile **file)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++
+++++	if (fd < 0 || fd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++	
+++++	*file = ft->ft_openfiles[fd];
+++++	if (*file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_dup2file
+++++ * verifies that both file descriptors are valid, and that the OLDFD is
+++++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++++ */
+++++int
+++++filetable_dup2file(int oldfd, int newfd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++
+++++	file = ft->ft_openfiles[oldfd];
+++++	if (file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++++	if (oldfd == newfd) {
+++++		return 0;
+++++	}
+++++
+++++	/* closes the newfd if it's open */
+++++	if (ft->ft_openfiles[newfd] != NULL) {
+++++		result = file_close(newfd);
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
+++++
+++++	/* up the refcount */
+++++	lock_acquire(file->of_lock);
+++++	file->of_refcount++;
+++++	lock_release(file->of_lock);
+++++
+++++	/* doesn't need to be synchronized because it's just changing the ft */
+++++	ft->ft_openfiles[newfd] = file;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++++new file mode 100644
++++index 0000000..8aa024c
++++--- /dev/null
+++++++ b/kern/syscall/file_syscalls.c
++++@@ -0,0 +1,270 @@
+++++/*
+++++ * File-related system call implementations.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <kern/seek.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++#include <copyinout.h>
+++++
+++++/*
+++++ * sys_open
+++++ * just copies in the filename, then passes work to file_open.
+++++ */
+++++int
+++++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++++{
+++++	char fname[PATH_MAX];
+++++	int result;
+++++
+++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return file_open(fname, flags, mode, retval);
+++++}
+++++
+++++/*
+++++ * sys_read
+++++ * translates the fd into its openfile, then calls VOP_READ.
+++++ */
+++++int
+++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* better be a valid file descriptor */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_WRONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++++  
+++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++++
+++++	/* does the read */
+++++	result = VOP_READ(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++	
+++++	/*
+++++	 * The amount read is the size of the buffer originally, minus
+++++	 * how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * sys_write
+++++ * translates the fd into its openfile, then calls VOP_WRITE.
+++++ */
+++++int
+++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_RDONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++++	
+++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++++
+++++	/* does the write */
+++++	result = VOP_WRITE(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	/*
+++++	 * the amount written is the size of the buffer originally,
+++++	 * minus how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_close
+++++ * just pass off the work to file_close.
+++++ */
+++++int
+++++sys_close(int fd)
+++++{
+++++	return file_close(fd);
+++++}
+++++
+++++/*
+++++ * sys_lseek
+++++ * translates the fd into its openfile, then based on the type of seek,
+++++ * figure out the new offset, try the seek, if that succeeds, update the
+++++ * openfile.
+++++ */
+++++int
+++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++++{
+++++	struct stat info;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++	
+++++	/* based on the type of seek, set the retval */ 
+++++	switch (whence) {
+++++	    case SEEK_SET:
+++++		*retval = offset;
+++++		break;
+++++	    case SEEK_CUR:
+++++		*retval = file->of_offset + offset;
+++++		break;
+++++	    case SEEK_END:
+++++		result = VOP_STAT(file->of_vnode, &info);
+++++		if (result) {
+++++			lock_release(file->of_lock);
+++++			return result;
+++++		}
+++++		*retval = info.st_size + offset;
+++++		break;
+++++	    default:
+++++		lock_release(file->of_lock);
+++++		return EINVAL;
+++++	}
+++++
+++++	/* try the seek -- if it fails, return */
+++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++	
+++++	/* success -- update the file structure */
+++++	file->of_offset = *retval;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_dup2
+++++ * just pass the work off to the filetable
+++++ */
+++++int
+++++sys_dup2(int oldfd, int newfd, int *retval)
+++++{
+++++	int result;
+++++
+++++	result = filetable_dup2file(oldfd, newfd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = newfd;
+++++	return 0;
+++++}
+++++
+++++/* really not "file" calls, per se, but might as well put it here */
+++++
+++++/*
+++++ * sys_chdir
+++++ * copyin the path and pass it off to vfs.
+++++ */
+++++int
+++++sys_chdir(userptr_t path)
+++++{
+++++	char pathbuf[PATH_MAX];
+++++	int result;
+++++	
+++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return vfs_chdir(pathbuf);
+++++}
+++++
+++++/*
+++++ * sys___getcwd
+++++ * just use vfs_getcwd.
+++++ */
+++++int
+++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	int result;
+++++  
+++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	result = vfs_getcwd(&useruio);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = buflen - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++++index a6f45c8..4ba181a 100644
++++--- a/kern/syscall/runprogram.c
+++++++ b/kern/syscall/runprogram.c
++++@@ -44,6 +44,7 @@
++++ #include <vfs.h>
++++ #include <syscall.h>
++++ #include <test.h>
+++++#include <file.h>
++++ 
++++ /*
++++  * Load program "progname" and start running it in usermode.
++++@@ -66,6 +67,13 @@ runprogram(char *progname)
++++ 
++++ 	/* We should be a new thread. */
++++ 	KASSERT(curthread->t_addrspace == NULL);
+++++	
+++++  if (curthread->t_filetable == NULL) {
+++++		result = filetable_init("con:", "con:", "con:");
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
++++ 
++++ 	/* Create a new address s
++\ No newline at end of file
++diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
++index 287a678..db31b89 100644
++--- a/user/testbin/badcall/bad_execv.c
+++++ b/user/testbin/badcall/bad_execv.c
++@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
++ 		return;
++ 	}
++ 
+++
++ 	rv = execv("/bin/true", args);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	exit(MAGIC_STATUS);
++diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
++index 809c68c..8eb69c3 100644
++--- a/user/testbin/badcall/bad_waitpid.c
+++++ b/user/testbin/badcall/bad_waitpid.c
++@@ -36,6 +36,7 @@
++ #include <unistd.h>
++ #include <errno.h>
++ #include <err.h>
+++#include<stdio.h>
++ 
++ #include "config.h"
++ #include "test.h"
++@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Hello:%d",(int)ptr);
++ 
++ 	rv = waitpid(pid, ptr, 0);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	waitpid(pid, &x, 0);
++ }
++ 
+++
++ static
++ void
++ wait_unaligned(void)
++@@ -85,13 +88,16 @@ wait_unaligned(void)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Aligned int:%d",&status);
++ 
++ 	/* start with proper integer alignment */
++ 	ptr = (char *)(&status[0]);
++-
+++	//printf("Aligned:%c\n",*ptr);
++ 	/* generate improper alignment on platforms with restrictions*/
++ 	ptr++;
++ 
+++	//Print("UnAligned:%c\n",*ptr);
+++
++ 	rv = waitpid(pid, (int *)ptr, 0);
++ 	report_survival(rv, errno, "wait with unaligned status");
++ 	if (rv<0) {
++diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
++new file mode 100644
++index 0000000..fe21882
++--- /dev/null
+++++ b/user/testbin/myforktest/Makefile
++@@ -0,0 +1,11 @@
+++# Makefile for forktest
+++
+++TOP=../../..
+++.include "$(TOP)/mk/os161.config.mk"
+++
+++PROG=myforktest
+++SRCS=myforktest.c
+++BINDIR=/testbin
+++
+++.include "$(TOP)/mk/os161.prog.mk"
+++
++diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
++new file mode 100644
++index 0000000..7bd6663
++--- /dev/null
+++++ b/user/testbin/myforktest/myforktest.c
++@@ -0,0 +1,33 @@
+++#include <unistd.h>
+++#include <string.h>
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <err.h>
+++
+++int main()
+++{
+++	int status;
+++	int pid;
+++	int childpid;
+++	int parent;
+++	int returnCode=fork();
+++
+++	if(returnCode==0)
+++	{
+++		childpid=getpid();
+++		printf("I am child:%d\n",childpid);
+++		return -10;
+++	}
+++	else
+++	{
+++		//printf("Return:%d",returnCode);
+++		//printf("Wait for child\n");
+++		parent=getpid();
+++		printf("I am parent:%d\n",parent);
+++		pid=waitpid(returnCode,&status,0);
+++		printf("Child id returned" "%d",pid);
+++		printf(" Return code: %d\n",status);
+++
+++	}
+++	return 0;
+++}
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/submitcr.patch b/submitcr.patch
new file mode 100644
index 0000000..f109c31
--- /dev/null
+++ b/submitcr.patch
@@ -0,0 +1,12595 @@
+diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
+index ff39633..72de946 100644
+--- a/kern/arch/mips/locore/trap.c
++++ b/kern/arch/mips/locore/trap.c
+@@ -114,7 +114,9 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
+ 
+ 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
+ 		code, sig, trapcodenames[code], epc, vaddr);
+-	panic("I don't know how to handle this\n");
++	sys_exit(0);
++	//panic("I don't know how to handle this\n");
++	//thread_exit();
+ }
+ 
+ /*
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..7d2eb52 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,49 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	//int flag;
++	//tf=(struct trapframe*)tf;
++	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++		//if(flag)
++		//{
++
++			//return flag;
++			//newtf.tf_v0=ENOMEM;
++			//newtf.tf_a3=1;
++		//}
++	curthread->t_addrspace=(struct addrspace*)adrspace;
++	as_activate(curthread->t_addrspace);
++	//tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	//int flag;
++	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	//if(flag)
++	//{
++		//newtf.tf_v0=ENOMEM;
++		//newtf.tf_a3=1;
++	//}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	//curthread->pid=newtf.tf_a0;
++
++
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..8cfaa94 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,34 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++	if(fthread->proc==NULL)
++		return ENOMEM;
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	if(fthread->proc->wcv==NULL)
++		return ENOMEM;
++	fthread->proc->tlock=lock_create("First Lock");
++	if(fthread->proc->tlock==NULL)
++		return ENOMEM;
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..c2d3ee2
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,499 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro) {
++	//lock_acquire(mypro->tlock);
++	while (!mypro->exited) {
++		cv_wait(mypro->wcv, mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++	(void) adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++			sizeof(struct trapframe));
++	if(copyt==NULL)
++		return ENOMEM;
++	bzero(copyt, sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt, tf, sizeof(struct trapframe));
++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++	if(flag)
++		return flag;
++	//if(curthread->pid==0)
++	//{
++	//curthread->pid=PID_MIN;
++	//}
++	if (flag) {
++		kfree(copyt);
++		return flag;
++	}
++
++	//we need to allocate pid for our new process
++
++	//pid_t cpid;
++	/*
++	for (childid = 0; childid <= 16; childid++) {
++		if (p_table[childid] == NULL ) {
++			p_table[childid] = (struct process*) kmalloc(
++					sizeof(struct process));
++			if(p_table[childid]==NULL)
++			{
++				return ENOMEM;
++			}
++			p_table[childid]->full = 1;
++			pidcount++;
++			p_table[childid]->pid = pidcount;
++			p_table[childid]->ppid = curthread->pid;
++			//p_table[childid]->exitsem=sem_create("process",0);
++			p_table[childid]->tlock = lock_create("My Lock");
++			if(p_table[childid]==NULL)
++			{
++				return ENOMEM;
++			}
++			p_table[childid]->wcv = cv_create("My CV");
++			if(p_table[childid]==NULL)
++				return ENOMEM;
++			p_table[childid]->self = NULL;
++			break;
++		}
++	}
++	if (childid > PID_MAX) {
++		//retval = 1;
++		return EMPROC;
++	}
++	*/
++	//int i;
++
++	//copyt->tf_a0 = (int) p_table[childid]->pid;
++	//kprintf("Ret:%d\n",copyt->tf_a0);
++	struct thread *new_proc;
++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++	//int s=splhigh();
++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++			(unsigned long) adrcopy, &new_proc);
++	//kprintf("Out of thread fork:%d\n",flag);
++	if (flag) {
++		kfree(copyt);
++		as_destroy(adrcopy);
++
++		return flag;
++	}
++
++
++	for (childid = 0; childid <= 16; childid++) {
++			if (p_table[childid] == NULL ) {
++				p_table[childid] = (struct process*) kmalloc(
++						sizeof(struct process));
++				if(p_table[childid]==NULL)
++				{
++					return ENOMEM;
++				}
++				p_table[childid]->full = 1;
++				pidcount++;
++				p_table[childid]->pid = pidcount;
++				p_table[childid]->ppid = curthread->pid;
++				//p_table[childid]->exitsem=sem_create("process",0);
++				p_table[childid]->tlock = lock_create("My Lock");
++				if(p_table[childid]==NULL)
++				{
++					return ENOMEM;
++				}
++				p_table[childid]->wcv = cv_create("My CV");
++				if(p_table[childid]==NULL)
++					return ENOMEM;
++				p_table[childid]->self = NULL;
++				break;
++			}
++		}
++		if (childid > PID_MAX) {
++			//*retval = 1;
++			return EMPROC;
++		}
++
++	//new_proc->pid=(pid_t)childid;
++	//new_proc=p_table[childid];
++
++	new_proc->pid = p_table[childid]->pid;
++	new_proc->proc = p_table[childid];
++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++	//if (new_proc->t_filetable == NULL) {
++	//return ENOMEM;
++	//}
++	p_table[childid]->self = new_proc;
++
++	//new_proc->pid=p_table[childid]->pid;
++	//new_proc->proc->pid=p_table[childid]->pid;
++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++
++	//kprintf("Child id:%d",new_proc->pid);
++	//new_proc->t_filetable->
++	//for(i=0;i<128;i++)
++	//{
++	flag = filetable_copy(&new_proc->t_filetable);
++	//}
++	//splx(s);
++	// kprintf("Fork over!");
++
++	*retval = p_table[childid]->pid;
++	//kprintf("Return val in fork:%d",*retval);
++	return 0;
++
++	//flag=
++	//flag=thread_fork=
++}
++
++int sys_execv(char *progname, char** arguments) {
++
++	int flag;
++	int numargs;
++	int addr;
++	int i;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size = 0;
++	char *namedes;
++
++	if (progname == NULL ) {
++		return EFAULT;
++	}
++	if (progname == "") {
++		return EINVAL;
++	}
++
++	namedes = (char*) kmalloc(PATH_MAX);
++	if(namedes==NULL)
++	{
++		return ENOMEM;
++	}
++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++			&actual_size);
++	if (flag != 0) {
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if (strlen(namedes) == 0) {
++		//*retval=1;
++		return EISDIR;
++	}
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++	if (flag) {
++		return flag;
++	}
++	actual_size = 0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++	if (arguments == NULL ) {
++		kfree(namedes);
++		return EFAULT;
++	}
++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++	if (flag) {
++		kfree(namedes);
++		return EFAULT;
++	}
++
++	//check=wthread->exitcode;
++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++	//if(err)
++	//{
++	//	lock_release(p_table[i]->tlock);
++	//return err;
++	//}
++
++	numargs = 0;
++	while (arguments[numargs] != NULL ) {
++		//kprintf("%");
++		numargs = numargs + 1;
++	}
++
++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++	//int i;
++	for (i = 0; i < numargs; i++) {
++		actual_size = 0;
++		kargv[i] = (char*) kmalloc(PATH_MAX);
++		if(kargv==NULL)
++			return ENOMEM;
++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++				&actual_size);
++		if (flag) {
++			kfree(kargv);
++			kfree(namedes);
++			return EFAULT;
++		}
++
++	}
++	actual_size = 0;
++
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace == NULL ) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++	if (flag) {
++		// thread_exit destroys curthread->t_addrspace
++		vfs_close(vn);
++		return flag;
++	}
++
++	vfs_close(vn);
++
++	// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (flag) {
++		//thread_exit destroys curthread->t_addrspace
++		return flag;
++	}
++
++	//i=0;
++	vaddr_t stackptrv[numargs + 1];
++	for (i = numargs - 1; i >= 0; i--) {
++		int len = strlen(kargv[i]);
++		int padder=0;
++		len++;// to account for string terminator
++		//if(len%4!=0)
++		padder = len % 4;
++		stackptr =stackptr-( len + (4-padder));
++
++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++				&actual_size);
++
++		if (flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return flag;
++		}
++
++		stackptrv[i] = stackptr;
++	}
++	stackptrv[numargs] = 0;
++
++	//This copies the actual stack addresses of the arguments
++	//* into the stack. Hopefully.
++
++	 for(i = numargs; i >= 0; i--)
++	 {
++	 stackptr -= sizeof(vaddr_t);
++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++
++	 if(flag)
++	 {
++	 kfree(kargv);
++	 kfree(namedes);
++	 return flag;
++	 }
++
++	 }
++
++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++	//pt_getthread();
++
++	//enter_new_process does not return.
++	panic("enter_new_process returned\n");
++	return EINVAL;
++
++}
++
++int sys_getpid(pid_t *retval) {
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval = curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++	struct process* wthread = NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if (status == NULL )
++		return EFAULT;
++	if (options != 0)
++		return EINVAL;
++	if (pid == curthread->pid)
++		return ECHILD;
++	if (pid < PID_MIN || pid > PID_MAX)
++		return ESRCH;
++	if (status == NULL )
++		return EFAULT;
++	if (pid == curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++	//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++	//return EFAULT;
++	//}
++
++	//if()
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++	//if (result) {
++	//return result;
++	//}
++	//int addr=(int)&status;
++	//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++	//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				wthread = p_table[i];
++				break;
++			}
++		}
++	}
++	if (wthread == NULL ) {
++		return ESRCH;
++	}
++	if (curthread->proc->pid != wthread->ppid)
++		return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check = wthread->exitcode;
++	err = copyout(&check, (userptr_t) status, sizeof(check));
++	if (err) {
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i] = NULL;
++
++	*retval = pid;
++	//panic("After dereferencing");
++	return 0;
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode) {
++	pid_t pid = curthread->proc->pid;
++	pid_t i = PID_MIN;
++	struct process* ethread;
++//pid_t parent;
++//if(pid!=2)
++//{
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				ethread = p_table[i];
++				break;
++			}
++		}
++	}
++
++//parent=ethread->ppid;
++	if (ethread != NULL ) {
++		lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++		ethread->exited = 1;
++//p_table[i]=ethread;
++		cv_broadcast(ethread->wcv, ethread->tlock);
++//kfree(curthread->t_filetable);
++		lock_release(ethread->tlock);
++	}
++//}
++	i = 0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++	thread_exit();
++}
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..6d6dc37 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,40 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++int padder=0;
++len++;
++if(len%4!=0)
++padder = len % 4;
++stackptr=stackptr-( len + (4-padder));
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..f3918ab 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,9 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++thread->t_filetable=NULL;
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +358,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +378,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +533,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -532,6 +546,7 @@ thread_fork(const char *name,
+ 	 * only with caution, because in general the child thread
+ 	 * might exit at any time.
+ 	 */
++
+ 	if (ret != NULL) {
+ 		*ret = newthread;
+ 	}
+@@ -589,7 +604,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +813,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..04fc72b
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,8279 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..dfd7b53
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,445 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro) {
+++	//lock_acquire(mypro->tlock);
+++	while (!mypro->exited) {
+++		cv_wait(mypro->wcv, mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+++	(void) adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt = (struct trapframe*) kmalloc(
+++			sizeof(struct trapframe));
+++	bzero(copyt, sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt, tf, sizeof(struct trapframe));
+++	flag = as_copy(curthread->t_addrspace, &adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++	//curthread->pid=PID_MIN;
+++	//}
+++	if (flag) {
+++		kfree(copyt);
+++		return flag;
+++	}
+++
+++	//we need to allocate pid for our new process
+++
+++	//pid_t cpid;
+++	for (childid = 0; childid <= 16; childid++) {
+++		if (p_table[childid] == NULL ) {
+++			p_table[childid] = (struct process*) kmalloc(
+++					sizeof(struct process));
+++			p_table[childid]->full = 1;
+++			pidcount++;
+++			p_table[childid]->pid = pidcount;
+++			p_table[childid]->ppid = curthread->pid;
+++			//p_table[childid]->exitsem=sem_create("process",0);
+++			p_table[childid]->tlock = lock_create("My Lock");
+++			p_table[childid]->wcv = cv_create("My CV");
+++			p_table[childid]->self = NULL;
+++			break;
+++		}
+++	}
+++	if (childid > PID_MAX) {
+++		*retval = 1;
+++		return EMPROC;
+++	}
+++	//int i;
+++
+++	copyt->tf_a0 = (int) p_table[childid]->pid;
+++	//kprintf("Ret:%d\n",copyt->tf_a0);
+++	struct thread *new_proc;
+++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+++	//int s=splhigh();
+++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+++			(unsigned long) adrcopy, &new_proc);
+++	//kprintf("Out of thread fork:%d\n",flag);
+++	if (flag) {
+++		kfree(copyt);
+++		as_destroy(adrcopy);
+++
+++		return flag;
+++	}
+++
+++	//new_proc->pid=(pid_t)childid;
+++	//new_proc=p_table[childid];
+++
+++	new_proc->pid = p_table[childid]->pid;
+++	new_proc->proc = p_table[childid];
+++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++	//if (new_proc->t_filetable == NULL) {
+++	//return ENOMEM;
+++	//}
+++	p_table[childid]->self = new_proc;
+++
+++	//new_proc->pid=p_table[childid]->pid;
+++	//new_proc->proc->pid=p_table[childid]->pid;
+++	//kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++	//kprintf("Child id:%d",new_proc->pid);
+++	//new_proc->t_filetable->
+++	//for(i=0;i<128;i++)
+++	//{
+++	flag = filetable_copy(&new_proc->t_filetable);
+++	//}
+++	//splx(s);
+++	// kprintf("Fork over!");
+++
+++	*retval = p_table[childid]->pid;
+++	//kprintf("Return val in fork:%d",*retval);
+++	return 0;
+++
+++	//flag=
+++	//flag=thread_fork=
+++}
+++
+++int sys_execv(char *progname, char** arguments) {
+++
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size = 0;
+++	char *namedes;
+++
+++	if (progname == NULL ) {
+++		return EFAULT;
+++	}
+++	if (progname == "") {
+++		return EINVAL;
+++	}
+++
+++	namedes = (char*) kmalloc(PATH_MAX);
+++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+++			&actual_size);
+++	if (flag != 0) {
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if (strlen(namedes) == 0) {
+++		//*retval=1;
+++		return EISDIR;
+++	}
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+++	if (flag) {
+++		return flag;
+++	}
+++	actual_size = 0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if (arguments == NULL ) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+++	if (flag) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++	//return err;
+++	//}
+++
+++	numargs = 0;
+++	while (arguments[numargs] != NULL ) {
+++		//kprintf("%");
+++		numargs = numargs + 1;
+++	}
+++
+++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+++	//int i;
+++	for (i = 0; i < numargs; i++) {
+++		actual_size = 0;
+++		kargv[i] = (char*) kmalloc(PATH_MAX);
+++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+++				&actual_size);
+++		if (flag) {
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size = 0;
+++
+++	curthread->t_addrspace = as_create();
+++	if (curthread->t_addrspace == NULL ) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++	if (flag) {
+++		// thread_exit destroys curthread->t_addrspace
+++		vfs_close(vn);
+++		return flag;
+++	}
+++
+++	vfs_close(vn);
+++
+++	// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++	if (flag) {
+++		//thread_exit destroys curthread->t_addrspace
+++		return flag;
+++	}
+++
+++	//i=0;
+++	vaddr_t stackptrv[numargs + 1];
+++	for (i = numargs - 1; i >= 0; i--) {
+++		int len = strlen(kargv[i]);
+++		int padder=0;
+++		len++;// to account for string terminator
+++		if(len%4!=0)
+++		padder = len % 4;
+++		stackptr =stackptr-(len + padder);
+++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+++				&actual_size);
+++
+++		if (flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return flag;
+++		}
+++
+++		stackptrv[i] = stackptr;
+++	}
+++	stackptrv[numargs] = 0;
+++
+++	//This copies the actual stack addresses of the arguments
+++	//* into the stack. Hopefully.
+++
+++	 for(i = numargs; i >= 0; i--)
+++	 {
+++	 stackptr -= sizeof(vaddr_t);
+++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++
+++	 if(flag)
+++	 {
+++	 kfree(kargv);
+++	 kfree(namedes);
+++	 return flag;
+++	 }
+++
+++	 }
+++
+++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+++	//pt_getthread();
+++
+++	//enter_new_process does not return.
+++	panic("enter_new_process returned\n");
+++	return EINVAL;
+++
+++}
+++
+++int sys_getpid(pid_t *retval) {
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval = curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+++	struct process* wthread = NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if (status == NULL )
+++		return EFAULT;
+++	if (options != 0)
+++		return EINVAL;
+++	if (pid == curthread->pid)
+++		return ECHILD;
+++	if (pid < PID_MIN || pid > PID_MAX)
+++		return ESRCH;
+++	if (status == NULL )
+++		return EFAULT;
+++	if (pid == curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++	//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++
+++	//if()
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++	//if (result) {
+++	//return result;
+++	//}
+++	//int addr=(int)&status;
+++	//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				wthread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++	if (wthread == NULL ) {
+++		return ESRCH;
+++	}
+++	if (curthread->proc->pid != wthread->ppid)
+++		return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check = wthread->exitcode;
+++	err = copyout(&check, (userptr_t) status, sizeof(check));
+++	if (err) {
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i] = NULL;
+++
+++	*retval = pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode) {
+++	pid_t pid = curthread->proc->pid;
+++	pid_t i = PID_MIN;
+++	struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				ethread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++
+++//parent=ethread->ppid;
+++	if (ethread != NULL ) {
+++		lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++		ethread->exited = 1;
+++//p_table[i]=ethread;
+++		cv_broadcast(ethread->wcv, ethread->tlock);
+++//kfree(curthread->t_filetable);
+++		lock_release(ethread->tlock);
+++	}
+++//}
+++	i = 0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++	thread_exit();
+++}
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..1ada408 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,40 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++int padder=0;
+++len++;
+++if(len%4!=0)
+++padder = len % 4;
+++stackptr=stackptr-(len + padder);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index 5b8099e..60108d3 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -798,6 +801,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..e07fb23
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,4058 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..33b99ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,11 +32,14 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <addrspace.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
+++ 
++++
+++ /*
+++  * System call dispatcher.
+++  *
+++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++                break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++			break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_fork:
++++	    	err=0;
++++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++++	    	break;
++++	    case SYS_execv:
++++	    	err=0;
++++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++++	    	break;
++++	    case SYS_getpid:
++++	    	err=0;
++++	    	err=sys_getpid(&retval);
++++	    	break;
++++	    case SYS_waitpid:
++++	    	err=0;
++++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++	    	//panic("Waitpid over");
++++	    	break;
++++	    case SYS__exit:
++++	    	sys_exit((int)tf->tf_a0);
++++	    	break;
++++
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+++  *
+++  * Thus, you can trash it and do things another way if you prefer.
+++  */
+++-void
+++-enter_forked_process(struct trapframe *tf)
++++//void
++++//enter_forked_process(struct trapframe *tf)
++++//{
++++	//(void)tf;
++++//}
++++
++++void enter_forked_process(void*tf,unsigned long adrspace)
+++ {
+++-	(void)tf;
++++	tf=(struct trapframe*)tf;
++++	struct trapframe newtf;
++++	int flag;
++++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++++	if(flag)
++++	{
++++		newtf.tf_v0=ENOMEM;
++++		newtf.tf_a3=1;
++++	}
++++
++++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++++	kfree(tf);
++++	//tf=NULL;
++++	//int flag;
++++
++++	curthread->pid=newtf.tf_a0;
++++
++++	as_activate(curthread->t_addrspace);
++++
++++
++++
++++	newtf.tf_v0=0;
++++	newtf.tf_a3=0;
++++	newtf.tf_epc+=4;
++++	mips_usermode(&newtf);
+++ }
+++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+++new file mode 100644
+++index 0000000..3e8d5b9
+++--- /dev/null
++++++ b/kern/arch/mips/syscall/syscall.c~
+++@@ -0,0 +1,165 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/syscall.h>
++++#include <lib.h>
++++#include <mips/trapframe.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <syscall.h>
++++
++++
++++/*
++++ * System call dispatcher.
++++ *
++++ * A pointer to the trapframe created during exception entry (in
++++ * exception.S) is passed in.
++++ *
++++ * The calling conventions for syscalls are as follows: Like ordinary
++++ * function calls, the first 4 32-bit arguments are passed in the 4
++++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++++ * unused.
++++ *
++++ * This much is the same as the calling conventions for ordinary
++++ * function calls. In addition, the system call number is passed in
++++ * the v0 register.
++++ *
++++ * On successful return, the return value is passed back in the v0
++++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++++ * function call, and additionally the a3 register is also set to 0 to
++++ * indicate success.
++++ *
++++ * On an error return, the error code is passed back in the v0
++++ * register, and the a3 register is set to 1 to indicate failure.
++++ * (Userlevel code takes care of storing the error code in errno and
++++ * returning the value -1 from the actual userlevel syscall function.
++++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++++ *
++++ * Upon syscall return the program counter stored in the trapframe
++++ * must be incremented by one instruction; otherwise the exception
++++ * return code will restart the "syscall" instruction and the system
++++ * call will repeat forever.
++++ *
++++ * If you run out of registers (which happens quickly with 64-bit
++++ * values) further arguments must be fetched from the user-level
++++ * stack, starting at sp+16 to skip over the slots for the
++++ * registerized values, with copyin().
++++ */
++++void
++++syscall(struct trapframe *tf)
++++{
++++	int callno;
++++	int32_t retval;
++++	int err;
++++
++++	KASSERT(curthread != NULL);
++++	KASSERT(curthread->t_curspl == 0);
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++
++++	callno = tf->tf_v0;
++++
++++	/*
++++	 * Initialize retval to 0. Many of the system calls don't
++++	 * really return a value, just 0 for success and -1 on
++++	 * error. Since retval is the value returned on success,
++++	 * initialize it to 0 by default; thus it's not necessary to
++++	 * deal with it except for calls that return other values, 
++++	 * like write.
++++	 */
++++
++++	retval = 0;
++++
++++	switch (callno) {
++++	    case SYS_reboot:
++++		err = sys_reboot(tf->tf_a0);
++++		break;
++++
++++	    case SYS___time:
++++		err = sys___time((userptr_t)tf->tf_a0,
++++				 (userptr_t)tf->tf_a1);
++++		break;
++++		
++++	    case SYS_open:
++++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++++	    break;
++++
++++	    /* Add stuff here */
++++ 
++++	    default:
++++		kprintf("Unknown syscall %d\n", callno);
++++		err = ENOSYS;
++++		break;
++++	}
++++
++++
++++	if (err) {
++++		/*
++++		 * Return the error code. This gets converted at
++++		 * userlevel to a return value of -1 and the error
++++		 * code in errno.
++++		 */
++++		tf->tf_v0 = err;
++++		tf->tf_a3 = 1;      /* signal an error */
++++	}
++++	else {
++++		/* Success. */
++++		tf->tf_v0 = retval;
++++		tf->tf_a3 = 0;      /* signal no error */
++++	}
++++	
++++	/*
++++	 * Now, advance the program counter, to avoid restarting
++++	 * the syscall over and over again.
++++	 */
++++	
++++	tf->tf_epc += 4;
++++
++++	/* Make sure the syscall code didn't forget to lower spl */
++++	KASSERT(curthread->t_curspl == 0);
++++	/* ...or leak any spinlocks */
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++}
++++
++++/*
++++ * Enter user mode for a newly forked process.
++++ *
++++ * This function is provided as a reminder. You need to write
++++ * both it and the code that calls it.
++++ *
++++ * Thus, you can trash it and do things another way if you prefer.
++++ */
++++void
++++enter_forked_process(struct trapframe *tf)
++++{
++++	(void)tf;
++++}
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..7d5df71 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,9 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
++++file	  syscall/proc_sys.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/limits.h b/kern/include/limits.h
+++index 01684c4..3a54e24 100644
+++--- a/kern/include/limits.h
++++++ b/kern/include/limits.h
+++@@ -48,5 +48,6 @@
+++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+++ #define OPEN_MAX        __OPEN_MAX
+++ #define IOV_MAX         __IOV_MAX
++++//#define OPEN_MAX        64
+++ 
+++ #endif /* _LIMITS_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..df9fe64 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,11 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        //struct spinlock cv_lock;
++++        struct wchan *cv_wchan;
++++        //volatile int hold;
++++        //struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ 
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int res_count;
++++        struct wchan *rd_wchan;
++++        struct wchan *wr_wchan;
++++        struct semaphore *rw_sem;
++++        struct lock *rw_lock;
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+++new file mode 100644
+++index 0000000..d98aeb7
+++--- /dev/null
++++++ b/kern/include/synch.h~
+++@@ -0,0 +1,161 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _SYNCH_H_
++++#define _SYNCH_H_
++++
++++/*
++++ * Header file for synchronization primitives.
++++ */
++++
++++
++++#include <spinlock.h>
++++
++++/*
++++ * Dijkstra-style semaphore.
++++ *
++++ * The name field is for easier debugging. A copy of the name is made
++++ * internally.
++++ */
++++struct semaphore {
++++        char *sem_name;
++++	struct wchan *sem_wchan;
++++	struct spinlock sem_lock;
++++        volatile int sem_count;
++++};
++++
++++struct semaphore *sem_create(const char *name, int initial_count);
++++void sem_destroy(struct semaphore *);
++++
++++/*
++++ * Operations (both atomic):
++++ *     P (proberen): decrement count. If the count is 0, block until
++++ *                   the count is 1 again before decrementing.
++++ *     V (verhogen): increment count.
++++ */
++++void P(struct semaphore *);
++++void V(struct semaphore *);
++++
++++
++++/*
++++ * Simple lock for mutual exclusion.
++++ *
++++ * When the lock is created, no thread should be holding it. Likewise,
++++ * when the lock is destroyed, no thread should be holding it.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++struct lock {
++++        char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct lock *lock_create(const char *name);
++++void lock_acquire(struct lock *);
++++
++++/*
++++ * Operations:
++++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++++ *                   same time.
++++ *    lock_release - Free the lock. Only the thread holding the lock may do
++++ *                   this.
++++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++++ *                   false otherwise.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void lock_release(struct lock *);
++++bool lock_do_i_hold(struct lock *);
++++void lock_destroy(struct lock *);
++++
++++
++++/*
++++ * Condition variable.
++++ *
++++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++++ * to wait until a variable meets a particular condition, but there's no
++++ * actual variable, as such, in the CV.
++++ *
++++ * These CVs are expected to support Mesa semantics, that is, no
++++ * guarantees are made about scheduling.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++
++++struct cv {
++++        char *cv_name;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct cv *cv_create(const char *name);
++++void cv_destroy(struct cv *);
++++
++++/*
++++ * Operations:
++++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++++ *                   waking up again, re-acquire the lock.
++++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++++ *
++++ * For all three operations, the current thread must hold the lock passed 
++++ * in. Note that under normal circumstances the same lock should be used
++++ * on all operations with any particular CV.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void cv_wait(struct cv *cv, struct lock *lock);
++++void cv_signal(struct cv *cv, struct lock *lock);
++++void cv_broadcast(struct cv *cv, struct lock *lock);
++++
++++/*
++++ * 13 Feb 2012 : GWA : Reader-writer locks.
++++ */
++++
++++struct rwlock {
++++        char *rwlock_name;
++++};
++++
++++struct rwlock * rwlock_create(const char *);
++++void rwlock_destroy(struct rwlock *);
++++
++++void rwlock_acquire_read(struct rwlock *);
++++void rwlock_release_read(struct rwlock *);
++++void rwlock_acquire_write(struct rwlock *);
++++void rwlock_release_write(struct rwlock *);
++++
++++#endif /* _SYNCH_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..ea96700 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -26,6 +26,7 @@
+++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++  * SUCH DAMAGE.
+++  */
++++#include<thread.h>
+++ 
+++ #ifndef _SYSCALL_H_
+++ #define _SYSCALL_H_
+++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+++  * Support functions.
+++  */
+++ 
++++
+++ /* Helper for fork(). You write this. */
+++-void enter_forked_process(struct trapframe *tf);
++++void enter_forked_process(void *tf,unsigned long adrspace);
+++ 
+++ /* Enter user mode. Does not return. */
+++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++++int sys_execv(char* progname,char** arguments);
++++int sys_getpid(pid_t *retval);
++++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++++void sys_exit(int exitcode);
++++int mywait(struct process* mypro);
+++ 
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/test.h b/kern/include/test.h
+++index 240d583..84f60fc 100644
+++--- a/kern/include/test.h
++++++ b/kern/include/test.h
+++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+++ int nettest(int, char **);
+++ 
+++ /* Routine for running a user-level program. */
+++-int runprogram(char *progname);
++++int runprogram(char *progname,char** argv,unsigned long argc);
+++ 
+++ /* Kernel menu system. */
+++ void menu(char *argstr);
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..77a3515 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -73,7 +73,10 @@ struct thread {
+++ 	 */
+++ 	char *t_name;			/* Name of this thread */
+++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+++-	threadstate_t t_state;		/* State this thread is in */
++++	threadstate_t t_state;
++++	/* State this thread is in */
++++
++++	pid_t pid;
+++ 
+++ 	/*
+++ 	 * Thread subsystem internal fields.
+++@@ -104,7 +107,7 @@ struct thread {
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++-
++++	struct process* proc;
+++ 	/* VM */
+++ 	struct addrspace *t_addrspace;	/* virtual address space */
+++ 
+++@@ -112,6 +115,19 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
++++};
++++
++++struct process {
++++	int full;
++++	pid_t pid;
++++    pid_t ppid;
++++    //struct semaphore* exitsem;
++++    struct lock* tlock;
++++    struct cv* wcv;
++++    bool exited;
++++    int exitcode;
++++    struct thread* self;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..4d8e7e2 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -100,7 +100,7 @@ boot(void)
+++ 	kprintf("%s", harvard_copyright);
+++ 	kprintf("\n");
+++ 
+++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++ 		GROUP_VERSION, buildconfig, buildversion);
+++ 	kprintf("\n");
+++ 
+++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+++new file mode 100644
+++index 0000000..4d8e7e2
+++--- /dev/null
++++++ b/kern/startup/main.c~
+++@@ -0,0 +1,211 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Main.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/reboot.h>
++++#include <kern/unistd.h>
++++#include <lib.h>
++++#include <spl.h>
++++#include <clock.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++#include <vm.h>
++++#include <mainbus.h>
++++#include <vfs.h>
++++#include <device.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <version.h>
++++#include "autoconf.h"  // for pseudoconfig
++++
++++
++++/*
++++ * These two pieces of data are maintained by the makefiles and build system.
++++ * buildconfig is the name of the config file the kernel was configured with.
++++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++++ *
++++ * The purpose is not to show off how many kernels you've linked, but
++++ * to make it easy to make sure that the kernel you just booted is the
++++ * same one you just built.
++++ */
++++extern const int buildversion;
++++extern const char buildconfig[];
++++
++++/*
++++ * Copyright message for the OS/161 base code.
++++ */
++++static const char harvard_copyright[] =
++++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++++
++++
++++/*
++++ * Initial boot sequence.
++++ */
++++static
++++void
++++boot(void)
++++{
++++	/*
++++	 * The order of these is important!
++++	 * Don't go changing it without thinking about the consequences.
++++	 *
++++	 * Among other things, be aware that console output gets
++++	 * buffered up at first and does not actually appear until
++++	 * mainbus_bootstrap() attaches the console device. This can
++++	 * be remarkably confusing if a bug occurs at this point. So
++++	 * don't put new code before mainbus_bootstrap if you don't
++++	 * absolutely have to.
++++	 *
++++	 * Also note that the buffer for this is only 1k. If you
++++	 * overflow it, the system will crash without printing
++++	 * anything at all. You can make it larger though (it's in
++++	 * dev/generic/console.c).
++++	 */
++++
++++	kprintf("\n");
++++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++++	kprintf("%s", harvard_copyright);
++++	kprintf("\n");
++++
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++++		GROUP_VERSION, buildconfig, buildversion);
++++	kprintf("\n");
++++
++++	/* Early initialization. */
++++	ram_bootstrap();
++++	thread_bootstrap();
++++	hardclock_bootstrap();
++++	vfs_bootstrap();
++++
++++	/* Probe and initialize devices. Interrupts should come on. */
++++	kprintf("Device probe...\n");
++++	KASSERT(curthread->t_curspl > 0);
++++	mainbus_bootstrap();
++++	KASSERT(curthread->t_curspl == 0);
++++	/* Now do pseudo-devices. */
++++	pseudoconfig();
++++	kprintf("\n");
++++
++++	/* Late phase of initialization. */
++++	vm_bootstrap();
++++	kprintf_bootstrap();
++++	thread_start_cpus();
++++
++++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++++	vfs_setbootfs("emu0");
++++
++++
++++	/*
++++	 * Make sure various things aren't screwed up.
++++	 */
++++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++++}
++++
++++/*
++++ * Shutdown sequence. Opposite to boot().
++++ */
++++static
++++void
++++shutdown(void)
++++{
++++
++++	kprintf("Shutting down.\n");
++++	
++++	vfs_clearbootfs();
++++	vfs_clearcurdir();
++++	vfs_unmountall();
++++
++++	thread_shutdown();
++++
++++	splhigh();
++++}
++++
++++/*****************************************/
++++
++++/*
++++ * reboot() system call.
++++ *
++++ * Note: this is here because it's directly related to the code above,
++++ * not because this is where system call code should go. Other syscall
++++ * code should probably live in the "syscall" directory.
++++ */
++++int
++++sys_reboot(int code)
++++{
++++	switch (code) {
++++	    case RB_REBOOT:
++++	    case RB_HALT:
++++	    case RB_POWEROFF:
++++		break;
++++	    default:
++++		return EINVAL;
++++	}
++++
++++	shutdown();
++++
++++	switch (code) {
++++	    case RB_HALT:
++++		kprintf("The system is halted.\n");
++++		mainbus_halt();
++++		break;
++++	    case RB_REBOOT:
++++		kprintf("Rebooting...\n");
++++		mainbus_reboot();
++++		break;
++++	    case RB_POWEROFF:
++++		kprintf("The system is halted.\n");
++++		mainbus_poweroff();
++++		break;
++++	}
++++
++++	panic("reboot operation failed\n");
++++	return 0;
++++}
++++
++++/*
++++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++++ * request, and then shut down.
++++ */
++++void
++++kmain(char *arguments)
++++{
++++	boot();
++++
++++	menu(arguments);
++++
++++	/* Should not get here */
++++}
+++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+++index 6c71551..a4c2750 100644
+++--- a/kern/startup/menu.c
++++++ b/kern/startup/menu.c
+++@@ -40,9 +40,13 @@
+++ #include <sfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include<thread.h>
++++#include<synch.h>
+++ #include "opt-synchprobs.h"
+++ #include "opt-sfs.h"
+++ #include "opt-net.h"
++++#include <copyinout.h>
++++//#include "proc_sys.c"
+++ 
+++ /*
+++  * In-kernel menu and command dispatcher.
+++@@ -51,6 +55,7 @@
+++ #define _PATH_SHELL "/bin/sh"
+++ 
+++ #define MAXMENUARGS  16
++++extern struct process* p_table[17];
+++ 
+++ // XXX this should not be in this file
+++ void
+++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+++ 
+++ 	strcpy(progname, args[0]);
+++ 
+++-	result = runprogram(progname);
++++	result = runprogram(progname,args,nargs);
+++ 	if (result) {
+++ 		kprintf("Running program %s failed: %s\n", args[0],
+++ 			strerror(result));
+++@@ -127,6 +132,8 @@ int
+++ common_prog(int nargs, char **args)
+++ {
+++ 	int result;
++++	struct thread* fthread;
++++	//int err;
+++ 
+++ #if OPT_SYNCHPROBS
+++ 	kprintf("Warning: this probably won't work with a "
+++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+++ 	result = thread_fork(args[0] /* thread name */,
+++ 			cmd_progthread /* thread function */,
+++ 			args /* thread arg */, nargs /* thread arg */,
+++-			NULL);
++++			&fthread);
++++	//fthread->
++++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++++
++++	fthread->pid=PID_MIN;
++++	fthread->proc->pid=PID_MIN;
++++
++++	fthread->proc->self=fthread;
++++	fthread->proc->wcv=cv_create("First CV");
++++	fthread->proc->tlock=lock_create("First Lock");
++++	p_table[0]=fthread->proc;
++++
++++	lock_acquire(p_table[0]->tlock);
++++	mywait(p_table[0]);
++++	lock_release(p_table[0]->tlock);
++++
++++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++
++++	//fthread->proc->
++++	//while(!p_table[0]->exited)
++++
++++
+++ 	if (result) {
+++ 		kprintf("thread_fork failed: %s\n", strerror(result));
+++ 		return result;
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..6c0bb3f 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -43,11 +43,25 @@
+++  * You should implement your solution to the whalemating problem below.
+++  */
+++ 
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++-// the top of the corresponding driver code.
++++// the top of the corresponding driver code
++++
++++struct semaphore *male_sem;
++++struct semaphore *female_sem;
++++struct lock *hold;
++++struct cv* mate_cv;
++++volatile int male_count;
++++volatile int female_count;
+++ 
+++ void whalemating_init() {
++++ hold=lock_create("My lock");
++++ male_sem=sem_create("Male Semaphore",0);
++++ female_sem=sem_create("Female Semaphore",0);
++++mate_cv=cv_create("mating cv");
++++male_count=0;
++++female_count=0;
+++   return;
+++ }
+++ 
+++@@ -55,6 +69,11 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++
++++	sem_destroy(male_sem);
++++	sem_destroy(female_sem);
++++	lock_destroy(hold);
++++	cv_destroy(mate_cv);
+++   return;
+++ }
+++ 
+++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+++   (void)which;
+++   
+++   male_start();
++++
++++  lock_acquire(hold);
++++
++++  V(male_sem);
++++  male_count++;
++++  if(female_count!=0)
++++  cv_signal(mate_cv,hold);
++++  else
++++	  cv_wait(mate_cv,hold);
++++  lock_release(hold);
++++
+++ 	// Implement this function 
+++   male_end();
+++ 
+++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
++++  lock_acquire(hold);
++++   V(female_sem);
++++   female_count++;
++++   if(male_count!=0)
++++   cv_signal(mate_cv,hold);
++++   else
++++	   cv_wait(mate_cv,hold);
++++  lock_release(hold);
+++ 	// Implement this function 
+++   female_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
++++  lock_acquire(hold);
++++ P(male_sem);
++++ male_count--;
++++ lock_release(hold);
++++ lock_acquire(hold);
++++  P(female_sem);
++++  female_count--;
++++  lock_release(hold);
+++ 	// Implement this function 
+++   matchmaker_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
++++
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
++++struct lock* intersect_lock;
++++struct cv* intersect_cv;
++++volatile int cur_poss[4];// an array to store the possible positions of the car
++++//currently
+++ 
+++ void stoplight_init() {
++++	intersect_cv=cv_create("Intersection Condition Variable");
++++	if(intersect_cv==NULL)
++++	{
++++		///return NULL;
++++		panic("condition variable not created");
++++	}
++++	intersect_lock=lock_create("A lock on the intersection");
++++	if(intersect_lock==NULL)
++++	{
++++		//return NULL;
++++		panic("Lock could not be created");
++++	}
++++	
++++	
+++   return;
+++ }
+++ 
+++@@ -145,6 +210,8 @@ void stoplight_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
++++	cv_destroy(intersect_cv);
++++	lock_destroy(intersect_lock);
+++   return;
+++ }
+++ 
+++@@ -152,8 +219,29 @@ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++  //(void)direction;
++++	int sec_quad=(direction+3)%4;
++++	lock_acquire(intersect_lock);
++++	// So while any of the two possible quadrants are already set, It means some 
++++	//thread is waiting...Hopefully
++++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++++		cv_wait(intersect_cv,intersect_lock);
++++	cur_poss[direction]=1;
++++	cur_poss[sec_quad]=1;
++++	inQuadrant(direction);
++++	lock_release(intersect_lock);
++++	lock_acquire(intersect_lock);
++++    cur_poss[direction]=0;
++++    //while(curr_p)
++++    //cv_broadcast(intersect_cv);
++++    inQuadrant(sec_quad);
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++    cur_poss[sec_quad]=0;
++++    leaveIntersection();
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
++++  int sec_quad=(direction+3)%4;
++++  int third_quad=(direction+2)%4;
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  cur_poss[sec_quad]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++  lock_acquire(intersect_lock);
++++  cur_poss[direction]=0;
+++   
++++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++++  //cv_wait(intersect_cv,intersect_lock);
++++      cur_poss[third_quad]=1;
++++      //while(curr_p)
++++      //cv_broadcast(intersect_cv);
++++      inQuadrant(sec_quad);
++++      cv_broadcast(intersect_cv,intersect_lock);
++++      lock_release(intersect_lock);
++++        lock_acquire(intersect_lock);
++++            //currposs[direction]=0;
++++            cur_poss[sec_quad]=0;
++++            //while(curr_p)
++++            //cv_broadcast(intersect_cv);
++++            inQuadrant(third_quad);
++++            cv_broadcast(intersect_cv,intersect_lock);
++++                //cur_poss[third_quad]=0;
++++            lock_release(intersect_lock);
++++              lock_acquire(intersect_lock);
++++                leaveIntersection();
++++                cur_poss[third_quad]=0;
++++                cv_broadcast(intersect_cv,intersect_lock);
++++                lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
+++-
++++  // Easy coz the vehicle is in same lane!!
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++  leaveIntersection();
++++  cur_poss[direction]=0;
++++  cv_broadcast(intersect_cv,intersect_lock);
++++  lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+++new file mode 100644
+++index 0000000..dfd7b53
+++--- /dev/null
++++++ b/kern/syscall/proc_sys.c
+++@@ -0,0 +1,445 @@
++++/*
++++
++++ * proc_sys.c
++++ *
++++ *  Created on: Mar 7, 2014
++++ *      Author: trinity
++++ */
++++
++++#include <types.h>
++++#include<mips/trapframe.h>
++++#include <kern/errno.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <addrspace.h>
++++#include <vm.h>
++++#include <vfs.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <file.h>
++++#include <synch.h>
++++#include<copyinout.h>
++++#include <spl.h>
++++#include<kern/wait.h>
++++
++++extern struct process* p_table[17];
++++
++++//struct cv* wcv;
++++
++++extern pid_t pidcount;
++++int mywait(struct process* mypro) {
++++	//lock_acquire(mypro->tlock);
++++	while (!mypro->exited) {
++++		cv_wait(mypro->wcv, mypro->tlock);
++++	}
++++	//*status=mypro->exitcode;
++++	//lock_release(mypro->tlock);
++++	//int test = mypro->exitcode;
++++	//test++;
++++	return 0;
++++}
++++
++++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++++	(void) adrs;
++++	int flag;
++++	pid_t childid;
++++	struct addrspace *adrcopy;
++++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++++			sizeof(struct trapframe));
++++	bzero(copyt, sizeof(struct trapframe));
++++
++++	//struct filetable* copyft;
++++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++++
++++	memcpy(copyt, tf, sizeof(struct trapframe));
++++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++++	//if(curthread->pid==0)
++++	//{
++++	//curthread->pid=PID_MIN;
++++	//}
++++	if (flag) {
++++		kfree(copyt);
++++		return flag;
++++	}
++++
++++	//we need to allocate pid for our new process
++++
++++	//pid_t cpid;
++++	for (childid = 0; childid <= 16; childid++) {
++++		if (p_table[childid] == NULL ) {
++++			p_table[childid] = (struct process*) kmalloc(
++++					sizeof(struct process));
++++			p_table[childid]->full = 1;
++++			pidcount++;
++++			p_table[childid]->pid = pidcount;
++++			p_table[childid]->ppid = curthread->pid;
++++			//p_table[childid]->exitsem=sem_create("process",0);
++++			p_table[childid]->tlock = lock_create("My Lock");
++++			p_table[childid]->wcv = cv_create("My CV");
++++			p_table[childid]->self = NULL;
++++			break;
++++		}
++++	}
++++	if (childid > PID_MAX) {
++++		*retval = 1;
++++		return EMPROC;
++++	}
++++	//int i;
++++
++++	copyt->tf_a0 = (int) p_table[childid]->pid;
++++	//kprintf("Ret:%d\n",copyt->tf_a0);
++++	struct thread *new_proc;
++++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++++	//int s=splhigh();
++++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++++			(unsigned long) adrcopy, &new_proc);
++++	//kprintf("Out of thread fork:%d\n",flag);
++++	if (flag) {
++++		kfree(copyt);
++++		as_destroy(adrcopy);
++++
++++		return flag;
++++	}
++++
++++	//new_proc->pid=(pid_t)childid;
++++	//new_proc=p_table[childid];
++++
++++	new_proc->pid = p_table[childid]->pid;
++++	new_proc->proc = p_table[childid];
++++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++++	//if (new_proc->t_filetable == NULL) {
++++	//return ENOMEM;
++++	//}
++++	p_table[childid]->self = new_proc;
++++
++++	//new_proc->pid=p_table[childid]->pid;
++++	//new_proc->proc->pid=p_table[childid]->pid;
++++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++++
++++	//kprintf("Child id:%d",new_proc->pid);
++++	//new_proc->t_filetable->
++++	//for(i=0;i<128;i++)
++++	//{
++++	flag = filetable_copy(&new_proc->t_filetable);
++++	//}
++++	//splx(s);
++++	// kprintf("Fork over!");
++++
++++	*retval = p_table[childid]->pid;
++++	//kprintf("Return val in fork:%d",*retval);
++++	return 0;
++++
++++	//flag=
++++	//flag=thread_fork=
++++}
++++
++++int sys_execv(char *progname, char** arguments) {
++++
++++	int flag;
++++	int numargs;
++++	int addr;
++++	int i;
++++	// first we need to copy the program name to the kernel space
++++	// then we go for arguments. Path size unknown
++++
++++	size_t actual_size = 0;
++++	char *namedes;
++++
++++	if (progname == NULL ) {
++++		return EFAULT;
++++	}
++++	if (progname == "") {
++++		return EINVAL;
++++	}
++++
++++	namedes = (char*) kmalloc(PATH_MAX);
++++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++++			&actual_size);
++++	if (flag != 0) {
++++		kfree(namedes);
++++		return flag;
++++	}
++++	//namedes[actual_size]
++++	if (strlen(namedes) == 0) {
++++		//*retval=1;
++++		return EISDIR;
++++	}
++++
++++	// now we open file using vfs_open. Same as runprogram
++++	struct vnode* vn;
++++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++++	if (flag) {
++++		return flag;
++++	}
++++	actual_size = 0;
++++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++++
++++	//char** kargv=(char**)kmalloc(sizeof(char));
++++	// get the number of arguments
++++	if (arguments == NULL ) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++++	if (flag) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++
++++	//check=wthread->exitcode;
++++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++++	//if(err)
++++	//{
++++	//	lock_release(p_table[i]->tlock);
++++	//return err;
++++	//}
++++
++++	numargs = 0;
++++	while (arguments[numargs] != NULL ) {
++++		//kprintf("%");
++++		numargs = numargs + 1;
++++	}
++++
++++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++++	//int i;
++++	for (i = 0; i < numargs; i++) {
++++		actual_size = 0;
++++		kargv[i] = (char*) kmalloc(PATH_MAX);
++++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++++				&actual_size);
++++		if (flag) {
++++			kfree(kargv);
++++			kfree(namedes);
++++			return EFAULT;
++++		}
++++
++++	}
++++	actual_size = 0;
++++
++++	curthread->t_addrspace = as_create();
++++	if (curthread->t_addrspace == NULL ) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	vaddr_t entrypoint, stackptr;
++++	as_activate(curthread->t_addrspace);
++++	flag = load_elf(vn, &entrypoint);
++++	if (flag) {
++++		// thread_exit destroys curthread->t_addrspace
++++		vfs_close(vn);
++++		return flag;
++++	}
++++
++++	vfs_close(vn);
++++
++++	// now set up the user stack with the arguments
++++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++++	if (flag) {
++++		//thread_exit destroys curthread->t_addrspace
++++		return flag;
++++	}
++++
++++	//i=0;
++++	vaddr_t stackptrv[numargs + 1];
++++	for (i = numargs - 1; i >= 0; i--) {
++++		int len = strlen(kargv[i]);
++++		int padder=0;
++++		len++;// to account for string terminator
++++		if(len%4!=0)
++++		padder = len % 4;
++++		stackptr =stackptr-(len + padder);
++++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++++				&actual_size);
++++
++++		if (flag)
++++		{
++++			kfree(kargv);
++++			kfree(namedes);
++++			return flag;
++++		}
++++
++++		stackptrv[i] = stackptr;
++++	}
++++	stackptrv[numargs] = 0;
++++
++++	//This copies the actual stack addresses of the arguments
++++	//* into the stack. Hopefully.
++++
++++	 for(i = numargs; i >= 0; i--)
++++	 {
++++	 stackptr -= sizeof(vaddr_t);
++++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++
++++	 if(flag)
++++	 {
++++	 kfree(kargv);
++++	 kfree(namedes);
++++	 return flag;
++++	 }
++++
++++	 }
++++
++++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++++	//pt_getthread();
++++
++++	//enter_new_process does not return.
++++	panic("enter_new_process returned\n");
++++	return EINVAL;
++++
++++}
++++
++++int sys_getpid(pid_t *retval) {
++++	//kprintf("In get pid:%d\n",curthread->pid);
++++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++++
++++	*retval = curthread->proc->pid;
++++	return 0;
++++}
++++
++++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++++	struct process* wthread = NULL;
++++	int check;
++++	int err;
++++	pid_t i;
++++	//kprintf("PID in wait pid:%d\n",pid);
++++	if (status == NULL )
++++		return EFAULT;
++++	if (options != 0)
++++		return EINVAL;
++++	if (pid == curthread->pid)
++++		return ECHILD;
++++	if (pid < PID_MIN || pid > PID_MAX)
++++		return ESRCH;
++++	if (status == NULL )
++++		return EFAULT;
++++	if (pid == curthread->proc->ppid)
++++		return ECHILD;
++++	//int *shit;
++++	//*shit=(int)&status;
++++	//kprintf("%d\n",*shit);
++++	//if(curthread->)
++++	//if(pid!=curthread->)
++++	//char* argv=(char*)(status);
++++	//int length=strlen(argv)+1;
++++	//int length=strlen(kargv[i])+1;
++++	//int padder=length%4;
++++	//kprintf("Hai:%d\n",padder);
++++	//if(padder!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++
++++	//if()
++++
++++	//char pathbuf[PATH_MAX];
++++	//int *buffer;
++++	//int result;
++++
++++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++++	//if (result) {
++++	//return result;
++++	//}
++++	//int addr=(int)&status;
++++	//kprintf("Status:%d\n",addr);
++++	//int *addr=&status;
++++	//if(addr%4!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++	//kprintf("Got Here\n");
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				wthread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++	if (wthread == NULL ) {
++++		return ESRCH;
++++	}
++++	if (curthread->proc->pid != wthread->ppid)
++++		return ECHILD;
++++	//panic("We are here");
++++
++++	lock_acquire(p_table[i]->tlock);
++++
++++	//while(!wthread->exited)
++++	//{
++++//
++++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++++	//}
++++	mywait(wthread);
++++
++++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++++	//kprintf("We are here!");
++++
++++	check = wthread->exitcode;
++++	err = copyout(&check, (userptr_t) status, sizeof(check));
++++	if (err) {
++++		lock_release(p_table[i]->tlock);
++++		return err;
++++	}
++++	//kprintf("Exit code After waiting:%d\n",*status);
++++	//kfree(p_table[i]->exitsem);
++++	//p_table[i]=NULL;
++++
++++	//panic("After kfree");
++++	//p_table[i]=NULL;
++++	lock_release(p_table[i]->tlock);
++++	//filetable_destroy(p_table[i]->self->t_filetable);
++++	//lock_destroy(p_table[i]->tlock);
++++	//cv_destroy(p_table[i]->wcv);
++++	//kfree(p_table[i]);
++++	p_table[i] = NULL;
++++
++++	*retval = pid;
++++	//panic("After dereferencing");
++++	return 0;
++++
++++	//return -1;
++++	//return 0;
++++}
++++
++++void sys_exit(int exitcode) {
++++	pid_t pid = curthread->proc->pid;
++++	pid_t i = PID_MIN;
++++	struct process* ethread;
++++//pid_t parent;
++++//if(pid!=2)
++++//{
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				ethread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++
++++//parent=ethread->ppid;
++++	if (ethread != NULL ) {
++++		lock_acquire(ethread->tlock);
++++//kprintf("Exit code Before:%d\n",exitcode);
++++
++++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++++		ethread->exited = 1;
++++//p_table[i]=ethread;
++++		cv_broadcast(ethread->wcv, ethread->tlock);
++++//kfree(curthread->t_filetable);
++++		lock_release(ethread->tlock);
++++	}
++++//}
++++	i = 0;
++++//
++++//kprintf("Before hanging");
++++//filetable_destroy(curthread->t_filetable);
++++//kfree(curthread->p);
++++
++++	thread_exit();
++++}
++++
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..1ada408 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,8 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
++++#include<copyinout.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -52,7 +54,7 @@
+++  * Calls vfs_open on progname and thus may destroy it.
+++  */
+++ int
+++-runprogram(char *progname)
++++runprogram(char *progname,char**argv,unsigned long argc)
+++ {
+++ 	struct vnode *v;
+++ 	vaddr_t entrypoint, stackptr;
+++@@ -66,6 +68,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	curthread->t_filetable=NULL;
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++@@ -94,9 +103,40 @@ runprogram(char *progname)
+++ 		/* thread_exit destroys curthread->t_addrspace */
+++ 		return result;
+++ 	}
++++	vaddr_t stackptrv[argc+1];
++++int i;
++++size_t actual;
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(argv[i]);
++++int padder=0;
++++len++;
++++if(len%4!=0)
++++padder = len % 4;
++++stackptr=stackptr-(len + padder);
++++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++return result;
++++}
++++}
++++
++++
++++
+++ 
+++ 	/* Warp to user mode. */
+++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++++	enter_new_process(argc, (userptr_t)stackptr,
+++ 			  stackptr, entrypoint);
+++ 	
+++ 	/* enter_new_process does not return. */
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..851f9ea 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -40,6 +40,8 @@
+++ #include <current.h>
+++ #include <synch.h>
+++ 
++++#define MAXREADERS 20;
++++
+++ ////////////////////////////////////////////////////////////
+++ //
+++ // Semaphore.
+++@@ -162,9 +164,17 @@ lock_create(const char *name)
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
+++-        // add stuff here as needed
+++-        
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
+++         return lock;
+++ }
+++ 
+++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+++ 
+++         // add stuff here as needed
+++         
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
+++         kfree(lock->lk_name);
+++         kfree(lock);
+++ }
+++@@ -183,26 +195,78 @@ void
+++ lock_acquire(struct lock *lock)
+++ {
+++         // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(&lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -225,7 +289,18 @@ cv_create(const char *name)
+++                 kfree(cv);
+++                 return NULL;
+++         }
+++-        
++++        cv->cv_wchan = wchan_create(cv->cv_name);
++++                	if (cv->cv_wchan == NULL) {
++++                		kfree(cv->cv_name);
++++                		kfree(cv);
++++                		return NULL;
++++                	}
++++
++++                	//spinlock_init(&cv->cv_lock);
++++                        //lock->hold = 0;
++++        		//lock->holder=NULL;
++++                //lock->=NULL
++++                return cv;
+++         // add stuff here as needed
+++         
+++         return cv;
+++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+++ 
+++         // add stuff here as needed
+++         
++++        //spinlock_cleanup(&cv->cv_lock);
++++        
++++        wchan_destroy(cv->cv_wchan);
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++ }
+++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	//KASSERT(lock_do_i_hold(lock));
++++	wchan_lock(cv->cv_wchan);
++++	lock_release(lock);
++++	
++++	wchan_sleep(cv->cv_wchan);
++++	lock_acquire(lock);
++++	
++++    // Write this
++++    //(void)cv;    // suppress warning until code gets written
++++    //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++         // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeone(cv->cv_wchan);
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeall(cv->cv_wchan);
++++		
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
++++}
++++
++++struct rwlock *rwlock_create(const char *name)
++++{
++++	struct rwlock *rw;
++++	rw=kmalloc(sizeof(struct rwlock));
++++	if(rw==NULL)
++++	{
++++		return NULL;
++++	}
++++	rw->rwlock_name=kstrdup(name);
++++	if(rw->rwlock_name==NULL)
++++	{
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++++	if(rw->rd_wchan==NULL)
++++	{
++++		kfree(rw->rwlock_name);
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++++		if(rw->wr_wchan==NULL)
++++		{
++++			kfree(rw->rwlock_name);
++++			kfree(rw);
++++			return NULL;
++++		}
++++		rw->rw_sem=sem_create("mysem",20);
++++		rw->rw_lock=lock_create("mylock");
++++	///rw->res_count=MAXREADERS;
++++	return rw;
++++	
++++}
++++void rwlock_destroy(struct rwlock *rw)
++++{
++++		KASSERT(rw != NULL);
++++		
++++		wchan_destroy(rw->rd_wchan);
++++		wchan_destroy(rw->wr_wchan);
++++		sem_destroy(rw->rw_sem);
++++		lock_destroy(rw->rw_lock);
++++	    kfree(rw->rwlock_name);
++++        kfree(rw);	
++++}
++++
++++void rwlock_acquire_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	P(rw->rw_sem);
++++	lock_release(rw->rw_lock);
++++}
++++void rwlock_release_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	V(rw->rw_sem);
++++	//lock_release(rw->rw_lock);
++++}
++++void rwlock_acquire_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	//rwlock->rw_sem->V();
++++	for(i=0;i<20;i++)
++++	{
++++	P(rw->rw_sem);
++++	}	
++++	lock_release(rw->rw_lock);
++++	
++++	
+++ }
++++void rwlock_release_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	for(i=0;i<20;i++)
++++	{
++++	V(rw->rw_sem);
++++	}	
++++	//lock_release(rw->rw_lock);
++++	
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+++new file mode 100644
+++index 0000000..b9680d1
+++--- /dev/null
++++++ b/kern/thread/synch.c~
+++@@ -0,0 +1,329 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Synchronization primitives.
++++ * The specifications of the functions are in synch.h.
++++ */
++++
++++#include <types.h>
++++#include <lib.h>
++++#include <spinlock.h>
++++#include <wchan.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Semaphore.
++++
++++struct semaphore *
++++sem_create(const char *name, int initial_count)
++++{
++++        struct semaphore *sem;
++++
++++        KASSERT(initial_count >= 0);
++++
++++        sem = kmalloc(sizeof(struct semaphore));
++++        if (sem == NULL) {
++++                return NULL;
++++        }
++++
++++        sem->sem_name = kstrdup(name);
++++        if (sem->sem_name == NULL) {
++++                kfree(sem);
++++                return NULL;
++++        }
++++
++++	sem->sem_wchan = wchan_create(sem->sem_name);
++++	if (sem->sem_wchan == NULL) {
++++		kfree(sem->sem_name);
++++		kfree(sem);
++++		return NULL;
++++	}
++++
++++	spinlock_init(&sem->sem_lock);
++++        sem->sem_count = initial_count;
++++
++++        return sem;
++++}
++++
++++void
++++sem_destroy(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	/* wchan_cleanup will assert if anyone's waiting on it */
++++	spinlock_cleanup(&sem->sem_lock);
++++	wchan_destroy(sem->sem_wchan);
++++        kfree(sem->sem_name);
++++        kfree(sem);
++++}
++++
++++void 
++++P(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++        /*
++++         * May not block in an interrupt handler.
++++         *
++++         * For robustness, always check, even if we can actually
++++         * complete the P without blocking.
++++         */
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++        while (sem->sem_count == 0) {
++++		/*
++++		 * Bridge to the wchan lock, so if someone else comes
++++		 * along in V right this instant the wakeup can't go
++++		 * through on the wchan until we've finished going to
++++		 * sleep. Note that wchan_sleep unlocks the wchan.
++++		 *
++++		 * Note that we don't maintain strict FIFO ordering of
++++		 * threads going through the semaphore; that is, we
++++		 * might "get" it on the first try even if other
++++		 * threads are waiting. Apparently according to some
++++		 * textbooks semaphores must for some reason have
++++		 * strict ordering. Too bad. :-)
++++		 *
++++		 * Exercise: how would you implement strict FIFO
++++		 * ordering?
++++		 */
++++		wchan_lock(sem->sem_wchan);
++++		spinlock_release(&sem->sem_lock);
++++                wchan_sleep(sem->sem_wchan);
++++
++++		spinlock_acquire(&sem->sem_lock);
++++        }
++++        KASSERT(sem->sem_count > 0);
++++        sem->sem_count--;
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++void
++++V(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++
++++        sem->sem_count++;
++++        KASSERT(sem->sem_count > 0);
++++	wchan_wakeone(sem->sem_wchan);
++++
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Lock.
++++
++++struct lock *
++++lock_create(const char *name)
++++{
++++        struct lock *lock;
++++
++++        lock = kmalloc(sizeof(struct lock));
++++        if (lock == NULL) {
++++                return NULL;
++++        }
++++
++++        lock->lk_name = kstrdup(name);
++++        if (lock->lk_name == NULL) {
++++                kfree(lock);
++++                return NULL;
++++        }
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
++++        return lock;
++++}
++++
++++void
++++lock_destroy(struct lock *lock)
++++{
++++        KASSERT(lock != NULL);
++++
++++        // add stuff here as needed
++++        
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
++++        kfree(lock->lk_name);
++++        kfree(lock);
++++}
++++
++++void
++++lock_acquire(struct lock *lock)
++++{
++++        // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
++++
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++lock_release(struct lock *lock)
++++{
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
++++        // Write this
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++bool
++++lock_do_i_hold(struct lock *lock)
++++{
++++        // Write this
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// CV
++++
++++
++++struct cv *
++++cv_create(const char *name)
++++{
++++        struct cv *cv;
++++
++++        cv = kmalloc(sizeof(struct cv));
++++        if (cv == NULL) {
++++                return NULL;
++++        }
++++
++++        cv->cv_name = kstrdup(name);
++++        if (cv->cv_name==NULL) {
++++                kfree(cv);
++++                return NULL;
++++        }
++++        
++++        // add stuff here as needed
++++        
++++        return cv;
++++}
++++
++++void
++++cv_destroy(struct cv *cv)
++++{
++++        KASSERT(cv != NULL);
++++
++++        // add stuff here as needed
++++        
++++        kfree(cv->cv_name);
++++        kfree(cv);
++++}
++++
++++void
++++cv_wait(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++        (void)cv;    // suppress warning until code gets written
++++        (void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_signal(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_broadcast(struct cv *cv, struct lock *lock)
++++{
++++	// Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..df129b9 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+++ 
+++ /* Used to wait for secondary CPUs to come online. */
+++ static struct semaphore *cpu_startup_sem;
++++pid_t pidcount;
++++struct process* p_table[17];
+++ 
+++ ////////////////////////////////////////////////////////////
+++ 
+++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -352,8 +357,15 @@ thread_bootstrap(void)
+++ {
+++ 	struct cpu *bootcpu;
+++ 	struct thread *bootthread;
++++	int i;
+++ 
+++ 	cpuarray_init(&allcpus);
++++	pidcount=PID_MIN;
++++
++++	for(i=0;i<=16;i++)
++++	{
++++		p_table[i]=NULL;
++++	}
+++ 
+++ 	/*
+++ 	 * Create the cpu structure for the bootup CPU, the one we're
+++@@ -365,6 +377,7 @@ thread_bootstrap(void)
+++ 	 */
+++ 	bootcpu = cpu_create(0);
+++ 	bootthread = bootcpu->c_curthread;
++++	//bootthread->pid=PID_MIN;
+++ 
+++ 	/*
+++ 	 * Initializing curcpu and curthread is machine-dependent
+++@@ -519,7 +532,7 @@ thread_fork(const char *name,
+++ 	 * for the spllower() that will be done releasing it.
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++-
++++	//newthread->pid=pidcount++;
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 	switch (newstate) {
+++ 	    case S_RUN:
+++ 		panic("Illegal S_RUN in thread_switch\n");
+++-		break;
+++ 	    case S_READY:
+++ 		thread_make_runnable(cur, true /*have lock*/);
+++ 		break;
+++@@ -799,6 +811,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
+++diff --git a/single10.patch b/single10.patch
+++new file mode 100644
+++index 0000000..2267436
+++--- /dev/null
++++++ b/single10.patch
+++@@ -0,0 +1,915 @@
++++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++++index 0f773bd..68c73ff 100644
++++--- a/kern/arch/mips/syscall/syscall.c
+++++++ b/kern/arch/mips/syscall/syscall.c
++++@@ -32,6 +32,7 @@
++++ #include <kern/syscall.h>
++++ #include <lib.h>
++++ #include <mips/trapframe.h>
+++++#include <copyinout.h>
++++ #include <thread.h>
++++ #include <current.h>
++++ #include <syscall.h>
++++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++++ {
++++ 	int callno;
++++ 	int32_t retval;
+++++        int32_t retvalv1 = 0;
+++++        int64_t retval64;
++++ 	int err;
+++++        int32_t stackarg1;
++++ 
++++ 	KASSERT(curthread != NULL);
++++ 	KASSERT(curthread->t_curspl == 0);
++++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++++ 		err = sys___time((userptr_t)tf->tf_a0,
++++ 				 (userptr_t)tf->tf_a1);
++++ 		break;
+++++            case SYS_open:
+++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_read:
+++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_write:
+++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++				&retval);
+++++		break;
+++++	    case SYS_close:
+++++		err = sys_close(tf->tf_a0);
+++++		break;
+++++	    case SYS_lseek:
+++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++++                                stackarg1, &retval64);
+++++                retval = retval64 >> 32;
+++++                retvalv1 = (int) retval64;
+++++		break;
+++++	    case SYS_dup2:
+++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
+++++	    case SYS_chdir:
+++++		err = sys_chdir((userptr_t)tf->tf_a0);
+++++		break;
+++++	    case SYS___getcwd:
+++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
++++ 
++++ 	    /* Add stuff here */
++++  
++++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++++ 	else {
++++ 		/* Success. */
++++ 		tf->tf_v0 = retval;
+++++                tf->tf_v1 = retvalv1;
++++ 		tf->tf_a3 = 0;      /* signal no error */
++++ 	}
++++ 	
++++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++++index d527f61..e1d7682 100644
++++--- a/kern/conf/conf.kern
+++++++ b/kern/conf/conf.kern
++++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++++ file      syscall/loadelf.c
++++ file      syscall/runprogram.c
++++ file      syscall/time_syscalls.c
+++++file      syscall/file_syscalls.c
+++++file      syscall/file.c
++++ 
++++ #
++++ # Startup and initialization
++++diff --git a/kern/include/file.h b/kern/include/file.h
++++new file mode 100644
++++index 0000000..2c63bc2
++++--- /dev/null
+++++++ b/kern/include/file.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Declarations for file handle and file table management.
+++++ * New for SOL2.
+++++ */
+++++
+++++#ifndef _FILE_H_
+++++#define _FILE_H_
+++++
+++++#include <limits.h>
+++++
+++++struct lock;
+++++struct vnode;
+++++
+++++/*** openfile section ***/
+++++
+++++/* 
+++++ * openfile struct 
+++++ * note that there's not too much to keep track of, since the vnode does most
+++++ * of that.  note that it does require synchronization, because a single
+++++ * openfile can be shared between processes (filetable inheritance).
+++++ */
+++++struct openfile {
+++++	struct vnode *of_vnode;
+++++	
+++++	struct lock *of_lock;
+++++	off_t of_offset;
+++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++++	int of_refcount;
+++++};
+++++
+++++/* opens a file (must be kernel pointers in the args) */
+++++int file_open(char *filename, int flags, int mode, int *retfd);
+++++
+++++/* closes a file */
+++++int file_close(int fd);
+++++
+++++
+++++/*** file table section ***/
+++++
+++++/*
+++++ * filetable struct
+++++ * just an array of open files.  nice and simple.  doesn't require
+++++ * synchronization, because a table can only be owned by a single process (on
+++++ * inheritance in fork, the table is copied).
+++++ */
+++++struct filetable {
+++++	struct openfile *ft_openfiles[OPEN_MAX];
+++++};
+++++
+++++/* these all have an implicit arg of the curthread's filetable */
+++++int filetable_init(const char *inpath, const char *outpath, 
+++++		   const char *errpath);
+++++int filetable_copy(struct filetable **copy);
+++++int filetable_placefile(struct openfile *file, int *fd);
+++++int filetable_findfile(int fd, struct openfile **file);
+++++int filetable_dup2file(int oldfd, int newfd);
+++++void filetable_destroy(struct filetable *ft);
+++++
+++++#endif /* _FILE_H_ */
++++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++++index befd3d8..f3a01ad 100644
++++--- a/kern/include/syscall.h
+++++++ b/kern/include/syscall.h
++++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++++  * Prototypes for IN-KERNEL entry points for system call implementations.
++++  */
++++ 
+++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_close(int fd);
+++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++++int sys_dup2(int oldfd, int newfd, int *retval);
+++++int sys_chdir(userptr_t path);
+++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++++
++++ int sys_reboot(int code);
++++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++ 
++++diff --git a/kern/include/thread.h b/kern/include/thread.h
++++index 86706ca..08b8f8c 100644
++++--- a/kern/include/thread.h
+++++++ b/kern/include/thread.h
++++@@ -112,6 +112,7 @@ struct thread {
++++ 	struct vnode *t_cwd;		/* current working directory */
++++ 
++++ 	/* add more here as needed */
+++++  struct filetable *t_filetable;
++++ };
++++ 
++++ /* Call once during system startup to allocate data structures. */
++++diff --git a/kern/include/uio.h b/kern/include/uio.h
++++index 5d97c48..c9124e8 100644
++++--- a/kern/include/uio.h
+++++++ b/kern/include/uio.h
++++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++++ void uio_kinit(struct iovec *, struct uio *,
++++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++++ 
+++++void uio_uinit(struct iovec *, struct uio *,
+++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++++
++++ 
++++ #endif /* _UIO_H_ */
++++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++++index 594fe96..83ea620 100644
++++--- a/kern/lib/uio.c
+++++++ b/kern/lib/uio.c
++++@@ -153,6 +153,7 @@ void
++++ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++++ {
+++++	KASSERT(u);
++++ 	iov->iov_kbase = kbuf;
++++ 	iov->iov_len = len;
++++ 	u->uio_iov = iov;
++++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	u->uio_rw = rw;
++++ 	u->uio_space = NULL;
++++ }
+++++
+++++void
+++++uio_uinit(struct iovec *iov, struct uio *u,
+++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++++{
+++++	KASSERT(u);
+++++	iov->iov_ubase = ubuf;
+++++	iov->iov_len = len;
+++++  u->uio_iov = iov;
+++++	u->uio_iovcnt = 1;
+++++	u->uio_offset = pos;
+++++	u->uio_resid = len;
+++++	u->uio_segflg = UIO_USERSPACE;
+++++	u->uio_rw = rw;
+++++	u->uio_space = curthread->t_addrspace;
+++++}
++++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++++new file mode 100644
++++index 0000000..dc5ffe5
++++--- /dev/null
+++++++ b/kern/syscall/file.c
++++@@ -0,0 +1,341 @@
+++++/*
+++++ * File handles and file tables.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++
+++++/*** openfile functions ***/
+++++
+++++/*
+++++ * file_open
+++++ * opens a file, places it in the filetable, sets RETFD to the file
+++++ * descriptor. the pointer arguments must be kernel pointers.
+++++ * NOTE -- the passed in filename must be a mutable string.
+++++ */
+++++int
+++++file_open(char *filename, int flags, int mode, int *retfd)
+++++{
+++++	struct vnode *vn;
+++++	struct openfile *file;
+++++	int result;
+++++	
+++++	result = vfs_open(filename, flags, mode, &vn);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	file = kmalloc(sizeof(struct openfile));
+++++	if (file == NULL) {
+++++		vfs_close(vn);
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* initialize the file struct */
+++++	file->of_lock = lock_create("file lock");
+++++	if (file->of_lock == NULL) {
+++++		vfs_close(vn);
+++++		kfree(file);
+++++		return ENOMEM;
+++++	}
+++++	file->of_vnode = vn;
+++++	file->of_offset = 0;
+++++	file->of_accmode = flags & O_ACCMODE;
+++++	file->of_refcount = 1;
+++++
+++++	/* vfs_open checks for invalid access modes */
+++++	KASSERT(file->of_accmode==O_RDONLY ||
+++++	        file->of_accmode==O_WRONLY ||
+++++	        file->of_accmode==O_RDWR);
+++++
+++++	/* place the file in the filetable, getting the file descriptor */
+++++	result = filetable_placefile(file, retfd);
+++++	if (result) {
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++		vfs_close(vn);
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * file_doclose
+++++ * shared code for file_close and filetable_destroy
+++++ */
+++++static
+++++int
+++++file_doclose(struct openfile *file)
+++++{
+++++	lock_acquire(file->of_lock);
+++++
+++++	/* if this is the last close of this file, free it up */
+++++	if (file->of_refcount == 1) {
+++++		vfs_close(file->of_vnode);
+++++		lock_release(file->of_lock);
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++	}
+++++	else {
+++++		KASSERT(file->of_refcount > 1);
+++++		file->of_refcount--;
+++++		lock_release(file->of_lock);
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * file_close
+++++ * knock off the refcount, freeing the memory if it goes to 0.
+++++ */
+++++int
+++++file_close(int fd)
+++++{
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* find the file in the filetable */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	result = file_doclose(file);
+++++	if (result) {
+++++		/* leave file open for possible retry */
+++++		return result;
+++++	}
+++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++
+++++	return 0;
+++++}
+++++
+++++/*** filetable functions ***/
+++++
+++++/* 
+++++ * filetable_init
+++++ * pretty straightforward -- allocate the space, initialize to NULL.
+++++ * note that the one careful thing is to open the std i/o in order to
+++++ * get
+++++ * stdin  == 0
+++++ * stdout == 1
+++++ * stderr == 2
+++++ */
+++++int
+++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++++{
+++++	/* the filenames come from the kernel; assume reasonable length */
+++++	char path[32];
+++++	int result;
+++++	int fd;
+++++
+++++	/* make sure we can fit these */
+++++	KASSERT(strlen(inpath) < sizeof(path));
+++++	KASSERT(strlen(outpath) < sizeof(path));
+++++	KASSERT(strlen(errpath) < sizeof(path));
+++++	
+++++	/* catch memory leaks, repeated calls */
+++++	KASSERT(curthread->t_filetable == NULL);
+++++
+++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++++	if (curthread->t_filetable == NULL) {
+++++		return ENOMEM;
+++++	}
+++++	
+++++	/* NULL-out the table */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++	}
+++++
+++++	/*
+++++	 * open the std fds.  note that the names must be copied into
+++++	 * the path buffer so that they're mutable.
+++++	 */
+++++	strcpy(path, inpath);
+++++	result = file_open(path, O_RDONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, outpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, errpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_copy
+++++ * again, pretty straightforward.  the subtle business here is that instead of
+++++ * copying the openfile structure, we just increment the refcount.  this means
+++++ * that openfile structs will, in fact, be shared between processes, as in
+++++ * Unix.
+++++ */
+++++int
+++++filetable_copy(struct filetable **copy)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int fd;
+++++
+++++	/* waste of a call, really */
+++++	if (ft == NULL) {
+++++		*copy = NULL;
+++++		return 0;
+++++	}
+++++	
+++++	*copy = kmalloc(sizeof(struct filetable));
+++++	
+++++	if (*copy == NULL) {
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* copy over the entries */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd] != NULL) {
+++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++++			ft->ft_openfiles[fd]->of_refcount++;
+++++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++++		} 
+++++		else {
+++++			(*copy)->ft_openfiles[fd] = NULL;
+++++		}
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_destroy
+++++ * closes the files in the file table, frees the table.
+++++ */
+++++void
+++++filetable_destroy(struct filetable *ft)
+++++{
+++++	int fd, result;
+++++
+++++	KASSERT(ft != NULL);
+++++
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd]) {
+++++			result = file_doclose(ft->ft_openfiles[fd]);
+++++			KASSERT(result==0);
+++++		}
+++++	}
+++++	
+++++	kfree(ft);
+++++}	
+++++
+++++/* 
+++++ * filetable_placefile
+++++ * finds the smallest available file descriptor, places the file at the point,
+++++ * sets FD to it.
+++++ */
+++++int
+++++filetable_placefile(struct openfile *file, int *fd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int i;
+++++	
+++++	for (i = 0; i < OPEN_MAX; i++) {
+++++		if (ft->ft_openfiles[i] == NULL) {
+++++			ft->ft_openfiles[i] = file;
+++++			*fd = i;
+++++			return 0;
+++++		}
+++++	}
+++++
+++++	return EMFILE;
+++++}
+++++
+++++/*
+++++ * filetable_findfile
+++++ * verifies that the file descriptor is valid and actually references an
+++++ * open file, setting the FILE to the file at that index if it's there.
+++++ */
+++++int
+++++filetable_findfile(int fd, struct openfile **file)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++
+++++	if (fd < 0 || fd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++	
+++++	*file = ft->ft_openfiles[fd];
+++++	if (*file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_dup2file
+++++ * verifies that both file descriptors are valid, and that the OLDFD is
+++++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++++ */
+++++int
+++++filetable_dup2file(int oldfd, int newfd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++
+++++	file = ft->ft_openfiles[oldfd];
+++++	if (file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++++	if (oldfd == newfd) {
+++++		return 0;
+++++	}
+++++
+++++	/* closes the newfd if it's open */
+++++	if (ft->ft_openfiles[newfd] != NULL) {
+++++		result = file_close(newfd);
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
+++++
+++++	/* up the refcount */
+++++	lock_acquire(file->of_lock);
+++++	file->of_refcount++;
+++++	lock_release(file->of_lock);
+++++
+++++	/* doesn't need to be synchronized because it's just changing the ft */
+++++	ft->ft_openfiles[newfd] = file;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++++new file mode 100644
++++index 0000000..8aa024c
++++--- /dev/null
+++++++ b/kern/syscall/file_syscalls.c
++++@@ -0,0 +1,270 @@
+++++/*
+++++ * File-related system call implementations.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <kern/seek.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++#include <copyinout.h>
+++++
+++++/*
+++++ * sys_open
+++++ * just copies in the filename, then passes work to file_open.
+++++ */
+++++int
+++++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++++{
+++++	char fname[PATH_MAX];
+++++	int result;
+++++
+++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return file_open(fname, flags, mode, retval);
+++++}
+++++
+++++/*
+++++ * sys_read
+++++ * translates the fd into its openfile, then calls VOP_READ.
+++++ */
+++++int
+++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* better be a valid file descriptor */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_WRONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++++  
+++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++++
+++++	/* does the read */
+++++	result = VOP_READ(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++	
+++++	/*
+++++	 * The amount read is the size of the buffer originally, minus
+++++	 * how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * sys_write
+++++ * translates the fd into its openfile, then calls VOP_WRITE.
+++++ */
+++++int
+++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_RDONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++++	
+++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++++
+++++	/* does the write */
+++++	result = VOP_WRITE(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	/*
+++++	 * the amount written is the size of the buffer originally,
+++++	 * minus how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_close
+++++ * just pass off the work to file_close.
+++++ */
+++++int
+++++sys_close(int fd)
+++++{
+++++	return file_close(fd);
+++++}
+++++
+++++/*
+++++ * sys_lseek
+++++ * translates the fd into its openfile, then based on the type of seek,
+++++ * figure out the new offset, try the seek, if that succeeds, update the
+++++ * openfile.
+++++ */
+++++int
+++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++++{
+++++	struct stat info;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++	
+++++	/* based on the type of seek, set the retval */ 
+++++	switch (whence) {
+++++	    case SEEK_SET:
+++++		*retval = offset;
+++++		break;
+++++	    case SEEK_CUR:
+++++		*retval = file->of_offset + offset;
+++++		break;
+++++	    case SEEK_END:
+++++		result = VOP_STAT(file->of_vnode, &info);
+++++		if (result) {
+++++			lock_release(file->of_lock);
+++++			return result;
+++++		}
+++++		*retval = info.st_size + offset;
+++++		break;
+++++	    default:
+++++		lock_release(file->of_lock);
+++++		return EINVAL;
+++++	}
+++++
+++++	/* try the seek -- if it fails, return */
+++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++	
+++++	/* success -- update the file structure */
+++++	file->of_offset = *retval;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_dup2
+++++ * just pass the work off to the filetable
+++++ */
+++++int
+++++sys_dup2(int oldfd, int newfd, int *retval)
+++++{
+++++	int result;
+++++
+++++	result = filetable_dup2file(oldfd, newfd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = newfd;
+++++	return 0;
+++++}
+++++
+++++/* really not "file" calls, per se, but might as well put it here */
+++++
+++++/*
+++++ * sys_chdir
+++++ * copyin the path and pass it off to vfs.
+++++ */
+++++int
+++++sys_chdir(userptr_t path)
+++++{
+++++	char pathbuf[PATH_MAX];
+++++	int result;
+++++	
+++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return vfs_chdir(pathbuf);
+++++}
+++++
+++++/*
+++++ * sys___getcwd
+++++ * just use vfs_getcwd.
+++++ */
+++++int
+++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	int result;
+++++  
+++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	result = vfs_getcwd(&useruio);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = buflen - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++++index a6f45c8..4ba181a 100644
++++--- a/kern/syscall/runprogram.c
+++++++ b/kern/syscall/runprogram.c
++++@@ -44,6 +44,7 @@
++++ #include <vfs.h>
++++ #include <syscall.h>
++++ #include <test.h>
+++++#include <file.h>
++++ 
++++ /*
++++  * Load program "progname" and start running it in usermode.
++++@@ -66,6 +67,13 @@ runprogram(char *progname)
++++ 
++++ 	/* We should be a new thread. */
++++ 	KASSERT(curthread->t_addrspace == NULL);
+++++	
+++++  if (curthread->t_filetable == NULL) {
+++++		result = filetable_init("con:", "con:", "con:");
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
++++ 
++++ 	/* Create a new address sp
++\ No newline at end of file
++diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
++index 287a678..db31b89 100644
++--- a/user/testbin/badcall/bad_execv.c
+++++ b/user/testbin/badcall/bad_execv.c
++@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
++ 		return;
++ 	}
++ 
+++
++ 	rv = execv("/bin/true", args);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	exit(MAGIC_STATUS);
++diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
++index 809c68c..8eb69c3 100644
++--- a/user/testbin/badcall/bad_waitpid.c
+++++ b/user/testbin/badcall/bad_waitpid.c
++@@ -36,6 +36,7 @@
++ #include <unistd.h>
++ #include <errno.h>
++ #include <err.h>
+++#include<stdio.h>
++ 
++ #include "config.h"
++ #include "test.h"
++@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Hello:%d",(int)ptr);
++ 
++ 	rv = waitpid(pid, ptr, 0);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	waitpid(pid, &x, 0);
++ }
++ 
+++
++ static
++ void
++ wait_unaligned(void)
++@@ -85,13 +88,16 @@ wait_unaligned(void)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Aligned int:%d",&status);
++ 
++ 	/* start with proper integer alignment */
++ 	ptr = (char *)(&status[0]);
++-
+++	//printf("Aligned:%c\n",*ptr);
++ 	/* generate improper alignment on platforms with restrictions*/
++ 	ptr++;
++ 
+++	//Print("UnAligned:%c\n",*ptr);
+++
++ 	rv = waitpid(pid, (int *)ptr, 0);
++ 	report_survival(rv, errno, "wait with unaligned status");
++ 	if (rv<0) {
++diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
++new file mode 100644
++index 0000000..fe21882
++--- /dev/null
+++++ b/user/testbin/myforktest/Makefile
++@@ -0,0 +1,11 @@
+++# Makefile for forktest
+++
+++TOP=../../..
+++.include "$(TOP)/mk/os161.config.mk"
+++
+++PROG=myforktest
+++SRCS=myforktest.c
+++BINDIR=/testbin
+++
+++.include "$(TOP)/mk/os161.prog.mk"
+++
++diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
++new file mode 100644
++index 0000000..7bd6663
++--- /dev/null
+++++ b/user/testbin/myforktest/myforktest.c
++@@ -0,0 +1,33 @@
+++#include <unistd.h>
+++#include <string.h>
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <err.h>
+++
+++int main()
+++{
+++	int status;
+++	int pid;
+++	int childpid;
+++	int parent;
+++	int returnCode=fork();
+++
+++	if(returnCode==0)
+++	{
+++		childpid=getpid();
+++		printf("I am child:%d\n",childpid);
+++		return -10;
+++	}
+++	else
+++	{
+++		//printf("Return:%d",returnCode);
+++		//printf("Wait for child\n");
+++		parent=getpid();
+++		printf("I am parent:%d\n",parent);
+++		pid=waitpid(returnCode,&status,0);
+++		printf("Child id returned" "%d",pid);
+++		printf(" Return code: %d\n",status);
+++
+++	}
+++	return 0;
+++}
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/submitfin.patch b/submitfin.patch
new file mode 100644
index 0000000..d440e6e
--- /dev/null
+++ b/submitfin.patch
@@ -0,0 +1,12621 @@
+diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
+index ff39633..72de946 100644
+--- a/kern/arch/mips/locore/trap.c
++++ b/kern/arch/mips/locore/trap.c
+@@ -114,7 +114,9 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
+ 
+ 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
+ 		code, sig, trapcodenames[code], epc, vaddr);
+-	panic("I don't know how to handle this\n");
++	sys_exit(0);
++	//panic("I don't know how to handle this\n");
++	//thread_exit();
+ }
+ 
+ /*
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..7d2eb52 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,49 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	//int flag;
++	//tf=(struct trapframe*)tf;
++	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++		//if(flag)
++		//{
++
++			//return flag;
++			//newtf.tf_v0=ENOMEM;
++			//newtf.tf_a3=1;
++		//}
++	curthread->t_addrspace=(struct addrspace*)adrspace;
++	as_activate(curthread->t_addrspace);
++	//tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	//int flag;
++	//flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	//if(flag)
++	//{
++		//newtf.tf_v0=ENOMEM;
++		//newtf.tf_a3=1;
++	//}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	//curthread->pid=newtf.tf_a0;
++
++
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..8cfaa94 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,34 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++	if(fthread->proc==NULL)
++		return ENOMEM;
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	if(fthread->proc->wcv==NULL)
++		return ENOMEM;
++	fthread->proc->tlock=lock_create("First Lock");
++	if(fthread->proc->tlock==NULL)
++		return ENOMEM;
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..1fdf2c0
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,498 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro) {
++	//lock_acquire(mypro->tlock);
++	while (!mypro->exited) {
++		cv_wait(mypro->wcv, mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++	(void) adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt = (struct trapframe*) kmalloc(sizeof(struct trapframe));
++	if(copyt==NULL)
++		return ENOMEM;
++	bzero(copyt, sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt, tf, sizeof(struct trapframe));
++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++	if(flag)
++		return flag;
++	//if(curthread->pid==0)
++	//{
++	//curthread->pid=PID_MIN;
++	//}
++	if (flag) {
++		kfree(copyt);
++		return flag;
++	}
++
++	//we need to allocate pid for our new process
++
++	//pid_t cpid;
++	/*
++	for (childid = 0; childid <= 16; childid++) {
++		if (p_table[childid] == NULL ) {
++			p_table[childid] = (struct process*) kmalloc(
++					sizeof(struct process));
++			if(p_table[childid]==NULL)
++			{
++				return ENOMEM;
++			}
++			p_table[childid]->full = 1;
++			pidcount++;
++			p_table[childid]->pid = pidcount;
++			p_table[childid]->ppid = curthread->pid;
++			//p_table[childid]->exitsem=sem_create("process",0);
++			p_table[childid]->tlock = lock_create("My Lock");
++			if(p_table[childid]==NULL)
++			{
++				return ENOMEM;
++			}
++			p_table[childid]->wcv = cv_create("My CV");
++			if(p_table[childid]==NULL)
++				return ENOMEM;
++			p_table[childid]->self = NULL;
++			break;
++		}
++	}
++	if (childid > PID_MAX) {
++		//retval = 1;
++		return EMPROC;
++	}
++	*/
++	//int i;
++
++	//copyt->tf_a0 = (int) p_table[childid]->pid;
++	//kprintf("Ret:%d\n",copyt->tf_a0);
++	struct thread *new_proc;
++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++	//int s=splhigh();
++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++			(unsigned long) adrcopy, &new_proc);
++	//kprintf("Out of thread fork:%d\n",flag);
++	if (flag) {
++		kfree(copyt);
++		as_destroy(adrcopy);
++
++		return flag;
++	}
++
++
++	for (childid = 0; childid <= 16; childid++) {
++			if (p_table[childid] == NULL ) {
++				p_table[childid] = (struct process*) kmalloc(
++						sizeof(struct process));
++				if(p_table[childid]==NULL)
++				{
++					return ENOMEM;
++				}
++				p_table[childid]->full = 1;
++				pidcount++;
++				p_table[childid]->pid = pidcount;
++				p_table[childid]->ppid = curthread->pid;
++				//p_table[childid]->exitsem=sem_create("process",0);
++				p_table[childid]->tlock = lock_create("My Lock");
++				if(p_table[childid]->tlock==NULL)
++				{
++					return ENOMEM;
++				}
++				p_table[childid]->wcv = cv_create("My CV");
++				if(p_table[childid]->wcv==NULL)
++					return ENOMEM;
++				p_table[childid]->self = NULL;
++				break;
++			}
++		}
++		if (childid > PID_MAX) {
++			//*retval = 1;
++			return EMPROC;
++		}
++
++	//new_proc->pid=(pid_t)childid;
++	//new_proc=p_table[childid];
++
++	new_proc->pid = p_table[childid]->pid;
++	new_proc->proc = p_table[childid];
++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++	//if (new_proc->t_filetable == NULL) {
++	//return ENOMEM;
++	//}
++	p_table[childid]->self = new_proc;
++
++	//new_proc->pid=p_table[childid]->pid;
++	//new_proc->proc->pid=p_table[childid]->pid;
++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++
++	//kprintf("Child id:%d",new_proc->pid);
++	//new_proc->t_filetable->
++	//for(i=0;i<128;i++)
++	//{
++	flag = filetable_copy(&new_proc->t_filetable);
++	//}
++	//splx(s);
++	// kprintf("Fork over!");
++
++	*retval = p_table[childid]->pid;
++	//kprintf("Return val in fork:%d",*retval);
++	return 0;
++
++	//flag=
++	//flag=thread_fork=
++}
++
++int sys_execv(char *progname, char** arguments) {
++
++	int flag;
++	int numargs;
++	int addr;
++	int i;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size = 0;
++	char *namedes;
++
++	if (progname == NULL ) {
++		return EFAULT;
++	}
++	if (progname == "") {
++		return EINVAL;
++	}
++
++	namedes = (char*) kmalloc(PATH_MAX);
++	if(namedes==NULL)
++	{
++		return ENOMEM;
++	}
++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++			&actual_size);
++	if (flag != 0) {
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if (strlen(namedes) == 0) {
++		//*retval=1;
++		return EISDIR;
++	}
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++	if (flag) {
++		return flag;
++	}
++	actual_size = 0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++	if (arguments == NULL ) {
++		kfree(namedes);
++		return EFAULT;
++	}
++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++	if (flag) {
++		kfree(namedes);
++		return EFAULT;
++	}
++
++	//check=wthread->exitcode;
++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++	//if(err)
++	//{
++	//	lock_release(p_table[i]->tlock);
++	//return err;
++	//}
++
++	numargs = 0;
++	while (arguments[numargs] != NULL ) {
++		//kprintf("%");
++		numargs = numargs + 1;
++	}
++
++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++	//int i;
++	for (i = 0; i < numargs; i++) {
++		actual_size = 0;
++		kargv[i] = (char*) kmalloc(PATH_MAX);
++		if(kargv==NULL)
++			return ENOMEM;
++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++				&actual_size);
++		if (flag) {
++			kfree(kargv);
++			kfree(namedes);
++			return EFAULT;
++		}
++
++	}
++	actual_size = 0;
++
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace == NULL ) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++	if (flag) {
++		// thread_exit destroys curthread->t_addrspace
++		vfs_close(vn);
++		return flag;
++	}
++
++	vfs_close(vn);
++
++	// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (flag) {
++		//thread_exit destroys curthread->t_addrspace
++		return flag;
++	}
++
++	//i=0;
++	vaddr_t stackptrv[numargs + 1];
++	for (i = numargs - 1; i >= 0; i--) {
++		int len = strlen(kargv[i]);
++		int padder=0;
++		len++;// to account for string terminator
++		//if(len%4!=0)
++		padder = len % 4;
++		stackptr =stackptr-( len + (4-padder));
++
++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++				&actual_size);
++
++		if (flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return flag;
++		}
++
++		stackptrv[i] = stackptr;
++	}
++	stackptrv[numargs] = 0;
++
++	//This copies the actual stack addresses of the arguments
++	//* into the stack. Hopefully.
++
++	 for(i = numargs; i >= 0; i--)
++	 {
++	 stackptr -= sizeof(vaddr_t);
++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++
++	 if(flag)
++	 {
++	 kfree(kargv);
++	 kfree(namedes);
++	 return flag;
++	 }
++
++	 }
++
++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++	//pt_getthread();
++
++	//enter_new_process does not return.
++	panic("enter_new_process returned\n");
++	return EINVAL;
++
++}
++
++int sys_getpid(pid_t *retval) {
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval = curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++	struct process* wthread = NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if (status == NULL )
++		return EFAULT;
++	if (options != 0)
++		return EINVAL;
++	if (pid == curthread->pid)
++		return ECHILD;
++	if (pid < PID_MIN || pid > PID_MAX)
++		return ESRCH;
++	if (status == NULL )
++		return EFAULT;
++	if (pid == curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++	//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++	//return EFAULT;
++	//}
++
++	//if()
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++	//if (result) {
++	//return result;
++	//}
++	//int addr=(int)&status;
++	//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++	//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				wthread = p_table[i];
++				break;
++			}
++		}
++	}
++	if (wthread == NULL ) {
++		return ESRCH;
++	}
++	if (curthread->proc->pid != wthread->ppid)
++		return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check = wthread->exitcode;
++	err = copyout(&check, (userptr_t) status, sizeof(check));
++	if (err) {
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i] = NULL;
++
++	*retval = pid;
++	//panic("After dereferencing");
++	return 0;
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode) {
++	pid_t pid = curthread->proc->pid;
++	pid_t i = PID_MIN;
++	struct process* ethread=NULL;
++//pid_t parent;
++//if(pid!=2)
++//{
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				ethread = p_table[i];
++				break;
++			}
++		}
++	}
++
++//parent=ethread->ppid;
++	if (ethread != NULL ) {
++		lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++		ethread->exited = 1;
++//p_table[i]=ethread;
++		cv_broadcast(ethread->wcv, ethread->tlock);
++//kfree(curthread->t_filetable);
++		lock_release(ethread->tlock);
++	}
++//}
++	i = 0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++	thread_exit();
++}
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..6d6dc37 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,40 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++int padder=0;
++len++;
++if(len%4!=0)
++padder = len % 4;
++stackptr=stackptr-( len + (4-padder));
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..f3918ab 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,9 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++thread->t_filetable=NULL;
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +358,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +378,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +533,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -532,6 +546,7 @@ thread_fork(const char *name,
+ 	 * only with caution, because in general the child thread
+ 	 * might exit at any time.
+ 	 */
++
+ 	if (ret != NULL) {
+ 		*ret = newthread;
+ 	}
+@@ -589,7 +604,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +813,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..04fc72b
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,8279 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..dfd7b53
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,445 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro) {
+++	//lock_acquire(mypro->tlock);
+++	while (!mypro->exited) {
+++		cv_wait(mypro->wcv, mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+++	(void) adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt = (struct trapframe*) kmalloc(
+++			sizeof(struct trapframe));
+++	bzero(copyt, sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt, tf, sizeof(struct trapframe));
+++	flag = as_copy(curthread->t_addrspace, &adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++	//curthread->pid=PID_MIN;
+++	//}
+++	if (flag) {
+++		kfree(copyt);
+++		return flag;
+++	}
+++
+++	//we need to allocate pid for our new process
+++
+++	//pid_t cpid;
+++	for (childid = 0; childid <= 16; childid++) {
+++		if (p_table[childid] == NULL ) {
+++			p_table[childid] = (struct process*) kmalloc(
+++					sizeof(struct process));
+++			p_table[childid]->full = 1;
+++			pidcount++;
+++			p_table[childid]->pid = pidcount;
+++			p_table[childid]->ppid = curthread->pid;
+++			//p_table[childid]->exitsem=sem_create("process",0);
+++			p_table[childid]->tlock = lock_create("My Lock");
+++			p_table[childid]->wcv = cv_create("My CV");
+++			p_table[childid]->self = NULL;
+++			break;
+++		}
+++	}
+++	if (childid > PID_MAX) {
+++		*retval = 1;
+++		return EMPROC;
+++	}
+++	//int i;
+++
+++	copyt->tf_a0 = (int) p_table[childid]->pid;
+++	//kprintf("Ret:%d\n",copyt->tf_a0);
+++	struct thread *new_proc;
+++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+++	//int s=splhigh();
+++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+++			(unsigned long) adrcopy, &new_proc);
+++	//kprintf("Out of thread fork:%d\n",flag);
+++	if (flag) {
+++		kfree(copyt);
+++		as_destroy(adrcopy);
+++
+++		return flag;
+++	}
+++
+++	//new_proc->pid=(pid_t)childid;
+++	//new_proc=p_table[childid];
+++
+++	new_proc->pid = p_table[childid]->pid;
+++	new_proc->proc = p_table[childid];
+++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++	//if (new_proc->t_filetable == NULL) {
+++	//return ENOMEM;
+++	//}
+++	p_table[childid]->self = new_proc;
+++
+++	//new_proc->pid=p_table[childid]->pid;
+++	//new_proc->proc->pid=p_table[childid]->pid;
+++	//kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++	//kprintf("Child id:%d",new_proc->pid);
+++	//new_proc->t_filetable->
+++	//for(i=0;i<128;i++)
+++	//{
+++	flag = filetable_copy(&new_proc->t_filetable);
+++	//}
+++	//splx(s);
+++	// kprintf("Fork over!");
+++
+++	*retval = p_table[childid]->pid;
+++	//kprintf("Return val in fork:%d",*retval);
+++	return 0;
+++
+++	//flag=
+++	//flag=thread_fork=
+++}
+++
+++int sys_execv(char *progname, char** arguments) {
+++
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size = 0;
+++	char *namedes;
+++
+++	if (progname == NULL ) {
+++		return EFAULT;
+++	}
+++	if (progname == "") {
+++		return EINVAL;
+++	}
+++
+++	namedes = (char*) kmalloc(PATH_MAX);
+++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+++			&actual_size);
+++	if (flag != 0) {
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if (strlen(namedes) == 0) {
+++		//*retval=1;
+++		return EISDIR;
+++	}
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+++	if (flag) {
+++		return flag;
+++	}
+++	actual_size = 0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if (arguments == NULL ) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+++	if (flag) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++	//return err;
+++	//}
+++
+++	numargs = 0;
+++	while (arguments[numargs] != NULL ) {
+++		//kprintf("%");
+++		numargs = numargs + 1;
+++	}
+++
+++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+++	//int i;
+++	for (i = 0; i < numargs; i++) {
+++		actual_size = 0;
+++		kargv[i] = (char*) kmalloc(PATH_MAX);
+++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+++				&actual_size);
+++		if (flag) {
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size = 0;
+++
+++	curthread->t_addrspace = as_create();
+++	if (curthread->t_addrspace == NULL ) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++	if (flag) {
+++		// thread_exit destroys curthread->t_addrspace
+++		vfs_close(vn);
+++		return flag;
+++	}
+++
+++	vfs_close(vn);
+++
+++	// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++	if (flag) {
+++		//thread_exit destroys curthread->t_addrspace
+++		return flag;
+++	}
+++
+++	//i=0;
+++	vaddr_t stackptrv[numargs + 1];
+++	for (i = numargs - 1; i >= 0; i--) {
+++		int len = strlen(kargv[i]);
+++		int padder=0;
+++		len++;// to account for string terminator
+++		if(len%4!=0)
+++		padder = len % 4;
+++		stackptr =stackptr-(len + padder);
+++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+++				&actual_size);
+++
+++		if (flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return flag;
+++		}
+++
+++		stackptrv[i] = stackptr;
+++	}
+++	stackptrv[numargs] = 0;
+++
+++	//This copies the actual stack addresses of the arguments
+++	//* into the stack. Hopefully.
+++
+++	 for(i = numargs; i >= 0; i--)
+++	 {
+++	 stackptr -= sizeof(vaddr_t);
+++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++
+++	 if(flag)
+++	 {
+++	 kfree(kargv);
+++	 kfree(namedes);
+++	 return flag;
+++	 }
+++
+++	 }
+++
+++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+++	//pt_getthread();
+++
+++	//enter_new_process does not return.
+++	panic("enter_new_process returned\n");
+++	return EINVAL;
+++
+++}
+++
+++int sys_getpid(pid_t *retval) {
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval = curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+++	struct process* wthread = NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if (status == NULL )
+++		return EFAULT;
+++	if (options != 0)
+++		return EINVAL;
+++	if (pid == curthread->pid)
+++		return ECHILD;
+++	if (pid < PID_MIN || pid > PID_MAX)
+++		return ESRCH;
+++	if (status == NULL )
+++		return EFAULT;
+++	if (pid == curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++	//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++
+++	//if()
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++	//if (result) {
+++	//return result;
+++	//}
+++	//int addr=(int)&status;
+++	//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				wthread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++	if (wthread == NULL ) {
+++		return ESRCH;
+++	}
+++	if (curthread->proc->pid != wthread->ppid)
+++		return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check = wthread->exitcode;
+++	err = copyout(&check, (userptr_t) status, sizeof(check));
+++	if (err) {
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i] = NULL;
+++
+++	*retval = pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode) {
+++	pid_t pid = curthread->proc->pid;
+++	pid_t i = PID_MIN;
+++	struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				ethread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++
+++//parent=ethread->ppid;
+++	if (ethread != NULL ) {
+++		lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++		ethread->exited = 1;
+++//p_table[i]=ethread;
+++		cv_broadcast(ethread->wcv, ethread->tlock);
+++//kfree(curthread->t_filetable);
+++		lock_release(ethread->tlock);
+++	}
+++//}
+++	i = 0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++	thread_exit();
+++}
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..1ada408 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,40 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++int padder=0;
+++len++;
+++if(len%4!=0)
+++padder = len % 4;
+++stackptr=stackptr-(len + padder);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index 5b8099e..60108d3 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -798,6 +801,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..e07fb23
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,4058 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..33b99ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,11 +32,14 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <addrspace.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
+++ 
++++
+++ /*
+++  * System call dispatcher.
+++  *
+++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++                break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++			break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_fork:
++++	    	err=0;
++++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++++	    	break;
++++	    case SYS_execv:
++++	    	err=0;
++++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++++	    	break;
++++	    case SYS_getpid:
++++	    	err=0;
++++	    	err=sys_getpid(&retval);
++++	    	break;
++++	    case SYS_waitpid:
++++	    	err=0;
++++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++	    	//panic("Waitpid over");
++++	    	break;
++++	    case SYS__exit:
++++	    	sys_exit((int)tf->tf_a0);
++++	    	break;
++++
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+++  *
+++  * Thus, you can trash it and do things another way if you prefer.
+++  */
+++-void
+++-enter_forked_process(struct trapframe *tf)
++++//void
++++//enter_forked_process(struct trapframe *tf)
++++//{
++++	//(void)tf;
++++//}
++++
++++void enter_forked_process(void*tf,unsigned long adrspace)
+++ {
+++-	(void)tf;
++++	tf=(struct trapframe*)tf;
++++	struct trapframe newtf;
++++	int flag;
++++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++++	if(flag)
++++	{
++++		newtf.tf_v0=ENOMEM;
++++		newtf.tf_a3=1;
++++	}
++++
++++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++++	kfree(tf);
++++	//tf=NULL;
++++	//int flag;
++++
++++	curthread->pid=newtf.tf_a0;
++++
++++	as_activate(curthread->t_addrspace);
++++
++++
++++
++++	newtf.tf_v0=0;
++++	newtf.tf_a3=0;
++++	newtf.tf_epc+=4;
++++	mips_usermode(&newtf);
+++ }
+++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+++new file mode 100644
+++index 0000000..3e8d5b9
+++--- /dev/null
++++++ b/kern/arch/mips/syscall/syscall.c~
+++@@ -0,0 +1,165 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/syscall.h>
++++#include <lib.h>
++++#include <mips/trapframe.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <syscall.h>
++++
++++
++++/*
++++ * System call dispatcher.
++++ *
++++ * A pointer to the trapframe created during exception entry (in
++++ * exception.S) is passed in.
++++ *
++++ * The calling conventions for syscalls are as follows: Like ordinary
++++ * function calls, the first 4 32-bit arguments are passed in the 4
++++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++++ * unused.
++++ *
++++ * This much is the same as the calling conventions for ordinary
++++ * function calls. In addition, the system call number is passed in
++++ * the v0 register.
++++ *
++++ * On successful return, the return value is passed back in the v0
++++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++++ * function call, and additionally the a3 register is also set to 0 to
++++ * indicate success.
++++ *
++++ * On an error return, the error code is passed back in the v0
++++ * register, and the a3 register is set to 1 to indicate failure.
++++ * (Userlevel code takes care of storing the error code in errno and
++++ * returning the value -1 from the actual userlevel syscall function.
++++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++++ *
++++ * Upon syscall return the program counter stored in the trapframe
++++ * must be incremented by one instruction; otherwise the exception
++++ * return code will restart the "syscall" instruction and the system
++++ * call will repeat forever.
++++ *
++++ * If you run out of registers (which happens quickly with 64-bit
++++ * values) further arguments must be fetched from the user-level
++++ * stack, starting at sp+16 to skip over the slots for the
++++ * registerized values, with copyin().
++++ */
++++void
++++syscall(struct trapframe *tf)
++++{
++++	int callno;
++++	int32_t retval;
++++	int err;
++++
++++	KASSERT(curthread != NULL);
++++	KASSERT(curthread->t_curspl == 0);
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++
++++	callno = tf->tf_v0;
++++
++++	/*
++++	 * Initialize retval to 0. Many of the system calls don't
++++	 * really return a value, just 0 for success and -1 on
++++	 * error. Since retval is the value returned on success,
++++	 * initialize it to 0 by default; thus it's not necessary to
++++	 * deal with it except for calls that return other values, 
++++	 * like write.
++++	 */
++++
++++	retval = 0;
++++
++++	switch (callno) {
++++	    case SYS_reboot:
++++		err = sys_reboot(tf->tf_a0);
++++		break;
++++
++++	    case SYS___time:
++++		err = sys___time((userptr_t)tf->tf_a0,
++++				 (userptr_t)tf->tf_a1);
++++		break;
++++		
++++	    case SYS_open:
++++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++++	    break;
++++
++++	    /* Add stuff here */
++++ 
++++	    default:
++++		kprintf("Unknown syscall %d\n", callno);
++++		err = ENOSYS;
++++		break;
++++	}
++++
++++
++++	if (err) {
++++		/*
++++		 * Return the error code. This gets converted at
++++		 * userlevel to a return value of -1 and the error
++++		 * code in errno.
++++		 */
++++		tf->tf_v0 = err;
++++		tf->tf_a3 = 1;      /* signal an error */
++++	}
++++	else {
++++		/* Success. */
++++		tf->tf_v0 = retval;
++++		tf->tf_a3 = 0;      /* signal no error */
++++	}
++++	
++++	/*
++++	 * Now, advance the program counter, to avoid restarting
++++	 * the syscall over and over again.
++++	 */
++++	
++++	tf->tf_epc += 4;
++++
++++	/* Make sure the syscall code didn't forget to lower spl */
++++	KASSERT(curthread->t_curspl == 0);
++++	/* ...or leak any spinlocks */
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++}
++++
++++/*
++++ * Enter user mode for a newly forked process.
++++ *
++++ * This function is provided as a reminder. You need to write
++++ * both it and the code that calls it.
++++ *
++++ * Thus, you can trash it and do things another way if you prefer.
++++ */
++++void
++++enter_forked_process(struct trapframe *tf)
++++{
++++	(void)tf;
++++}
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..7d5df71 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,9 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
++++file	  syscall/proc_sys.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/limits.h b/kern/include/limits.h
+++index 01684c4..3a54e24 100644
+++--- a/kern/include/limits.h
++++++ b/kern/include/limits.h
+++@@ -48,5 +48,6 @@
+++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+++ #define OPEN_MAX        __OPEN_MAX
+++ #define IOV_MAX         __IOV_MAX
++++//#define OPEN_MAX        64
+++ 
+++ #endif /* _LIMITS_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..df9fe64 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,11 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        //struct spinlock cv_lock;
++++        struct wchan *cv_wchan;
++++        //volatile int hold;
++++        //struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ 
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int res_count;
++++        struct wchan *rd_wchan;
++++        struct wchan *wr_wchan;
++++        struct semaphore *rw_sem;
++++        struct lock *rw_lock;
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+++new file mode 100644
+++index 0000000..d98aeb7
+++--- /dev/null
++++++ b/kern/include/synch.h~
+++@@ -0,0 +1,161 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _SYNCH_H_
++++#define _SYNCH_H_
++++
++++/*
++++ * Header file for synchronization primitives.
++++ */
++++
++++
++++#include <spinlock.h>
++++
++++/*
++++ * Dijkstra-style semaphore.
++++ *
++++ * The name field is for easier debugging. A copy of the name is made
++++ * internally.
++++ */
++++struct semaphore {
++++        char *sem_name;
++++	struct wchan *sem_wchan;
++++	struct spinlock sem_lock;
++++        volatile int sem_count;
++++};
++++
++++struct semaphore *sem_create(const char *name, int initial_count);
++++void sem_destroy(struct semaphore *);
++++
++++/*
++++ * Operations (both atomic):
++++ *     P (proberen): decrement count. If the count is 0, block until
++++ *                   the count is 1 again before decrementing.
++++ *     V (verhogen): increment count.
++++ */
++++void P(struct semaphore *);
++++void V(struct semaphore *);
++++
++++
++++/*
++++ * Simple lock for mutual exclusion.
++++ *
++++ * When the lock is created, no thread should be holding it. Likewise,
++++ * when the lock is destroyed, no thread should be holding it.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++struct lock {
++++        char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct lock *lock_create(const char *name);
++++void lock_acquire(struct lock *);
++++
++++/*
++++ * Operations:
++++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++++ *                   same time.
++++ *    lock_release - Free the lock. Only the thread holding the lock may do
++++ *                   this.
++++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++++ *                   false otherwise.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void lock_release(struct lock *);
++++bool lock_do_i_hold(struct lock *);
++++void lock_destroy(struct lock *);
++++
++++
++++/*
++++ * Condition variable.
++++ *
++++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++++ * to wait until a variable meets a particular condition, but there's no
++++ * actual variable, as such, in the CV.
++++ *
++++ * These CVs are expected to support Mesa semantics, that is, no
++++ * guarantees are made about scheduling.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++
++++struct cv {
++++        char *cv_name;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct cv *cv_create(const char *name);
++++void cv_destroy(struct cv *);
++++
++++/*
++++ * Operations:
++++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++++ *                   waking up again, re-acquire the lock.
++++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++++ *
++++ * For all three operations, the current thread must hold the lock passed 
++++ * in. Note that under normal circumstances the same lock should be used
++++ * on all operations with any particular CV.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void cv_wait(struct cv *cv, struct lock *lock);
++++void cv_signal(struct cv *cv, struct lock *lock);
++++void cv_broadcast(struct cv *cv, struct lock *lock);
++++
++++/*
++++ * 13 Feb 2012 : GWA : Reader-writer locks.
++++ */
++++
++++struct rwlock {
++++        char *rwlock_name;
++++};
++++
++++struct rwlock * rwlock_create(const char *);
++++void rwlock_destroy(struct rwlock *);
++++
++++void rwlock_acquire_read(struct rwlock *);
++++void rwlock_release_read(struct rwlock *);
++++void rwlock_acquire_write(struct rwlock *);
++++void rwlock_release_write(struct rwlock *);
++++
++++#endif /* _SYNCH_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..ea96700 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -26,6 +26,7 @@
+++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++  * SUCH DAMAGE.
+++  */
++++#include<thread.h>
+++ 
+++ #ifndef _SYSCALL_H_
+++ #define _SYSCALL_H_
+++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+++  * Support functions.
+++  */
+++ 
++++
+++ /* Helper for fork(). You write this. */
+++-void enter_forked_process(struct trapframe *tf);
++++void enter_forked_process(void *tf,unsigned long adrspace);
+++ 
+++ /* Enter user mode. Does not return. */
+++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++++int sys_execv(char* progname,char** arguments);
++++int sys_getpid(pid_t *retval);
++++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++++void sys_exit(int exitcode);
++++int mywait(struct process* mypro);
+++ 
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/test.h b/kern/include/test.h
+++index 240d583..84f60fc 100644
+++--- a/kern/include/test.h
++++++ b/kern/include/test.h
+++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+++ int nettest(int, char **);
+++ 
+++ /* Routine for running a user-level program. */
+++-int runprogram(char *progname);
++++int runprogram(char *progname,char** argv,unsigned long argc);
+++ 
+++ /* Kernel menu system. */
+++ void menu(char *argstr);
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..77a3515 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -73,7 +73,10 @@ struct thread {
+++ 	 */
+++ 	char *t_name;			/* Name of this thread */
+++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+++-	threadstate_t t_state;		/* State this thread is in */
++++	threadstate_t t_state;
++++	/* State this thread is in */
++++
++++	pid_t pid;
+++ 
+++ 	/*
+++ 	 * Thread subsystem internal fields.
+++@@ -104,7 +107,7 @@ struct thread {
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++-
++++	struct process* proc;
+++ 	/* VM */
+++ 	struct addrspace *t_addrspace;	/* virtual address space */
+++ 
+++@@ -112,6 +115,19 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
++++};
++++
++++struct process {
++++	int full;
++++	pid_t pid;
++++    pid_t ppid;
++++    //struct semaphore* exitsem;
++++    struct lock* tlock;
++++    struct cv* wcv;
++++    bool exited;
++++    int exitcode;
++++    struct thread* self;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..4d8e7e2 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -100,7 +100,7 @@ boot(void)
+++ 	kprintf("%s", harvard_copyright);
+++ 	kprintf("\n");
+++ 
+++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++ 		GROUP_VERSION, buildconfig, buildversion);
+++ 	kprintf("\n");
+++ 
+++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+++new file mode 100644
+++index 0000000..4d8e7e2
+++--- /dev/null
++++++ b/kern/startup/main.c~
+++@@ -0,0 +1,211 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Main.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/reboot.h>
++++#include <kern/unistd.h>
++++#include <lib.h>
++++#include <spl.h>
++++#include <clock.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++#include <vm.h>
++++#include <mainbus.h>
++++#include <vfs.h>
++++#include <device.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <version.h>
++++#include "autoconf.h"  // for pseudoconfig
++++
++++
++++/*
++++ * These two pieces of data are maintained by the makefiles and build system.
++++ * buildconfig is the name of the config file the kernel was configured with.
++++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++++ *
++++ * The purpose is not to show off how many kernels you've linked, but
++++ * to make it easy to make sure that the kernel you just booted is the
++++ * same one you just built.
++++ */
++++extern const int buildversion;
++++extern const char buildconfig[];
++++
++++/*
++++ * Copyright message for the OS/161 base code.
++++ */
++++static const char harvard_copyright[] =
++++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++++
++++
++++/*
++++ * Initial boot sequence.
++++ */
++++static
++++void
++++boot(void)
++++{
++++	/*
++++	 * The order of these is important!
++++	 * Don't go changing it without thinking about the consequences.
++++	 *
++++	 * Among other things, be aware that console output gets
++++	 * buffered up at first and does not actually appear until
++++	 * mainbus_bootstrap() attaches the console device. This can
++++	 * be remarkably confusing if a bug occurs at this point. So
++++	 * don't put new code before mainbus_bootstrap if you don't
++++	 * absolutely have to.
++++	 *
++++	 * Also note that the buffer for this is only 1k. If you
++++	 * overflow it, the system will crash without printing
++++	 * anything at all. You can make it larger though (it's in
++++	 * dev/generic/console.c).
++++	 */
++++
++++	kprintf("\n");
++++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++++	kprintf("%s", harvard_copyright);
++++	kprintf("\n");
++++
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++++		GROUP_VERSION, buildconfig, buildversion);
++++	kprintf("\n");
++++
++++	/* Early initialization. */
++++	ram_bootstrap();
++++	thread_bootstrap();
++++	hardclock_bootstrap();
++++	vfs_bootstrap();
++++
++++	/* Probe and initialize devices. Interrupts should come on. */
++++	kprintf("Device probe...\n");
++++	KASSERT(curthread->t_curspl > 0);
++++	mainbus_bootstrap();
++++	KASSERT(curthread->t_curspl == 0);
++++	/* Now do pseudo-devices. */
++++	pseudoconfig();
++++	kprintf("\n");
++++
++++	/* Late phase of initialization. */
++++	vm_bootstrap();
++++	kprintf_bootstrap();
++++	thread_start_cpus();
++++
++++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++++	vfs_setbootfs("emu0");
++++
++++
++++	/*
++++	 * Make sure various things aren't screwed up.
++++	 */
++++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++++}
++++
++++/*
++++ * Shutdown sequence. Opposite to boot().
++++ */
++++static
++++void
++++shutdown(void)
++++{
++++
++++	kprintf("Shutting down.\n");
++++	
++++	vfs_clearbootfs();
++++	vfs_clearcurdir();
++++	vfs_unmountall();
++++
++++	thread_shutdown();
++++
++++	splhigh();
++++}
++++
++++/*****************************************/
++++
++++/*
++++ * reboot() system call.
++++ *
++++ * Note: this is here because it's directly related to the code above,
++++ * not because this is where system call code should go. Other syscall
++++ * code should probably live in the "syscall" directory.
++++ */
++++int
++++sys_reboot(int code)
++++{
++++	switch (code) {
++++	    case RB_REBOOT:
++++	    case RB_HALT:
++++	    case RB_POWEROFF:
++++		break;
++++	    default:
++++		return EINVAL;
++++	}
++++
++++	shutdown();
++++
++++	switch (code) {
++++	    case RB_HALT:
++++		kprintf("The system is halted.\n");
++++		mainbus_halt();
++++		break;
++++	    case RB_REBOOT:
++++		kprintf("Rebooting...\n");
++++		mainbus_reboot();
++++		break;
++++	    case RB_POWEROFF:
++++		kprintf("The system is halted.\n");
++++		mainbus_poweroff();
++++		break;
++++	}
++++
++++	panic("reboot operation failed\n");
++++	return 0;
++++}
++++
++++/*
++++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++++ * request, and then shut down.
++++ */
++++void
++++kmain(char *arguments)
++++{
++++	boot();
++++
++++	menu(arguments);
++++
++++	/* Should not get here */
++++}
+++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+++index 6c71551..a4c2750 100644
+++--- a/kern/startup/menu.c
++++++ b/kern/startup/menu.c
+++@@ -40,9 +40,13 @@
+++ #include <sfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include<thread.h>
++++#include<synch.h>
+++ #include "opt-synchprobs.h"
+++ #include "opt-sfs.h"
+++ #include "opt-net.h"
++++#include <copyinout.h>
++++//#include "proc_sys.c"
+++ 
+++ /*
+++  * In-kernel menu and command dispatcher.
+++@@ -51,6 +55,7 @@
+++ #define _PATH_SHELL "/bin/sh"
+++ 
+++ #define MAXMENUARGS  16
++++extern struct process* p_table[17];
+++ 
+++ // XXX this should not be in this file
+++ void
+++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+++ 
+++ 	strcpy(progname, args[0]);
+++ 
+++-	result = runprogram(progname);
++++	result = runprogram(progname,args,nargs);
+++ 	if (result) {
+++ 		kprintf("Running program %s failed: %s\n", args[0],
+++ 			strerror(result));
+++@@ -127,6 +132,8 @@ int
+++ common_prog(int nargs, char **args)
+++ {
+++ 	int result;
++++	struct thread* fthread;
++++	//int err;
+++ 
+++ #if OPT_SYNCHPROBS
+++ 	kprintf("Warning: this probably won't work with a "
+++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+++ 	result = thread_fork(args[0] /* thread name */,
+++ 			cmd_progthread /* thread function */,
+++ 			args /* thread arg */, nargs /* thread arg */,
+++-			NULL);
++++			&fthread);
++++	//fthread->
++++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++++
++++	fthread->pid=PID_MIN;
++++	fthread->proc->pid=PID_MIN;
++++
++++	fthread->proc->self=fthread;
++++	fthread->proc->wcv=cv_create("First CV");
++++	fthread->proc->tlock=lock_create("First Lock");
++++	p_table[0]=fthread->proc;
++++
++++	lock_acquire(p_table[0]->tlock);
++++	mywait(p_table[0]);
++++	lock_release(p_table[0]->tlock);
++++
++++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++
++++	//fthread->proc->
++++	//while(!p_table[0]->exited)
++++
++++
+++ 	if (result) {
+++ 		kprintf("thread_fork failed: %s\n", strerror(result));
+++ 		return result;
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..6c0bb3f 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -43,11 +43,25 @@
+++  * You should implement your solution to the whalemating problem below.
+++  */
+++ 
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++-// the top of the corresponding driver code.
++++// the top of the corresponding driver code
++++
++++struct semaphore *male_sem;
++++struct semaphore *female_sem;
++++struct lock *hold;
++++struct cv* mate_cv;
++++volatile int male_count;
++++volatile int female_count;
+++ 
+++ void whalemating_init() {
++++ hold=lock_create("My lock");
++++ male_sem=sem_create("Male Semaphore",0);
++++ female_sem=sem_create("Female Semaphore",0);
++++mate_cv=cv_create("mating cv");
++++male_count=0;
++++female_count=0;
+++   return;
+++ }
+++ 
+++@@ -55,6 +69,11 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++
++++	sem_destroy(male_sem);
++++	sem_destroy(female_sem);
++++	lock_destroy(hold);
++++	cv_destroy(mate_cv);
+++   return;
+++ }
+++ 
+++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+++   (void)which;
+++   
+++   male_start();
++++
++++  lock_acquire(hold);
++++
++++  V(male_sem);
++++  male_count++;
++++  if(female_count!=0)
++++  cv_signal(mate_cv,hold);
++++  else
++++	  cv_wait(mate_cv,hold);
++++  lock_release(hold);
++++
+++ 	// Implement this function 
+++   male_end();
+++ 
+++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
++++  lock_acquire(hold);
++++   V(female_sem);
++++   female_count++;
++++   if(male_count!=0)
++++   cv_signal(mate_cv,hold);
++++   else
++++	   cv_wait(mate_cv,hold);
++++  lock_release(hold);
+++ 	// Implement this function 
+++   female_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
++++  lock_acquire(hold);
++++ P(male_sem);
++++ male_count--;
++++ lock_release(hold);
++++ lock_acquire(hold);
++++  P(female_sem);
++++  female_count--;
++++  lock_release(hold);
+++ 	// Implement this function 
+++   matchmaker_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
++++
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
++++struct lock* intersect_lock;
++++struct cv* intersect_cv;
++++volatile int cur_poss[4];// an array to store the possible positions of the car
++++//currently
+++ 
+++ void stoplight_init() {
++++	intersect_cv=cv_create("Intersection Condition Variable");
++++	if(intersect_cv==NULL)
++++	{
++++		///return NULL;
++++		panic("condition variable not created");
++++	}
++++	intersect_lock=lock_create("A lock on the intersection");
++++	if(intersect_lock==NULL)
++++	{
++++		//return NULL;
++++		panic("Lock could not be created");
++++	}
++++	
++++	
+++   return;
+++ }
+++ 
+++@@ -145,6 +210,8 @@ void stoplight_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
++++	cv_destroy(intersect_cv);
++++	lock_destroy(intersect_lock);
+++   return;
+++ }
+++ 
+++@@ -152,8 +219,29 @@ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++  //(void)direction;
++++	int sec_quad=(direction+3)%4;
++++	lock_acquire(intersect_lock);
++++	// So while any of the two possible quadrants are already set, It means some 
++++	//thread is waiting...Hopefully
++++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++++		cv_wait(intersect_cv,intersect_lock);
++++	cur_poss[direction]=1;
++++	cur_poss[sec_quad]=1;
++++	inQuadrant(direction);
++++	lock_release(intersect_lock);
++++	lock_acquire(intersect_lock);
++++    cur_poss[direction]=0;
++++    //while(curr_p)
++++    //cv_broadcast(intersect_cv);
++++    inQuadrant(sec_quad);
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++    cur_poss[sec_quad]=0;
++++    leaveIntersection();
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
++++  int sec_quad=(direction+3)%4;
++++  int third_quad=(direction+2)%4;
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  cur_poss[sec_quad]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++  lock_acquire(intersect_lock);
++++  cur_poss[direction]=0;
+++   
++++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++++  //cv_wait(intersect_cv,intersect_lock);
++++      cur_poss[third_quad]=1;
++++      //while(curr_p)
++++      //cv_broadcast(intersect_cv);
++++      inQuadrant(sec_quad);
++++      cv_broadcast(intersect_cv,intersect_lock);
++++      lock_release(intersect_lock);
++++        lock_acquire(intersect_lock);
++++            //currposs[direction]=0;
++++            cur_poss[sec_quad]=0;
++++            //while(curr_p)
++++            //cv_broadcast(intersect_cv);
++++            inQuadrant(third_quad);
++++            cv_broadcast(intersect_cv,intersect_lock);
++++                //cur_poss[third_quad]=0;
++++            lock_release(intersect_lock);
++++              lock_acquire(intersect_lock);
++++                leaveIntersection();
++++                cur_poss[third_quad]=0;
++++                cv_broadcast(intersect_cv,intersect_lock);
++++                lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
+++-
++++  // Easy coz the vehicle is in same lane!!
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++  leaveIntersection();
++++  cur_poss[direction]=0;
++++  cv_broadcast(intersect_cv,intersect_lock);
++++  lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+++new file mode 100644
+++index 0000000..dfd7b53
+++--- /dev/null
++++++ b/kern/syscall/proc_sys.c
+++@@ -0,0 +1,445 @@
++++/*
++++
++++ * proc_sys.c
++++ *
++++ *  Created on: Mar 7, 2014
++++ *      Author: trinity
++++ */
++++
++++#include <types.h>
++++#include<mips/trapframe.h>
++++#include <kern/errno.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <addrspace.h>
++++#include <vm.h>
++++#include <vfs.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <file.h>
++++#include <synch.h>
++++#include<copyinout.h>
++++#include <spl.h>
++++#include<kern/wait.h>
++++
++++extern struct process* p_table[17];
++++
++++//struct cv* wcv;
++++
++++extern pid_t pidcount;
++++int mywait(struct process* mypro) {
++++	//lock_acquire(mypro->tlock);
++++	while (!mypro->exited) {
++++		cv_wait(mypro->wcv, mypro->tlock);
++++	}
++++	//*status=mypro->exitcode;
++++	//lock_release(mypro->tlock);
++++	//int test = mypro->exitcode;
++++	//test++;
++++	return 0;
++++}
++++
++++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++++	(void) adrs;
++++	int flag;
++++	pid_t childid;
++++	struct addrspace *adrcopy;
++++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++++			sizeof(struct trapframe));
++++	bzero(copyt, sizeof(struct trapframe));
++++
++++	//struct filetable* copyft;
++++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++++
++++	memcpy(copyt, tf, sizeof(struct trapframe));
++++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++++	//if(curthread->pid==0)
++++	//{
++++	//curthread->pid=PID_MIN;
++++	//}
++++	if (flag) {
++++		kfree(copyt);
++++		return flag;
++++	}
++++
++++	//we need to allocate pid for our new process
++++
++++	//pid_t cpid;
++++	for (childid = 0; childid <= 16; childid++) {
++++		if (p_table[childid] == NULL ) {
++++			p_table[childid] = (struct process*) kmalloc(
++++					sizeof(struct process));
++++			p_table[childid]->full = 1;
++++			pidcount++;
++++			p_table[childid]->pid = pidcount;
++++			p_table[childid]->ppid = curthread->pid;
++++			//p_table[childid]->exitsem=sem_create("process",0);
++++			p_table[childid]->tlock = lock_create("My Lock");
++++			p_table[childid]->wcv = cv_create("My CV");
++++			p_table[childid]->self = NULL;
++++			break;
++++		}
++++	}
++++	if (childid > PID_MAX) {
++++		*retval = 1;
++++		return EMPROC;
++++	}
++++	//int i;
++++
++++	copyt->tf_a0 = (int) p_table[childid]->pid;
++++	//kprintf("Ret:%d\n",copyt->tf_a0);
++++	struct thread *new_proc;
++++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++++	//int s=splhigh();
++++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++++			(unsigned long) adrcopy, &new_proc);
++++	//kprintf("Out of thread fork:%d\n",flag);
++++	if (flag) {
++++		kfree(copyt);
++++		as_destroy(adrcopy);
++++
++++		return flag;
++++	}
++++
++++	//new_proc->pid=(pid_t)childid;
++++	//new_proc=p_table[childid];
++++
++++	new_proc->pid = p_table[childid]->pid;
++++	new_proc->proc = p_table[childid];
++++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++++	//if (new_proc->t_filetable == NULL) {
++++	//return ENOMEM;
++++	//}
++++	p_table[childid]->self = new_proc;
++++
++++	//new_proc->pid=p_table[childid]->pid;
++++	//new_proc->proc->pid=p_table[childid]->pid;
++++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++++
++++	//kprintf("Child id:%d",new_proc->pid);
++++	//new_proc->t_filetable->
++++	//for(i=0;i<128;i++)
++++	//{
++++	flag = filetable_copy(&new_proc->t_filetable);
++++	//}
++++	//splx(s);
++++	// kprintf("Fork over!");
++++
++++	*retval = p_table[childid]->pid;
++++	//kprintf("Return val in fork:%d",*retval);
++++	return 0;
++++
++++	//flag=
++++	//flag=thread_fork=
++++}
++++
++++int sys_execv(char *progname, char** arguments) {
++++
++++	int flag;
++++	int numargs;
++++	int addr;
++++	int i;
++++	// first we need to copy the program name to the kernel space
++++	// then we go for arguments. Path size unknown
++++
++++	size_t actual_size = 0;
++++	char *namedes;
++++
++++	if (progname == NULL ) {
++++		return EFAULT;
++++	}
++++	if (progname == "") {
++++		return EINVAL;
++++	}
++++
++++	namedes = (char*) kmalloc(PATH_MAX);
++++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++++			&actual_size);
++++	if (flag != 0) {
++++		kfree(namedes);
++++		return flag;
++++	}
++++	//namedes[actual_size]
++++	if (strlen(namedes) == 0) {
++++		//*retval=1;
++++		return EISDIR;
++++	}
++++
++++	// now we open file using vfs_open. Same as runprogram
++++	struct vnode* vn;
++++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++++	if (flag) {
++++		return flag;
++++	}
++++	actual_size = 0;
++++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++++
++++	//char** kargv=(char**)kmalloc(sizeof(char));
++++	// get the number of arguments
++++	if (arguments == NULL ) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++++	if (flag) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++
++++	//check=wthread->exitcode;
++++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++++	//if(err)
++++	//{
++++	//	lock_release(p_table[i]->tlock);
++++	//return err;
++++	//}
++++
++++	numargs = 0;
++++	while (arguments[numargs] != NULL ) {
++++		//kprintf("%");
++++		numargs = numargs + 1;
++++	}
++++
++++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++++	//int i;
++++	for (i = 0; i < numargs; i++) {
++++		actual_size = 0;
++++		kargv[i] = (char*) kmalloc(PATH_MAX);
++++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++++				&actual_size);
++++		if (flag) {
++++			kfree(kargv);
++++			kfree(namedes);
++++			return EFAULT;
++++		}
++++
++++	}
++++	actual_size = 0;
++++
++++	curthread->t_addrspace = as_create();
++++	if (curthread->t_addrspace == NULL ) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	vaddr_t entrypoint, stackptr;
++++	as_activate(curthread->t_addrspace);
++++	flag = load_elf(vn, &entrypoint);
++++	if (flag) {
++++		// thread_exit destroys curthread->t_addrspace
++++		vfs_close(vn);
++++		return flag;
++++	}
++++
++++	vfs_close(vn);
++++
++++	// now set up the user stack with the arguments
++++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++++	if (flag) {
++++		//thread_exit destroys curthread->t_addrspace
++++		return flag;
++++	}
++++
++++	//i=0;
++++	vaddr_t stackptrv[numargs + 1];
++++	for (i = numargs - 1; i >= 0; i--) {
++++		int len = strlen(kargv[i]);
++++		int padder=0;
++++		len++;// to account for string terminator
++++		if(len%4!=0)
++++		padder = len % 4;
++++		stackptr =stackptr-(len + padder);
++++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++++				&actual_size);
++++
++++		if (flag)
++++		{
++++			kfree(kargv);
++++			kfree(namedes);
++++			return flag;
++++		}
++++
++++		stackptrv[i] = stackptr;
++++	}
++++	stackptrv[numargs] = 0;
++++
++++	//This copies the actual stack addresses of the arguments
++++	//* into the stack. Hopefully.
++++
++++	 for(i = numargs; i >= 0; i--)
++++	 {
++++	 stackptr -= sizeof(vaddr_t);
++++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++
++++	 if(flag)
++++	 {
++++	 kfree(kargv);
++++	 kfree(namedes);
++++	 return flag;
++++	 }
++++
++++	 }
++++
++++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++++	//pt_getthread();
++++
++++	//enter_new_process does not return.
++++	panic("enter_new_process returned\n");
++++	return EINVAL;
++++
++++}
++++
++++int sys_getpid(pid_t *retval) {
++++	//kprintf("In get pid:%d\n",curthread->pid);
++++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++++
++++	*retval = curthread->proc->pid;
++++	return 0;
++++}
++++
++++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++++	struct process* wthread = NULL;
++++	int check;
++++	int err;
++++	pid_t i;
++++	//kprintf("PID in wait pid:%d\n",pid);
++++	if (status == NULL )
++++		return EFAULT;
++++	if (options != 0)
++++		return EINVAL;
++++	if (pid == curthread->pid)
++++		return ECHILD;
++++	if (pid < PID_MIN || pid > PID_MAX)
++++		return ESRCH;
++++	if (status == NULL )
++++		return EFAULT;
++++	if (pid == curthread->proc->ppid)
++++		return ECHILD;
++++	//int *shit;
++++	//*shit=(int)&status;
++++	//kprintf("%d\n",*shit);
++++	//if(curthread->)
++++	//if(pid!=curthread->)
++++	//char* argv=(char*)(status);
++++	//int length=strlen(argv)+1;
++++	//int length=strlen(kargv[i])+1;
++++	//int padder=length%4;
++++	//kprintf("Hai:%d\n",padder);
++++	//if(padder!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++
++++	//if()
++++
++++	//char pathbuf[PATH_MAX];
++++	//int *buffer;
++++	//int result;
++++
++++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++++	//if (result) {
++++	//return result;
++++	//}
++++	//int addr=(int)&status;
++++	//kprintf("Status:%d\n",addr);
++++	//int *addr=&status;
++++	//if(addr%4!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++	//kprintf("Got Here\n");
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				wthread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++	if (wthread == NULL ) {
++++		return ESRCH;
++++	}
++++	if (curthread->proc->pid != wthread->ppid)
++++		return ECHILD;
++++	//panic("We are here");
++++
++++	lock_acquire(p_table[i]->tlock);
++++
++++	//while(!wthread->exited)
++++	//{
++++//
++++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++++	//}
++++	mywait(wthread);
++++
++++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++++	//kprintf("We are here!");
++++
++++	check = wthread->exitcode;
++++	err = copyout(&check, (userptr_t) status, sizeof(check));
++++	if (err) {
++++		lock_release(p_table[i]->tlock);
++++		return err;
++++	}
++++	//kprintf("Exit code After waiting:%d\n",*status);
++++	//kfree(p_table[i]->exitsem);
++++	//p_table[i]=NULL;
++++
++++	//panic("After kfree");
++++	//p_table[i]=NULL;
++++	lock_release(p_table[i]->tlock);
++++	//filetable_destroy(p_table[i]->self->t_filetable);
++++	//lock_destroy(p_table[i]->tlock);
++++	//cv_destroy(p_table[i]->wcv);
++++	//kfree(p_table[i]);
++++	p_table[i] = NULL;
++++
++++	*retval = pid;
++++	//panic("After dereferencing");
++++	return 0;
++++
++++	//return -1;
++++	//return 0;
++++}
++++
++++void sys_exit(int exitcode) {
++++	pid_t pid = curthread->proc->pid;
++++	pid_t i = PID_MIN;
++++	struct process* ethread;
++++//pid_t parent;
++++//if(pid!=2)
++++//{
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				ethread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++
++++//parent=ethread->ppid;
++++	if (ethread != NULL ) {
++++		lock_acquire(ethread->tlock);
++++//kprintf("Exit code Before:%d\n",exitcode);
++++
++++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++++		ethread->exited = 1;
++++//p_table[i]=ethread;
++++		cv_broadcast(ethread->wcv, ethread->tlock);
++++//kfree(curthread->t_filetable);
++++		lock_release(ethread->tlock);
++++	}
++++//}
++++	i = 0;
++++//
++++//kprintf("Before hanging");
++++//filetable_destroy(curthread->t_filetable);
++++//kfree(curthread->p);
++++
++++	thread_exit();
++++}
++++
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..1ada408 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,8 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
++++#include<copyinout.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -52,7 +54,7 @@
+++  * Calls vfs_open on progname and thus may destroy it.
+++  */
+++ int
+++-runprogram(char *progname)
++++runprogram(char *progname,char**argv,unsigned long argc)
+++ {
+++ 	struct vnode *v;
+++ 	vaddr_t entrypoint, stackptr;
+++@@ -66,6 +68,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	curthread->t_filetable=NULL;
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++@@ -94,9 +103,40 @@ runprogram(char *progname)
+++ 		/* thread_exit destroys curthread->t_addrspace */
+++ 		return result;
+++ 	}
++++	vaddr_t stackptrv[argc+1];
++++int i;
++++size_t actual;
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(argv[i]);
++++int padder=0;
++++len++;
++++if(len%4!=0)
++++padder = len % 4;
++++stackptr=stackptr-(len + padder);
++++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++return result;
++++}
++++}
++++
++++
++++
+++ 
+++ 	/* Warp to user mode. */
+++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++++	enter_new_process(argc, (userptr_t)stackptr,
+++ 			  stackptr, entrypoint);
+++ 	
+++ 	/* enter_new_process does not return. */
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..851f9ea 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -40,6 +40,8 @@
+++ #include <current.h>
+++ #include <synch.h>
+++ 
++++#define MAXREADERS 20;
++++
+++ ////////////////////////////////////////////////////////////
+++ //
+++ // Semaphore.
+++@@ -162,9 +164,17 @@ lock_create(const char *name)
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
+++-        // add stuff here as needed
+++-        
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
+++         return lock;
+++ }
+++ 
+++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+++ 
+++         // add stuff here as needed
+++         
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
+++         kfree(lock->lk_name);
+++         kfree(lock);
+++ }
+++@@ -183,26 +195,78 @@ void
+++ lock_acquire(struct lock *lock)
+++ {
+++         // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(&lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -225,7 +289,18 @@ cv_create(const char *name)
+++                 kfree(cv);
+++                 return NULL;
+++         }
+++-        
++++        cv->cv_wchan = wchan_create(cv->cv_name);
++++                	if (cv->cv_wchan == NULL) {
++++                		kfree(cv->cv_name);
++++                		kfree(cv);
++++                		return NULL;
++++                	}
++++
++++                	//spinlock_init(&cv->cv_lock);
++++                        //lock->hold = 0;
++++        		//lock->holder=NULL;
++++                //lock->=NULL
++++                return cv;
+++         // add stuff here as needed
+++         
+++         return cv;
+++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+++ 
+++         // add stuff here as needed
+++         
++++        //spinlock_cleanup(&cv->cv_lock);
++++        
++++        wchan_destroy(cv->cv_wchan);
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++ }
+++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	//KASSERT(lock_do_i_hold(lock));
++++	wchan_lock(cv->cv_wchan);
++++	lock_release(lock);
++++	
++++	wchan_sleep(cv->cv_wchan);
++++	lock_acquire(lock);
++++	
++++    // Write this
++++    //(void)cv;    // suppress warning until code gets written
++++    //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++         // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeone(cv->cv_wchan);
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeall(cv->cv_wchan);
++++		
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
++++}
++++
++++struct rwlock *rwlock_create(const char *name)
++++{
++++	struct rwlock *rw;
++++	rw=kmalloc(sizeof(struct rwlock));
++++	if(rw==NULL)
++++	{
++++		return NULL;
++++	}
++++	rw->rwlock_name=kstrdup(name);
++++	if(rw->rwlock_name==NULL)
++++	{
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++++	if(rw->rd_wchan==NULL)
++++	{
++++		kfree(rw->rwlock_name);
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++++		if(rw->wr_wchan==NULL)
++++		{
++++			kfree(rw->rwlock_name);
++++			kfree(rw);
++++			return NULL;
++++		}
++++		rw->rw_sem=sem_create("mysem",20);
++++		rw->rw_lock=lock_create("mylock");
++++	///rw->res_count=MAXREADERS;
++++	return rw;
++++	
++++}
++++void rwlock_destroy(struct rwlock *rw)
++++{
++++		KASSERT(rw != NULL);
++++		
++++		wchan_destroy(rw->rd_wchan);
++++		wchan_destroy(rw->wr_wchan);
++++		sem_destroy(rw->rw_sem);
++++		lock_destroy(rw->rw_lock);
++++	    kfree(rw->rwlock_name);
++++        kfree(rw);	
++++}
++++
++++void rwlock_acquire_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	P(rw->rw_sem);
++++	lock_release(rw->rw_lock);
++++}
++++void rwlock_release_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	V(rw->rw_sem);
++++	//lock_release(rw->rw_lock);
++++}
++++void rwlock_acquire_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	//rwlock->rw_sem->V();
++++	for(i=0;i<20;i++)
++++	{
++++	P(rw->rw_sem);
++++	}	
++++	lock_release(rw->rw_lock);
++++	
++++	
+++ }
++++void rwlock_release_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	for(i=0;i<20;i++)
++++	{
++++	V(rw->rw_sem);
++++	}	
++++	//lock_release(rw->rw_lock);
++++	
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+++new file mode 100644
+++index 0000000..b9680d1
+++--- /dev/null
++++++ b/kern/thread/synch.c~
+++@@ -0,0 +1,329 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Synchronization primitives.
++++ * The specifications of the functions are in synch.h.
++++ */
++++
++++#include <types.h>
++++#include <lib.h>
++++#include <spinlock.h>
++++#include <wchan.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Semaphore.
++++
++++struct semaphore *
++++sem_create(const char *name, int initial_count)
++++{
++++        struct semaphore *sem;
++++
++++        KASSERT(initial_count >= 0);
++++
++++        sem = kmalloc(sizeof(struct semaphore));
++++        if (sem == NULL) {
++++                return NULL;
++++        }
++++
++++        sem->sem_name = kstrdup(name);
++++        if (sem->sem_name == NULL) {
++++                kfree(sem);
++++                return NULL;
++++        }
++++
++++	sem->sem_wchan = wchan_create(sem->sem_name);
++++	if (sem->sem_wchan == NULL) {
++++		kfree(sem->sem_name);
++++		kfree(sem);
++++		return NULL;
++++	}
++++
++++	spinlock_init(&sem->sem_lock);
++++        sem->sem_count = initial_count;
++++
++++        return sem;
++++}
++++
++++void
++++sem_destroy(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	/* wchan_cleanup will assert if anyone's waiting on it */
++++	spinlock_cleanup(&sem->sem_lock);
++++	wchan_destroy(sem->sem_wchan);
++++        kfree(sem->sem_name);
++++        kfree(sem);
++++}
++++
++++void 
++++P(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++        /*
++++         * May not block in an interrupt handler.
++++         *
++++         * For robustness, always check, even if we can actually
++++         * complete the P without blocking.
++++         */
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++        while (sem->sem_count == 0) {
++++		/*
++++		 * Bridge to the wchan lock, so if someone else comes
++++		 * along in V right this instant the wakeup can't go
++++		 * through on the wchan until we've finished going to
++++		 * sleep. Note that wchan_sleep unlocks the wchan.
++++		 *
++++		 * Note that we don't maintain strict FIFO ordering of
++++		 * threads going through the semaphore; that is, we
++++		 * might "get" it on the first try even if other
++++		 * threads are waiting. Apparently according to some
++++		 * textbooks semaphores must for some reason have
++++		 * strict ordering. Too bad. :-)
++++		 *
++++		 * Exercise: how would you implement strict FIFO
++++		 * ordering?
++++		 */
++++		wchan_lock(sem->sem_wchan);
++++		spinlock_release(&sem->sem_lock);
++++                wchan_sleep(sem->sem_wchan);
++++
++++		spinlock_acquire(&sem->sem_lock);
++++        }
++++        KASSERT(sem->sem_count > 0);
++++        sem->sem_count--;
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++void
++++V(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++
++++        sem->sem_count++;
++++        KASSERT(sem->sem_count > 0);
++++	wchan_wakeone(sem->sem_wchan);
++++
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Lock.
++++
++++struct lock *
++++lock_create(const char *name)
++++{
++++        struct lock *lock;
++++
++++        lock = kmalloc(sizeof(struct lock));
++++        if (lock == NULL) {
++++                return NULL;
++++        }
++++
++++        lock->lk_name = kstrdup(name);
++++        if (lock->lk_name == NULL) {
++++                kfree(lock);
++++                return NULL;
++++        }
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
++++        return lock;
++++}
++++
++++void
++++lock_destroy(struct lock *lock)
++++{
++++        KASSERT(lock != NULL);
++++
++++        // add stuff here as needed
++++        
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
++++        kfree(lock->lk_name);
++++        kfree(lock);
++++}
++++
++++void
++++lock_acquire(struct lock *lock)
++++{
++++        // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
++++
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++lock_release(struct lock *lock)
++++{
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
++++        // Write this
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++bool
++++lock_do_i_hold(struct lock *lock)
++++{
++++        // Write this
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// CV
++++
++++
++++struct cv *
++++cv_create(const char *name)
++++{
++++        struct cv *cv;
++++
++++        cv = kmalloc(sizeof(struct cv));
++++        if (cv == NULL) {
++++                return NULL;
++++        }
++++
++++        cv->cv_name = kstrdup(name);
++++        if (cv->cv_name==NULL) {
++++                kfree(cv);
++++                return NULL;
++++        }
++++        
++++        // add stuff here as needed
++++        
++++        return cv;
++++}
++++
++++void
++++cv_destroy(struct cv *cv)
++++{
++++        KASSERT(cv != NULL);
++++
++++        // add stuff here as needed
++++        
++++        kfree(cv->cv_name);
++++        kfree(cv);
++++}
++++
++++void
++++cv_wait(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++        (void)cv;    // suppress warning until code gets written
++++        (void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_signal(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_broadcast(struct cv *cv, struct lock *lock)
++++{
++++	// Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..df129b9 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+++ 
+++ /* Used to wait for secondary CPUs to come online. */
+++ static struct semaphore *cpu_startup_sem;
++++pid_t pidcount;
++++struct process* p_table[17];
+++ 
+++ ////////////////////////////////////////////////////////////
+++ 
+++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -352,8 +357,15 @@ thread_bootstrap(void)
+++ {
+++ 	struct cpu *bootcpu;
+++ 	struct thread *bootthread;
++++	int i;
+++ 
+++ 	cpuarray_init(&allcpus);
++++	pidcount=PID_MIN;
++++
++++	for(i=0;i<=16;i++)
++++	{
++++		p_table[i]=NULL;
++++	}
+++ 
+++ 	/*
+++ 	 * Create the cpu structure for the bootup CPU, the one we're
+++@@ -365,6 +377,7 @@ thread_bootstrap(void)
+++ 	 */
+++ 	bootcpu = cpu_create(0);
+++ 	bootthread = bootcpu->c_curthread;
++++	//bootthread->pid=PID_MIN;
+++ 
+++ 	/*
+++ 	 * Initializing curcpu and curthread is machine-dependent
+++@@ -519,7 +532,7 @@ thread_fork(const char *name,
+++ 	 * for the spllower() that will be done releasing it.
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++-
++++	//newthread->pid=pidcount++;
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 	switch (newstate) {
+++ 	    case S_RUN:
+++ 		panic("Illegal S_RUN in thread_switch\n");
+++-		break;
+++ 	    case S_READY:
+++ 		thread_make_runnable(cur, true /*have lock*/);
+++ 		break;
+++@@ -799,6 +811,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
+++diff --git a/single10.patch b/single10.patch
+++new file mode 100644
+++index 0000000..2267436
+++--- /dev/null
++++++ b/single10.patch
+++@@ -0,0 +1,915 @@
++++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++++index 0f773bd..68c73ff 100644
++++--- a/kern/arch/mips/syscall/syscall.c
+++++++ b/kern/arch/mips/syscall/syscall.c
++++@@ -32,6 +32,7 @@
++++ #include <kern/syscall.h>
++++ #include <lib.h>
++++ #include <mips/trapframe.h>
+++++#include <copyinout.h>
++++ #include <thread.h>
++++ #include <current.h>
++++ #include <syscall.h>
++++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++++ {
++++ 	int callno;
++++ 	int32_t retval;
+++++        int32_t retvalv1 = 0;
+++++        int64_t retval64;
++++ 	int err;
+++++        int32_t stackarg1;
++++ 
++++ 	KASSERT(curthread != NULL);
++++ 	KASSERT(curthread->t_curspl == 0);
++++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++++ 		err = sys___time((userptr_t)tf->tf_a0,
++++ 				 (userptr_t)tf->tf_a1);
++++ 		break;
+++++            case SYS_open:
+++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_read:
+++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_write:
+++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++				&retval);
+++++		break;
+++++	    case SYS_close:
+++++		err = sys_close(tf->tf_a0);
+++++		break;
+++++	    case SYS_lseek:
+++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++++                                stackarg1, &retval64);
+++++                retval = retval64 >> 32;
+++++                retvalv1 = (int) retval64;
+++++		break;
+++++	    case SYS_dup2:
+++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
+++++	    case SYS_chdir:
+++++		err = sys_chdir((userptr_t)tf->tf_a0);
+++++		break;
+++++	    case SYS___getcwd:
+++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
++++ 
++++ 	    /* Add stuff here */
++++  
++++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++++ 	else {
++++ 		/* Success. */
++++ 		tf->tf_v0 = retval;
+++++                tf->tf_v1 = retvalv1;
++++ 		tf->tf_a3 = 0;      /* signal no error */
++++ 	}
++++ 	
++++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++++index d527f61..e1d7682 100644
++++--- a/kern/conf/conf.kern
+++++++ b/kern/conf/conf.kern
++++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++++ file      syscall/loadelf.c
++++ file      syscall/runprogram.c
++++ file      syscall/time_syscalls.c
+++++file      syscall/file_syscalls.c
+++++file      syscall/file.c
++++ 
++++ #
++++ # Startup and initialization
++++diff --git a/kern/include/file.h b/kern/include/file.h
++++new file mode 100644
++++index 0000000..2c63bc2
++++--- /dev/null
+++++++ b/kern/include/file.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Declarations for file handle and file table management.
+++++ * New for SOL2.
+++++ */
+++++
+++++#ifndef _FILE_H_
+++++#define _FILE_H_
+++++
+++++#include <limits.h>
+++++
+++++struct lock;
+++++struct vnode;
+++++
+++++/*** openfile section ***/
+++++
+++++/* 
+++++ * openfile struct 
+++++ * note that there's not too much to keep track of, since the vnode does most
+++++ * of that.  note that it does require synchronization, because a single
+++++ * openfile can be shared between processes (filetable inheritance).
+++++ */
+++++struct openfile {
+++++	struct vnode *of_vnode;
+++++	
+++++	struct lock *of_lock;
+++++	off_t of_offset;
+++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++++	int of_refcount;
+++++};
+++++
+++++/* opens a file (must be kernel pointers in the args) */
+++++int file_open(char *filename, int flags, int mode, int *retfd);
+++++
+++++/* closes a file */
+++++int file_close(int fd);
+++++
+++++
+++++/*** file table section ***/
+++++
+++++/*
+++++ * filetable struct
+++++ * just an array of open files.  nice and simple.  doesn't require
+++++ * synchronization, because a table can only be owned by a single process (on
+++++ * inheritance in fork, the table is copied).
+++++ */
+++++struct filetable {
+++++	struct openfile *ft_openfiles[OPEN_MAX];
+++++};
+++++
+++++/* these all have an implicit arg of the curthread's filetable */
+++++int filetable_init(const char *inpath, const char *outpath, 
+++++		   const char *errpath);
+++++int filetable_copy(struct filetable **copy);
+++++int filetable_placefile(struct openfile *file, int *fd);
+++++int filetable_findfile(int fd, struct openfile **file);
+++++int filetable_dup2file(int oldfd, int newfd);
+++++void filetable_destroy(struct filetable *ft);
+++++
+++++#endif /* _FILE_H_ */
++++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++++index befd3d8..f3a01ad 100644
++++--- a/kern/include/syscall.h
+++++++ b/kern/include/syscall.h
++++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++++  * Prototypes for IN-KERNEL entry points for system call implementations.
++++  */
++++ 
+++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_close(int fd);
+++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++++int sys_dup2(int oldfd, int newfd, int *retval);
+++++int sys_chdir(userptr_t path);
+++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++++
++++ int sys_reboot(int code);
++++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++ 
++++diff --git a/kern/include/thread.h b/kern/include/thread.h
++++index 86706ca..08b8f8c 100644
++++--- a/kern/include/thread.h
+++++++ b/kern/include/thread.h
++++@@ -112,6 +112,7 @@ struct thread {
++++ 	struct vnode *t_cwd;		/* current working directory */
++++ 
++++ 	/* add more here as needed */
+++++  struct filetable *t_filetable;
++++ };
++++ 
++++ /* Call once during system startup to allocate data structures. */
++++diff --git a/kern/include/uio.h b/kern/include/uio.h
++++index 5d97c48..c9124e8 100644
++++--- a/kern/include/uio.h
+++++++ b/kern/include/uio.h
++++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++++ void uio_kinit(struct iovec *, struct uio *,
++++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++++ 
+++++void uio_uinit(struct iovec *, struct uio *,
+++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++++
++++ 
++++ #endif /* _UIO_H_ */
++++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++++index 594fe96..83ea620 100644
++++--- a/kern/lib/uio.c
+++++++ b/kern/lib/uio.c
++++@@ -153,6 +153,7 @@ void
++++ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++++ {
+++++	KASSERT(u);
++++ 	iov->iov_kbase = kbuf;
++++ 	iov->iov_len = len;
++++ 	u->uio_iov = iov;
++++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	u->uio_rw = rw;
++++ 	u->uio_space = NULL;
++++ }
+++++
+++++void
+++++uio_uinit(struct iovec *iov, struct uio *u,
+++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++++{
+++++	KASSERT(u);
+++++	iov->iov_ubase = ubuf;
+++++	iov->iov_len = len;
+++++  u->uio_iov = iov;
+++++	u->uio_iovcnt = 1;
+++++	u->uio_offset = pos;
+++++	u->uio_resid = len;
+++++	u->uio_segflg = UIO_USERSPACE;
+++++	u->uio_rw = rw;
+++++	u->uio_space = curthread->t_addrspace;
+++++}
++++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++++new file mode 100644
++++index 0000000..dc5ffe5
++++--- /dev/null
+++++++ b/kern/syscall/file.c
++++@@ -0,0 +1,341 @@
+++++/*
+++++ * File handles and file tables.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++
+++++/*** openfile functions ***/
+++++
+++++/*
+++++ * file_open
+++++ * opens a file, places it in the filetable, sets RETFD to the file
+++++ * descriptor. the pointer arguments must be kernel pointers.
+++++ * NOTE -- the passed in filename must be a mutable string.
+++++ */
+++++int
+++++file_open(char *filename, int flags, int mode, int *retfd)
+++++{
+++++	struct vnode *vn;
+++++	struct openfile *file;
+++++	int result;
+++++	
+++++	result = vfs_open(filename, flags, mode, &vn);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	file = kmalloc(sizeof(struct openfile));
+++++	if (file == NULL) {
+++++		vfs_close(vn);
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* initialize the file struct */
+++++	file->of_lock = lock_create("file lock");
+++++	if (file->of_lock == NULL) {
+++++		vfs_close(vn);
+++++		kfree(file);
+++++		return ENOMEM;
+++++	}
+++++	file->of_vnode = vn;
+++++	file->of_offset = 0;
+++++	file->of_accmode = flags & O_ACCMODE;
+++++	file->of_refcount = 1;
+++++
+++++	/* vfs_open checks for invalid access modes */
+++++	KASSERT(file->of_accmode==O_RDONLY ||
+++++	        file->of_accmode==O_WRONLY ||
+++++	        file->of_accmode==O_RDWR);
+++++
+++++	/* place the file in the filetable, getting the file descriptor */
+++++	result = filetable_placefile(file, retfd);
+++++	if (result) {
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++		vfs_close(vn);
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * file_doclose
+++++ * shared code for file_close and filetable_destroy
+++++ */
+++++static
+++++int
+++++file_doclose(struct openfile *file)
+++++{
+++++	lock_acquire(file->of_lock);
+++++
+++++	/* if this is the last close of this file, free it up */
+++++	if (file->of_refcount == 1) {
+++++		vfs_close(file->of_vnode);
+++++		lock_release(file->of_lock);
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++	}
+++++	else {
+++++		KASSERT(file->of_refcount > 1);
+++++		file->of_refcount--;
+++++		lock_release(file->of_lock);
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * file_close
+++++ * knock off the refcount, freeing the memory if it goes to 0.
+++++ */
+++++int
+++++file_close(int fd)
+++++{
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* find the file in the filetable */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	result = file_doclose(file);
+++++	if (result) {
+++++		/* leave file open for possible retry */
+++++		return result;
+++++	}
+++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++
+++++	return 0;
+++++}
+++++
+++++/*** filetable functions ***/
+++++
+++++/* 
+++++ * filetable_init
+++++ * pretty straightforward -- allocate the space, initialize to NULL.
+++++ * note that the one careful thing is to open the std i/o in order to
+++++ * get
+++++ * stdin  == 0
+++++ * stdout == 1
+++++ * stderr == 2
+++++ */
+++++int
+++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++++{
+++++	/* the filenames come from the kernel; assume reasonable length */
+++++	char path[32];
+++++	int result;
+++++	int fd;
+++++
+++++	/* make sure we can fit these */
+++++	KASSERT(strlen(inpath) < sizeof(path));
+++++	KASSERT(strlen(outpath) < sizeof(path));
+++++	KASSERT(strlen(errpath) < sizeof(path));
+++++	
+++++	/* catch memory leaks, repeated calls */
+++++	KASSERT(curthread->t_filetable == NULL);
+++++
+++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++++	if (curthread->t_filetable == NULL) {
+++++		return ENOMEM;
+++++	}
+++++	
+++++	/* NULL-out the table */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++	}
+++++
+++++	/*
+++++	 * open the std fds.  note that the names must be copied into
+++++	 * the path buffer so that they're mutable.
+++++	 */
+++++	strcpy(path, inpath);
+++++	result = file_open(path, O_RDONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, outpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, errpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_copy
+++++ * again, pretty straightforward.  the subtle business here is that instead of
+++++ * copying the openfile structure, we just increment the refcount.  this means
+++++ * that openfile structs will, in fact, be shared between processes, as in
+++++ * Unix.
+++++ */
+++++int
+++++filetable_copy(struct filetable **copy)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int fd;
+++++
+++++	/* waste of a call, really */
+++++	if (ft == NULL) {
+++++		*copy = NULL;
+++++		return 0;
+++++	}
+++++	
+++++	*copy = kmalloc(sizeof(struct filetable));
+++++	
+++++	if (*copy == NULL) {
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* copy over the entries */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd] != NULL) {
+++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++++			ft->ft_openfiles[fd]->of_refcount++;
+++++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++++		} 
+++++		else {
+++++			(*copy)->ft_openfiles[fd] = NULL;
+++++		}
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_destroy
+++++ * closes the files in the file table, frees the table.
+++++ */
+++++void
+++++filetable_destroy(struct filetable *ft)
+++++{
+++++	int fd, result;
+++++
+++++	KASSERT(ft != NULL);
+++++
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd]) {
+++++			result = file_doclose(ft->ft_openfiles[fd]);
+++++			KASSERT(result==0);
+++++		}
+++++	}
+++++	
+++++	kfree(ft);
+++++}	
+++++
+++++/* 
+++++ * filetable_placefile
+++++ * finds the smallest available file descriptor, places the file at the point,
+++++ * sets FD to it.
+++++ */
+++++int
+++++filetable_placefile(struct openfile *file, int *fd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int i;
+++++	
+++++	for (i = 0; i < OPEN_MAX; i++) {
+++++		if (ft->ft_openfiles[i] == NULL) {
+++++			ft->ft_openfiles[i] = file;
+++++			*fd = i;
+++++			return 0;
+++++		}
+++++	}
+++++
+++++	return EMFILE;
+++++}
+++++
+++++/*
+++++ * filetable_findfile
+++++ * verifies that the file descriptor is valid and actually references an
+++++ * open file, setting the FILE to the file at that index if it's there.
+++++ */
+++++int
+++++filetable_findfile(int fd, struct openfile **file)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++
+++++	if (fd < 0 || fd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++	
+++++	*file = ft->ft_openfiles[fd];
+++++	if (*file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_dup2file
+++++ * verifies that both file descriptors are valid, and that the OLDFD is
+++++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++++ */
+++++int
+++++filetable_dup2file(int oldfd, int newfd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++
+++++	file = ft->ft_openfiles[oldfd];
+++++	if (file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++++	if (oldfd == newfd) {
+++++		return 0;
+++++	}
+++++
+++++	/* closes the newfd if it's open */
+++++	if (ft->ft_openfiles[newfd] != NULL) {
+++++		result = file_close(newfd);
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
+++++
+++++	/* up the refcount */
+++++	lock_acquire(file->of_lock);
+++++	file->of_refcount++;
+++++	lock_release(file->of_lock);
+++++
+++++	/* doesn't need to be synchronized because it's just changing the ft */
+++++	ft->ft_openfiles[newfd] = file;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++++new file mode 100644
++++index 0000000..8aa024c
++++--- /dev/null
+++++++ b/kern/syscall/file_syscalls.c
++++@@ -0,0 +1,270 @@
+++++/*
+++++ * File-related system call implementations.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <kern/seek.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++#include <copyinout.h>
+++++
+++++/*
+++++ * sys_open
+++++ * just copies in the filename, then passes work to file_open.
+++++ */
+++++int
+++++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++++{
+++++	char fname[PATH_MAX];
+++++	int result;
+++++
+++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return file_open(fname, flags, mode, retval);
+++++}
+++++
+++++/*
+++++ * sys_read
+++++ * translates the fd into its openfile, then calls VOP_READ.
+++++ */
+++++int
+++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* better be a valid file descriptor */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_WRONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++++  
+++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++++
+++++	/* does the read */
+++++	result = VOP_READ(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++	
+++++	/*
+++++	 * The amount read is the size of the buffer originally, minus
+++++	 * how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * sys_write
+++++ * translates the fd into its openfile, then calls VOP_WRITE.
+++++ */
+++++int
+++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_RDONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++++	
+++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++++
+++++	/* does the write */
+++++	result = VOP_WRITE(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	/*
+++++	 * the amount written is the size of the buffer originally,
+++++	 * minus how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_close
+++++ * just pass off the work to file_close.
+++++ */
+++++int
+++++sys_close(int fd)
+++++{
+++++	return file_close(fd);
+++++}
+++++
+++++/*
+++++ * sys_lseek
+++++ * translates the fd into its openfile, then based on the type of seek,
+++++ * figure out the new offset, try the seek, if that succeeds, update the
+++++ * openfile.
+++++ */
+++++int
+++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++++{
+++++	struct stat info;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++	
+++++	/* based on the type of seek, set the retval */ 
+++++	switch (whence) {
+++++	    case SEEK_SET:
+++++		*retval = offset;
+++++		break;
+++++	    case SEEK_CUR:
+++++		*retval = file->of_offset + offset;
+++++		break;
+++++	    case SEEK_END:
+++++		result = VOP_STAT(file->of_vnode, &info);
+++++		if (result) {
+++++			lock_release(file->of_lock);
+++++			return result;
+++++		}
+++++		*retval = info.st_size + offset;
+++++		break;
+++++	    default:
+++++		lock_release(file->of_lock);
+++++		return EINVAL;
+++++	}
+++++
+++++	/* try the seek -- if it fails, return */
+++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++	
+++++	/* success -- update the file structure */
+++++	file->of_offset = *retval;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_dup2
+++++ * just pass the work off to the filetable
+++++ */
+++++int
+++++sys_dup2(int oldfd, int newfd, int *retval)
+++++{
+++++	int result;
+++++
+++++	result = filetable_dup2file(oldfd, newfd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = newfd;
+++++	return 0;
+++++}
+++++
+++++/* really not "file" calls, per se, but might as well put it here */
+++++
+++++/*
+++++ * sys_chdir
+++++ * copyin the path and pass it off to vfs.
+++++ */
+++++int
+++++sys_chdir(userptr_t path)
+++++{
+++++	char pathbuf[PATH_MAX];
+++++	int result;
+++++	
+++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return vfs_chdir(pathbuf);
+++++}
+++++
+++++/*
+++++ * sys___getcwd
+++++ * just use vfs_getcwd.
+++++ */
+++++int
+++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	int result;
+++++  
+++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	result = vfs_getcwd(&useruio);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = buflen - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++++index a6f45c8..4ba181a 100644
++++--- a/kern/syscall/runprogram.c
+++++++ b/kern/syscall/runprogram.c
++++@@ -44,6 +44,7 @@
++++ #include <vfs.h>
++++ #include <syscall.h>
++++ #include <test.h>
+++++#include <file.h>
++++ 
++++ /*
++++  * Load program "progname" and start running it in usermode.
++++@@ -66,6 +67,13 @@ runprogram(char *progname)
++++ 
++++ 	/* We should be a new thread. */
++++ 	KASSERT(curthread->t_addrspace == NULL);
+++++	
+++++  if (curthread->t_filetable == NULL) {
+++++		result = filetable_init("con:", "con:", "con:");
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
++++ 
++++ 	/* Create a new address sp
++\ No newline at end of file
++diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
++index 287a678..db31b89 100644
++--- a/user/testbin/badcall/bad_execv.c
+++++ b/user/testbin/badcall/bad_execv.c
++@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
++ 		return;
++ 	}
++ 
+++
++ 	rv = execv("/bin/true", args);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	exit(MAGIC_STATUS);
++diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
++index 809c68c..8eb69c3 100644
++--- a/user/testbin/badcall/bad_waitpid.c
+++++ b/user/testbin/badcall/bad_waitpid.c
++@@ -36,6 +36,7 @@
++ #include <unistd.h>
++ #include <errno.h>
++ #include <err.h>
+++#include<stdio.h>
++ 
++ #include "config.h"
++ #include "test.h"
++@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Hello:%d",(int)ptr);
++ 
++ 	rv = waitpid(pid, ptr, 0);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	waitpid(pid, &x, 0);
++ }
++ 
+++
++ static
++ void
++ wait_unaligned(void)
++@@ -85,13 +88,16 @@ wait_unaligned(void)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Aligned int:%d",&status);
++ 
++ 	/* start with proper integer alignment */
++ 	ptr = (char *)(&status[0]);
++-
+++	//printf("Aligned:%c\n",*ptr);
++ 	/* generate improper alignment on platforms with restrictions*/
++ 	ptr++;
++ 
+++	//Print("UnAligned:%c\n",*ptr);
+++
++ 	rv = waitpid(pid, (int *)ptr, 0);
++ 	report_survival(rv, errno, "wait with unaligned status");
++ 	if (rv<0) {
++diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
++new file mode 100644
++index 0000000..fe21882
++--- /dev/null
+++++ b/user/testbin/myforktest/Makefile
++@@ -0,0 +1,11 @@
+++# Makefile for forktest
+++
+++TOP=../../..
+++.include "$(TOP)/mk/os161.config.mk"
+++
+++PROG=myforktest
+++SRCS=myforktest.c
+++BINDIR=/testbin
+++
+++.include "$(TOP)/mk/os161.prog.mk"
+++
++diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
++new file mode 100644
++index 0000000..7bd6663
++--- /dev/null
+++++ b/user/testbin/myforktest/myforktest.c
++@@ -0,0 +1,33 @@
+++#include <unistd.h>
+++#include <string.h>
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <err.h>
+++
+++int main()
+++{
+++	int status;
+++	int pid;
+++	int childpid;
+++	int parent;
+++	int returnCode=fork();
+++
+++	if(returnCode==0)
+++	{
+++		childpid=getpid();
+++		printf("I am child:%d\n",childpid);
+++		return -10;
+++	}
+++	else
+++	{
+++		//printf("Return:%d",returnCode);
+++		//printf("Wait for child\n");
+++		parent=getpid();
+++		printf("I am parent:%d\n",parent);
+++		pid=waitpid(returnCode,&status,0);
+++		printf("Child id returned" "%d",pid);
+++		printf(" Return code: %d\n",status);
+++
+++	}
+++	return 0;
+++}
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/forkbomb/forkbomb.c b/user/testbin/forkbomb/forkbomb.c
+index 880027c..1e9b5cc 100644
+--- a/user/testbin/forkbomb/forkbomb.c
++++ b/user/testbin/forkbomb/forkbomb.c
+@@ -49,7 +49,7 @@
+ 
+ #include <unistd.h>
+ #include <err.h>
+-
++#include<stdio.h>
+ static volatile int pid;
+ 
+ int
+@@ -61,11 +61,12 @@ main()
+ 		fork();
+ 
+ 		pid = getpid();
+-
++		//printf("First:%d\n",pid);
+ 		/* Make sure each fork has its own address space. */
+ 		for (i=0; i<300; i++) {
+ 			volatile int seenpid;
+ 			seenpid = pid;
++			//printf("Second:%d\n",seenpid);
+ 			if (seenpid != getpid()) {
+ 				errx(1, "pid mismatch (%d, should be %d) "
+ 				     "- your vm is broken!", 
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/submitsys.patch b/submitsys.patch
new file mode 100644
index 0000000..232ffbf
--- /dev/null
+++ b/submitsys.patch
@@ -0,0 +1,12499 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..33b99ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	int flag;
++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	if(flag)
++	{
++		newtf.tf_v0=ENOMEM;
++		newtf.tf_a3=1;
++	}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	curthread->pid=newtf.tf_a0;
++
++	as_activate(curthread->t_addrspace);
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..a4c2750 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	fthread->proc->tlock=lock_create("First Lock");
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..dfd7b53
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,445 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro) {
++	//lock_acquire(mypro->tlock);
++	while (!mypro->exited) {
++		cv_wait(mypro->wcv, mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++	(void) adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++			sizeof(struct trapframe));
++	bzero(copyt, sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt, tf, sizeof(struct trapframe));
++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++	//if(curthread->pid==0)
++	//{
++	//curthread->pid=PID_MIN;
++	//}
++	if (flag) {
++		kfree(copyt);
++		return flag;
++	}
++
++	//we need to allocate pid for our new process
++
++	//pid_t cpid;
++	for (childid = 0; childid <= 16; childid++) {
++		if (p_table[childid] == NULL ) {
++			p_table[childid] = (struct process*) kmalloc(
++					sizeof(struct process));
++			p_table[childid]->full = 1;
++			pidcount++;
++			p_table[childid]->pid = pidcount;
++			p_table[childid]->ppid = curthread->pid;
++			//p_table[childid]->exitsem=sem_create("process",0);
++			p_table[childid]->tlock = lock_create("My Lock");
++			p_table[childid]->wcv = cv_create("My CV");
++			p_table[childid]->self = NULL;
++			break;
++		}
++	}
++	if (childid > PID_MAX) {
++		*retval = 1;
++		return EMPROC;
++	}
++	//int i;
++
++	copyt->tf_a0 = (int) p_table[childid]->pid;
++	//kprintf("Ret:%d\n",copyt->tf_a0);
++	struct thread *new_proc;
++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++	//int s=splhigh();
++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++			(unsigned long) adrcopy, &new_proc);
++	//kprintf("Out of thread fork:%d\n",flag);
++	if (flag) {
++		kfree(copyt);
++		as_destroy(adrcopy);
++
++		return flag;
++	}
++
++	//new_proc->pid=(pid_t)childid;
++	//new_proc=p_table[childid];
++
++	new_proc->pid = p_table[childid]->pid;
++	new_proc->proc = p_table[childid];
++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++	//if (new_proc->t_filetable == NULL) {
++	//return ENOMEM;
++	//}
++	p_table[childid]->self = new_proc;
++
++	//new_proc->pid=p_table[childid]->pid;
++	//new_proc->proc->pid=p_table[childid]->pid;
++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++
++	//kprintf("Child id:%d",new_proc->pid);
++	//new_proc->t_filetable->
++	//for(i=0;i<128;i++)
++	//{
++	flag = filetable_copy(&new_proc->t_filetable);
++	//}
++	//splx(s);
++	// kprintf("Fork over!");
++
++	*retval = p_table[childid]->pid;
++	//kprintf("Return val in fork:%d",*retval);
++	return 0;
++
++	//flag=
++	//flag=thread_fork=
++}
++
++int sys_execv(char *progname, char** arguments) {
++
++	int flag;
++	int numargs;
++	int addr;
++	int i;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size = 0;
++	char *namedes;
++
++	if (progname == NULL ) {
++		return EFAULT;
++	}
++	if (progname == "") {
++		return EINVAL;
++	}
++
++	namedes = (char*) kmalloc(PATH_MAX);
++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++			&actual_size);
++	if (flag != 0) {
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if (strlen(namedes) == 0) {
++		//*retval=1;
++		return EISDIR;
++	}
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++	if (flag) {
++		return flag;
++	}
++	actual_size = 0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++	if (arguments == NULL ) {
++		kfree(namedes);
++		return EFAULT;
++	}
++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++	if (flag) {
++		kfree(namedes);
++		return EFAULT;
++	}
++
++	//check=wthread->exitcode;
++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++	//if(err)
++	//{
++	//	lock_release(p_table[i]->tlock);
++	//return err;
++	//}
++
++	numargs = 0;
++	while (arguments[numargs] != NULL ) {
++		//kprintf("%");
++		numargs = numargs + 1;
++	}
++
++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++	//int i;
++	for (i = 0; i < numargs; i++) {
++		actual_size = 0;
++		kargv[i] = (char*) kmalloc(PATH_MAX);
++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++				&actual_size);
++		if (flag) {
++			kfree(kargv);
++			kfree(namedes);
++			return EFAULT;
++		}
++
++	}
++	actual_size = 0;
++
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace == NULL ) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++	if (flag) {
++		// thread_exit destroys curthread->t_addrspace
++		vfs_close(vn);
++		return flag;
++	}
++
++	vfs_close(vn);
++
++	// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (flag) {
++		//thread_exit destroys curthread->t_addrspace
++		return flag;
++	}
++
++	//i=0;
++	vaddr_t stackptrv[numargs + 1];
++	for (i = numargs - 1; i >= 0; i--) {
++		int len = strlen(kargv[i]);
++		int padder=0;
++		len++;// to account for string terminator
++		if(len%4!=0)
++		padder = len % 4;
++		stackptr =stackptr-(len + padder);
++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++				&actual_size);
++
++		if (flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return flag;
++		}
++
++		stackptrv[i] = stackptr;
++	}
++	stackptrv[numargs] = 0;
++
++	//This copies the actual stack addresses of the arguments
++	//* into the stack. Hopefully.
++
++	 for(i = numargs; i >= 0; i--)
++	 {
++	 stackptr -= sizeof(vaddr_t);
++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++
++	 if(flag)
++	 {
++	 kfree(kargv);
++	 kfree(namedes);
++	 return flag;
++	 }
++
++	 }
++
++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++	//pt_getthread();
++
++	//enter_new_process does not return.
++	panic("enter_new_process returned\n");
++	return EINVAL;
++
++}
++
++int sys_getpid(pid_t *retval) {
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval = curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++	struct process* wthread = NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if (status == NULL )
++		return EFAULT;
++	if (options != 0)
++		return EINVAL;
++	if (pid == curthread->pid)
++		return ECHILD;
++	if (pid < PID_MIN || pid > PID_MAX)
++		return ESRCH;
++	if (status == NULL )
++		return EFAULT;
++	if (pid == curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++	//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++	//return EFAULT;
++	//}
++
++	//if()
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++	//if (result) {
++	//return result;
++	//}
++	//int addr=(int)&status;
++	//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++	//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				wthread = p_table[i];
++				break;
++			}
++		}
++	}
++	if (wthread == NULL ) {
++		return ESRCH;
++	}
++	if (curthread->proc->pid != wthread->ppid)
++		return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check = wthread->exitcode;
++	err = copyout(&check, (userptr_t) status, sizeof(check));
++	if (err) {
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i] = NULL;
++
++	*retval = pid;
++	//panic("After dereferencing");
++	return 0;
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode) {
++	pid_t pid = curthread->proc->pid;
++	pid_t i = PID_MIN;
++	struct process* ethread;
++//pid_t parent;
++//if(pid!=2)
++//{
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				ethread = p_table[i];
++				break;
++			}
++		}
++	}
++
++//parent=ethread->ppid;
++	if (ethread != NULL ) {
++		lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++		ethread->exited = 1;
++//p_table[i]=ethread;
++		cv_broadcast(ethread->wcv, ethread->tlock);
++//kfree(curthread->t_filetable);
++		lock_release(ethread->tlock);
++	}
++//}
++	i = 0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++	thread_exit();
++}
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..1ada408 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,40 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++int padder=0;
++len++;
++if(len%4!=0)
++padder = len % 4;
++stackptr=stackptr-(len + padder);
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..df129b9 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +357,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +377,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +532,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +811,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..04fc72b
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,8279 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..dfd7b53
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,445 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro) {
+++	//lock_acquire(mypro->tlock);
+++	while (!mypro->exited) {
+++		cv_wait(mypro->wcv, mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+++	(void) adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt = (struct trapframe*) kmalloc(
+++			sizeof(struct trapframe));
+++	bzero(copyt, sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt, tf, sizeof(struct trapframe));
+++	flag = as_copy(curthread->t_addrspace, &adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++	//curthread->pid=PID_MIN;
+++	//}
+++	if (flag) {
+++		kfree(copyt);
+++		return flag;
+++	}
+++
+++	//we need to allocate pid for our new process
+++
+++	//pid_t cpid;
+++	for (childid = 0; childid <= 16; childid++) {
+++		if (p_table[childid] == NULL ) {
+++			p_table[childid] = (struct process*) kmalloc(
+++					sizeof(struct process));
+++			p_table[childid]->full = 1;
+++			pidcount++;
+++			p_table[childid]->pid = pidcount;
+++			p_table[childid]->ppid = curthread->pid;
+++			//p_table[childid]->exitsem=sem_create("process",0);
+++			p_table[childid]->tlock = lock_create("My Lock");
+++			p_table[childid]->wcv = cv_create("My CV");
+++			p_table[childid]->self = NULL;
+++			break;
+++		}
+++	}
+++	if (childid > PID_MAX) {
+++		*retval = 1;
+++		return EMPROC;
+++	}
+++	//int i;
+++
+++	copyt->tf_a0 = (int) p_table[childid]->pid;
+++	//kprintf("Ret:%d\n",copyt->tf_a0);
+++	struct thread *new_proc;
+++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+++	//int s=splhigh();
+++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+++			(unsigned long) adrcopy, &new_proc);
+++	//kprintf("Out of thread fork:%d\n",flag);
+++	if (flag) {
+++		kfree(copyt);
+++		as_destroy(adrcopy);
+++
+++		return flag;
+++	}
+++
+++	//new_proc->pid=(pid_t)childid;
+++	//new_proc=p_table[childid];
+++
+++	new_proc->pid = p_table[childid]->pid;
+++	new_proc->proc = p_table[childid];
+++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++	//if (new_proc->t_filetable == NULL) {
+++	//return ENOMEM;
+++	//}
+++	p_table[childid]->self = new_proc;
+++
+++	//new_proc->pid=p_table[childid]->pid;
+++	//new_proc->proc->pid=p_table[childid]->pid;
+++	//kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++	//kprintf("Child id:%d",new_proc->pid);
+++	//new_proc->t_filetable->
+++	//for(i=0;i<128;i++)
+++	//{
+++	flag = filetable_copy(&new_proc->t_filetable);
+++	//}
+++	//splx(s);
+++	// kprintf("Fork over!");
+++
+++	*retval = p_table[childid]->pid;
+++	//kprintf("Return val in fork:%d",*retval);
+++	return 0;
+++
+++	//flag=
+++	//flag=thread_fork=
+++}
+++
+++int sys_execv(char *progname, char** arguments) {
+++
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size = 0;
+++	char *namedes;
+++
+++	if (progname == NULL ) {
+++		return EFAULT;
+++	}
+++	if (progname == "") {
+++		return EINVAL;
+++	}
+++
+++	namedes = (char*) kmalloc(PATH_MAX);
+++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+++			&actual_size);
+++	if (flag != 0) {
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if (strlen(namedes) == 0) {
+++		//*retval=1;
+++		return EISDIR;
+++	}
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+++	if (flag) {
+++		return flag;
+++	}
+++	actual_size = 0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if (arguments == NULL ) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+++	if (flag) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++	//return err;
+++	//}
+++
+++	numargs = 0;
+++	while (arguments[numargs] != NULL ) {
+++		//kprintf("%");
+++		numargs = numargs + 1;
+++	}
+++
+++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+++	//int i;
+++	for (i = 0; i < numargs; i++) {
+++		actual_size = 0;
+++		kargv[i] = (char*) kmalloc(PATH_MAX);
+++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+++				&actual_size);
+++		if (flag) {
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size = 0;
+++
+++	curthread->t_addrspace = as_create();
+++	if (curthread->t_addrspace == NULL ) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++	if (flag) {
+++		// thread_exit destroys curthread->t_addrspace
+++		vfs_close(vn);
+++		return flag;
+++	}
+++
+++	vfs_close(vn);
+++
+++	// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++	if (flag) {
+++		//thread_exit destroys curthread->t_addrspace
+++		return flag;
+++	}
+++
+++	//i=0;
+++	vaddr_t stackptrv[numargs + 1];
+++	for (i = numargs - 1; i >= 0; i--) {
+++		int len = strlen(kargv[i]);
+++		int padder=0;
+++		len++;// to account for string terminator
+++		if(len%4!=0)
+++		padder = len % 4;
+++		stackptr =stackptr-(len + padder);
+++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+++				&actual_size);
+++
+++		if (flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return flag;
+++		}
+++
+++		stackptrv[i] = stackptr;
+++	}
+++	stackptrv[numargs] = 0;
+++
+++	//This copies the actual stack addresses of the arguments
+++	//* into the stack. Hopefully.
+++
+++	 for(i = numargs; i >= 0; i--)
+++	 {
+++	 stackptr -= sizeof(vaddr_t);
+++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++
+++	 if(flag)
+++	 {
+++	 kfree(kargv);
+++	 kfree(namedes);
+++	 return flag;
+++	 }
+++
+++	 }
+++
+++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+++	//pt_getthread();
+++
+++	//enter_new_process does not return.
+++	panic("enter_new_process returned\n");
+++	return EINVAL;
+++
+++}
+++
+++int sys_getpid(pid_t *retval) {
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval = curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+++	struct process* wthread = NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if (status == NULL )
+++		return EFAULT;
+++	if (options != 0)
+++		return EINVAL;
+++	if (pid == curthread->pid)
+++		return ECHILD;
+++	if (pid < PID_MIN || pid > PID_MAX)
+++		return ESRCH;
+++	if (status == NULL )
+++		return EFAULT;
+++	if (pid == curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++	//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++
+++	//if()
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++	//if (result) {
+++	//return result;
+++	//}
+++	//int addr=(int)&status;
+++	//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				wthread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++	if (wthread == NULL ) {
+++		return ESRCH;
+++	}
+++	if (curthread->proc->pid != wthread->ppid)
+++		return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check = wthread->exitcode;
+++	err = copyout(&check, (userptr_t) status, sizeof(check));
+++	if (err) {
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i] = NULL;
+++
+++	*retval = pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode) {
+++	pid_t pid = curthread->proc->pid;
+++	pid_t i = PID_MIN;
+++	struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				ethread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++
+++//parent=ethread->ppid;
+++	if (ethread != NULL ) {
+++		lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++		ethread->exited = 1;
+++//p_table[i]=ethread;
+++		cv_broadcast(ethread->wcv, ethread->tlock);
+++//kfree(curthread->t_filetable);
+++		lock_release(ethread->tlock);
+++	}
+++//}
+++	i = 0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++	thread_exit();
+++}
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..1ada408 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,40 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++int padder=0;
+++len++;
+++if(len%4!=0)
+++padder = len % 4;
+++stackptr=stackptr-(len + padder);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index 5b8099e..60108d3 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -798,6 +801,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..e07fb23
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,4058 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..33b99ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,11 +32,14 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <addrspace.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
+++ 
++++
+++ /*
+++  * System call dispatcher.
+++  *
+++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++                break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++			break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_fork:
++++	    	err=0;
++++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++++	    	break;
++++	    case SYS_execv:
++++	    	err=0;
++++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++++	    	break;
++++	    case SYS_getpid:
++++	    	err=0;
++++	    	err=sys_getpid(&retval);
++++	    	break;
++++	    case SYS_waitpid:
++++	    	err=0;
++++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++	    	//panic("Waitpid over");
++++	    	break;
++++	    case SYS__exit:
++++	    	sys_exit((int)tf->tf_a0);
++++	    	break;
++++
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+++  *
+++  * Thus, you can trash it and do things another way if you prefer.
+++  */
+++-void
+++-enter_forked_process(struct trapframe *tf)
++++//void
++++//enter_forked_process(struct trapframe *tf)
++++//{
++++	//(void)tf;
++++//}
++++
++++void enter_forked_process(void*tf,unsigned long adrspace)
+++ {
+++-	(void)tf;
++++	tf=(struct trapframe*)tf;
++++	struct trapframe newtf;
++++	int flag;
++++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++++	if(flag)
++++	{
++++		newtf.tf_v0=ENOMEM;
++++		newtf.tf_a3=1;
++++	}
++++
++++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++++	kfree(tf);
++++	//tf=NULL;
++++	//int flag;
++++
++++	curthread->pid=newtf.tf_a0;
++++
++++	as_activate(curthread->t_addrspace);
++++
++++
++++
++++	newtf.tf_v0=0;
++++	newtf.tf_a3=0;
++++	newtf.tf_epc+=4;
++++	mips_usermode(&newtf);
+++ }
+++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+++new file mode 100644
+++index 0000000..3e8d5b9
+++--- /dev/null
++++++ b/kern/arch/mips/syscall/syscall.c~
+++@@ -0,0 +1,165 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/syscall.h>
++++#include <lib.h>
++++#include <mips/trapframe.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <syscall.h>
++++
++++
++++/*
++++ * System call dispatcher.
++++ *
++++ * A pointer to the trapframe created during exception entry (in
++++ * exception.S) is passed in.
++++ *
++++ * The calling conventions for syscalls are as follows: Like ordinary
++++ * function calls, the first 4 32-bit arguments are passed in the 4
++++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++++ * unused.
++++ *
++++ * This much is the same as the calling conventions for ordinary
++++ * function calls. In addition, the system call number is passed in
++++ * the v0 register.
++++ *
++++ * On successful return, the return value is passed back in the v0
++++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++++ * function call, and additionally the a3 register is also set to 0 to
++++ * indicate success.
++++ *
++++ * On an error return, the error code is passed back in the v0
++++ * register, and the a3 register is set to 1 to indicate failure.
++++ * (Userlevel code takes care of storing the error code in errno and
++++ * returning the value -1 from the actual userlevel syscall function.
++++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++++ *
++++ * Upon syscall return the program counter stored in the trapframe
++++ * must be incremented by one instruction; otherwise the exception
++++ * return code will restart the "syscall" instruction and the system
++++ * call will repeat forever.
++++ *
++++ * If you run out of registers (which happens quickly with 64-bit
++++ * values) further arguments must be fetched from the user-level
++++ * stack, starting at sp+16 to skip over the slots for the
++++ * registerized values, with copyin().
++++ */
++++void
++++syscall(struct trapframe *tf)
++++{
++++	int callno;
++++	int32_t retval;
++++	int err;
++++
++++	KASSERT(curthread != NULL);
++++	KASSERT(curthread->t_curspl == 0);
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++
++++	callno = tf->tf_v0;
++++
++++	/*
++++	 * Initialize retval to 0. Many of the system calls don't
++++	 * really return a value, just 0 for success and -1 on
++++	 * error. Since retval is the value returned on success,
++++	 * initialize it to 0 by default; thus it's not necessary to
++++	 * deal with it except for calls that return other values, 
++++	 * like write.
++++	 */
++++
++++	retval = 0;
++++
++++	switch (callno) {
++++	    case SYS_reboot:
++++		err = sys_reboot(tf->tf_a0);
++++		break;
++++
++++	    case SYS___time:
++++		err = sys___time((userptr_t)tf->tf_a0,
++++				 (userptr_t)tf->tf_a1);
++++		break;
++++		
++++	    case SYS_open:
++++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++++	    break;
++++
++++	    /* Add stuff here */
++++ 
++++	    default:
++++		kprintf("Unknown syscall %d\n", callno);
++++		err = ENOSYS;
++++		break;
++++	}
++++
++++
++++	if (err) {
++++		/*
++++		 * Return the error code. This gets converted at
++++		 * userlevel to a return value of -1 and the error
++++		 * code in errno.
++++		 */
++++		tf->tf_v0 = err;
++++		tf->tf_a3 = 1;      /* signal an error */
++++	}
++++	else {
++++		/* Success. */
++++		tf->tf_v0 = retval;
++++		tf->tf_a3 = 0;      /* signal no error */
++++	}
++++	
++++	/*
++++	 * Now, advance the program counter, to avoid restarting
++++	 * the syscall over and over again.
++++	 */
++++	
++++	tf->tf_epc += 4;
++++
++++	/* Make sure the syscall code didn't forget to lower spl */
++++	KASSERT(curthread->t_curspl == 0);
++++	/* ...or leak any spinlocks */
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++}
++++
++++/*
++++ * Enter user mode for a newly forked process.
++++ *
++++ * This function is provided as a reminder. You need to write
++++ * both it and the code that calls it.
++++ *
++++ * Thus, you can trash it and do things another way if you prefer.
++++ */
++++void
++++enter_forked_process(struct trapframe *tf)
++++{
++++	(void)tf;
++++}
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..7d5df71 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,9 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
++++file	  syscall/proc_sys.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/limits.h b/kern/include/limits.h
+++index 01684c4..3a54e24 100644
+++--- a/kern/include/limits.h
++++++ b/kern/include/limits.h
+++@@ -48,5 +48,6 @@
+++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+++ #define OPEN_MAX        __OPEN_MAX
+++ #define IOV_MAX         __IOV_MAX
++++//#define OPEN_MAX        64
+++ 
+++ #endif /* _LIMITS_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..df9fe64 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,11 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        //struct spinlock cv_lock;
++++        struct wchan *cv_wchan;
++++        //volatile int hold;
++++        //struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ 
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int res_count;
++++        struct wchan *rd_wchan;
++++        struct wchan *wr_wchan;
++++        struct semaphore *rw_sem;
++++        struct lock *rw_lock;
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+++new file mode 100644
+++index 0000000..d98aeb7
+++--- /dev/null
++++++ b/kern/include/synch.h~
+++@@ -0,0 +1,161 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _SYNCH_H_
++++#define _SYNCH_H_
++++
++++/*
++++ * Header file for synchronization primitives.
++++ */
++++
++++
++++#include <spinlock.h>
++++
++++/*
++++ * Dijkstra-style semaphore.
++++ *
++++ * The name field is for easier debugging. A copy of the name is made
++++ * internally.
++++ */
++++struct semaphore {
++++        char *sem_name;
++++	struct wchan *sem_wchan;
++++	struct spinlock sem_lock;
++++        volatile int sem_count;
++++};
++++
++++struct semaphore *sem_create(const char *name, int initial_count);
++++void sem_destroy(struct semaphore *);
++++
++++/*
++++ * Operations (both atomic):
++++ *     P (proberen): decrement count. If the count is 0, block until
++++ *                   the count is 1 again before decrementing.
++++ *     V (verhogen): increment count.
++++ */
++++void P(struct semaphore *);
++++void V(struct semaphore *);
++++
++++
++++/*
++++ * Simple lock for mutual exclusion.
++++ *
++++ * When the lock is created, no thread should be holding it. Likewise,
++++ * when the lock is destroyed, no thread should be holding it.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++struct lock {
++++        char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct lock *lock_create(const char *name);
++++void lock_acquire(struct lock *);
++++
++++/*
++++ * Operations:
++++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++++ *                   same time.
++++ *    lock_release - Free the lock. Only the thread holding the lock may do
++++ *                   this.
++++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++++ *                   false otherwise.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void lock_release(struct lock *);
++++bool lock_do_i_hold(struct lock *);
++++void lock_destroy(struct lock *);
++++
++++
++++/*
++++ * Condition variable.
++++ *
++++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++++ * to wait until a variable meets a particular condition, but there's no
++++ * actual variable, as such, in the CV.
++++ *
++++ * These CVs are expected to support Mesa semantics, that is, no
++++ * guarantees are made about scheduling.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++
++++struct cv {
++++        char *cv_name;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct cv *cv_create(const char *name);
++++void cv_destroy(struct cv *);
++++
++++/*
++++ * Operations:
++++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++++ *                   waking up again, re-acquire the lock.
++++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++++ *
++++ * For all three operations, the current thread must hold the lock passed 
++++ * in. Note that under normal circumstances the same lock should be used
++++ * on all operations with any particular CV.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void cv_wait(struct cv *cv, struct lock *lock);
++++void cv_signal(struct cv *cv, struct lock *lock);
++++void cv_broadcast(struct cv *cv, struct lock *lock);
++++
++++/*
++++ * 13 Feb 2012 : GWA : Reader-writer locks.
++++ */
++++
++++struct rwlock {
++++        char *rwlock_name;
++++};
++++
++++struct rwlock * rwlock_create(const char *);
++++void rwlock_destroy(struct rwlock *);
++++
++++void rwlock_acquire_read(struct rwlock *);
++++void rwlock_release_read(struct rwlock *);
++++void rwlock_acquire_write(struct rwlock *);
++++void rwlock_release_write(struct rwlock *);
++++
++++#endif /* _SYNCH_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..ea96700 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -26,6 +26,7 @@
+++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++  * SUCH DAMAGE.
+++  */
++++#include<thread.h>
+++ 
+++ #ifndef _SYSCALL_H_
+++ #define _SYSCALL_H_
+++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+++  * Support functions.
+++  */
+++ 
++++
+++ /* Helper for fork(). You write this. */
+++-void enter_forked_process(struct trapframe *tf);
++++void enter_forked_process(void *tf,unsigned long adrspace);
+++ 
+++ /* Enter user mode. Does not return. */
+++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++++int sys_execv(char* progname,char** arguments);
++++int sys_getpid(pid_t *retval);
++++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++++void sys_exit(int exitcode);
++++int mywait(struct process* mypro);
+++ 
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/test.h b/kern/include/test.h
+++index 240d583..84f60fc 100644
+++--- a/kern/include/test.h
++++++ b/kern/include/test.h
+++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+++ int nettest(int, char **);
+++ 
+++ /* Routine for running a user-level program. */
+++-int runprogram(char *progname);
++++int runprogram(char *progname,char** argv,unsigned long argc);
+++ 
+++ /* Kernel menu system. */
+++ void menu(char *argstr);
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..77a3515 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -73,7 +73,10 @@ struct thread {
+++ 	 */
+++ 	char *t_name;			/* Name of this thread */
+++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+++-	threadstate_t t_state;		/* State this thread is in */
++++	threadstate_t t_state;
++++	/* State this thread is in */
++++
++++	pid_t pid;
+++ 
+++ 	/*
+++ 	 * Thread subsystem internal fields.
+++@@ -104,7 +107,7 @@ struct thread {
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++-
++++	struct process* proc;
+++ 	/* VM */
+++ 	struct addrspace *t_addrspace;	/* virtual address space */
+++ 
+++@@ -112,6 +115,19 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
++++};
++++
++++struct process {
++++	int full;
++++	pid_t pid;
++++    pid_t ppid;
++++    //struct semaphore* exitsem;
++++    struct lock* tlock;
++++    struct cv* wcv;
++++    bool exited;
++++    int exitcode;
++++    struct thread* self;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..4d8e7e2 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -100,7 +100,7 @@ boot(void)
+++ 	kprintf("%s", harvard_copyright);
+++ 	kprintf("\n");
+++ 
+++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++ 		GROUP_VERSION, buildconfig, buildversion);
+++ 	kprintf("\n");
+++ 
+++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+++new file mode 100644
+++index 0000000..4d8e7e2
+++--- /dev/null
++++++ b/kern/startup/main.c~
+++@@ -0,0 +1,211 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Main.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/reboot.h>
++++#include <kern/unistd.h>
++++#include <lib.h>
++++#include <spl.h>
++++#include <clock.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++#include <vm.h>
++++#include <mainbus.h>
++++#include <vfs.h>
++++#include <device.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <version.h>
++++#include "autoconf.h"  // for pseudoconfig
++++
++++
++++/*
++++ * These two pieces of data are maintained by the makefiles and build system.
++++ * buildconfig is the name of the config file the kernel was configured with.
++++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++++ *
++++ * The purpose is not to show off how many kernels you've linked, but
++++ * to make it easy to make sure that the kernel you just booted is the
++++ * same one you just built.
++++ */
++++extern const int buildversion;
++++extern const char buildconfig[];
++++
++++/*
++++ * Copyright message for the OS/161 base code.
++++ */
++++static const char harvard_copyright[] =
++++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++++
++++
++++/*
++++ * Initial boot sequence.
++++ */
++++static
++++void
++++boot(void)
++++{
++++	/*
++++	 * The order of these is important!
++++	 * Don't go changing it without thinking about the consequences.
++++	 *
++++	 * Among other things, be aware that console output gets
++++	 * buffered up at first and does not actually appear until
++++	 * mainbus_bootstrap() attaches the console device. This can
++++	 * be remarkably confusing if a bug occurs at this point. So
++++	 * don't put new code before mainbus_bootstrap if you don't
++++	 * absolutely have to.
++++	 *
++++	 * Also note that the buffer for this is only 1k. If you
++++	 * overflow it, the system will crash without printing
++++	 * anything at all. You can make it larger though (it's in
++++	 * dev/generic/console.c).
++++	 */
++++
++++	kprintf("\n");
++++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++++	kprintf("%s", harvard_copyright);
++++	kprintf("\n");
++++
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++++		GROUP_VERSION, buildconfig, buildversion);
++++	kprintf("\n");
++++
++++	/* Early initialization. */
++++	ram_bootstrap();
++++	thread_bootstrap();
++++	hardclock_bootstrap();
++++	vfs_bootstrap();
++++
++++	/* Probe and initialize devices. Interrupts should come on. */
++++	kprintf("Device probe...\n");
++++	KASSERT(curthread->t_curspl > 0);
++++	mainbus_bootstrap();
++++	KASSERT(curthread->t_curspl == 0);
++++	/* Now do pseudo-devices. */
++++	pseudoconfig();
++++	kprintf("\n");
++++
++++	/* Late phase of initialization. */
++++	vm_bootstrap();
++++	kprintf_bootstrap();
++++	thread_start_cpus();
++++
++++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++++	vfs_setbootfs("emu0");
++++
++++
++++	/*
++++	 * Make sure various things aren't screwed up.
++++	 */
++++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++++}
++++
++++/*
++++ * Shutdown sequence. Opposite to boot().
++++ */
++++static
++++void
++++shutdown(void)
++++{
++++
++++	kprintf("Shutting down.\n");
++++	
++++	vfs_clearbootfs();
++++	vfs_clearcurdir();
++++	vfs_unmountall();
++++
++++	thread_shutdown();
++++
++++	splhigh();
++++}
++++
++++/*****************************************/
++++
++++/*
++++ * reboot() system call.
++++ *
++++ * Note: this is here because it's directly related to the code above,
++++ * not because this is where system call code should go. Other syscall
++++ * code should probably live in the "syscall" directory.
++++ */
++++int
++++sys_reboot(int code)
++++{
++++	switch (code) {
++++	    case RB_REBOOT:
++++	    case RB_HALT:
++++	    case RB_POWEROFF:
++++		break;
++++	    default:
++++		return EINVAL;
++++	}
++++
++++	shutdown();
++++
++++	switch (code) {
++++	    case RB_HALT:
++++		kprintf("The system is halted.\n");
++++		mainbus_halt();
++++		break;
++++	    case RB_REBOOT:
++++		kprintf("Rebooting...\n");
++++		mainbus_reboot();
++++		break;
++++	    case RB_POWEROFF:
++++		kprintf("The system is halted.\n");
++++		mainbus_poweroff();
++++		break;
++++	}
++++
++++	panic("reboot operation failed\n");
++++	return 0;
++++}
++++
++++/*
++++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++++ * request, and then shut down.
++++ */
++++void
++++kmain(char *arguments)
++++{
++++	boot();
++++
++++	menu(arguments);
++++
++++	/* Should not get here */
++++}
+++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+++index 6c71551..a4c2750 100644
+++--- a/kern/startup/menu.c
++++++ b/kern/startup/menu.c
+++@@ -40,9 +40,13 @@
+++ #include <sfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include<thread.h>
++++#include<synch.h>
+++ #include "opt-synchprobs.h"
+++ #include "opt-sfs.h"
+++ #include "opt-net.h"
++++#include <copyinout.h>
++++//#include "proc_sys.c"
+++ 
+++ /*
+++  * In-kernel menu and command dispatcher.
+++@@ -51,6 +55,7 @@
+++ #define _PATH_SHELL "/bin/sh"
+++ 
+++ #define MAXMENUARGS  16
++++extern struct process* p_table[17];
+++ 
+++ // XXX this should not be in this file
+++ void
+++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+++ 
+++ 	strcpy(progname, args[0]);
+++ 
+++-	result = runprogram(progname);
++++	result = runprogram(progname,args,nargs);
+++ 	if (result) {
+++ 		kprintf("Running program %s failed: %s\n", args[0],
+++ 			strerror(result));
+++@@ -127,6 +132,8 @@ int
+++ common_prog(int nargs, char **args)
+++ {
+++ 	int result;
++++	struct thread* fthread;
++++	//int err;
+++ 
+++ #if OPT_SYNCHPROBS
+++ 	kprintf("Warning: this probably won't work with a "
+++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+++ 	result = thread_fork(args[0] /* thread name */,
+++ 			cmd_progthread /* thread function */,
+++ 			args /* thread arg */, nargs /* thread arg */,
+++-			NULL);
++++			&fthread);
++++	//fthread->
++++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++++
++++	fthread->pid=PID_MIN;
++++	fthread->proc->pid=PID_MIN;
++++
++++	fthread->proc->self=fthread;
++++	fthread->proc->wcv=cv_create("First CV");
++++	fthread->proc->tlock=lock_create("First Lock");
++++	p_table[0]=fthread->proc;
++++
++++	lock_acquire(p_table[0]->tlock);
++++	mywait(p_table[0]);
++++	lock_release(p_table[0]->tlock);
++++
++++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++
++++	//fthread->proc->
++++	//while(!p_table[0]->exited)
++++
++++
+++ 	if (result) {
+++ 		kprintf("thread_fork failed: %s\n", strerror(result));
+++ 		return result;
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..6c0bb3f 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -43,11 +43,25 @@
+++  * You should implement your solution to the whalemating problem below.
+++  */
+++ 
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++-// the top of the corresponding driver code.
++++// the top of the corresponding driver code
++++
++++struct semaphore *male_sem;
++++struct semaphore *female_sem;
++++struct lock *hold;
++++struct cv* mate_cv;
++++volatile int male_count;
++++volatile int female_count;
+++ 
+++ void whalemating_init() {
++++ hold=lock_create("My lock");
++++ male_sem=sem_create("Male Semaphore",0);
++++ female_sem=sem_create("Female Semaphore",0);
++++mate_cv=cv_create("mating cv");
++++male_count=0;
++++female_count=0;
+++   return;
+++ }
+++ 
+++@@ -55,6 +69,11 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++
++++	sem_destroy(male_sem);
++++	sem_destroy(female_sem);
++++	lock_destroy(hold);
++++	cv_destroy(mate_cv);
+++   return;
+++ }
+++ 
+++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+++   (void)which;
+++   
+++   male_start();
++++
++++  lock_acquire(hold);
++++
++++  V(male_sem);
++++  male_count++;
++++  if(female_count!=0)
++++  cv_signal(mate_cv,hold);
++++  else
++++	  cv_wait(mate_cv,hold);
++++  lock_release(hold);
++++
+++ 	// Implement this function 
+++   male_end();
+++ 
+++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
++++  lock_acquire(hold);
++++   V(female_sem);
++++   female_count++;
++++   if(male_count!=0)
++++   cv_signal(mate_cv,hold);
++++   else
++++	   cv_wait(mate_cv,hold);
++++  lock_release(hold);
+++ 	// Implement this function 
+++   female_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
++++  lock_acquire(hold);
++++ P(male_sem);
++++ male_count--;
++++ lock_release(hold);
++++ lock_acquire(hold);
++++  P(female_sem);
++++  female_count--;
++++  lock_release(hold);
+++ 	// Implement this function 
+++   matchmaker_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
++++
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
++++struct lock* intersect_lock;
++++struct cv* intersect_cv;
++++volatile int cur_poss[4];// an array to store the possible positions of the car
++++//currently
+++ 
+++ void stoplight_init() {
++++	intersect_cv=cv_create("Intersection Condition Variable");
++++	if(intersect_cv==NULL)
++++	{
++++		///return NULL;
++++		panic("condition variable not created");
++++	}
++++	intersect_lock=lock_create("A lock on the intersection");
++++	if(intersect_lock==NULL)
++++	{
++++		//return NULL;
++++		panic("Lock could not be created");
++++	}
++++	
++++	
+++   return;
+++ }
+++ 
+++@@ -145,6 +210,8 @@ void stoplight_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
++++	cv_destroy(intersect_cv);
++++	lock_destroy(intersect_lock);
+++   return;
+++ }
+++ 
+++@@ -152,8 +219,29 @@ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++  //(void)direction;
++++	int sec_quad=(direction+3)%4;
++++	lock_acquire(intersect_lock);
++++	// So while any of the two possible quadrants are already set, It means some 
++++	//thread is waiting...Hopefully
++++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++++		cv_wait(intersect_cv,intersect_lock);
++++	cur_poss[direction]=1;
++++	cur_poss[sec_quad]=1;
++++	inQuadrant(direction);
++++	lock_release(intersect_lock);
++++	lock_acquire(intersect_lock);
++++    cur_poss[direction]=0;
++++    //while(curr_p)
++++    //cv_broadcast(intersect_cv);
++++    inQuadrant(sec_quad);
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++    cur_poss[sec_quad]=0;
++++    leaveIntersection();
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
++++  int sec_quad=(direction+3)%4;
++++  int third_quad=(direction+2)%4;
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  cur_poss[sec_quad]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++  lock_acquire(intersect_lock);
++++  cur_poss[direction]=0;
+++   
++++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++++  //cv_wait(intersect_cv,intersect_lock);
++++      cur_poss[third_quad]=1;
++++      //while(curr_p)
++++      //cv_broadcast(intersect_cv);
++++      inQuadrant(sec_quad);
++++      cv_broadcast(intersect_cv,intersect_lock);
++++      lock_release(intersect_lock);
++++        lock_acquire(intersect_lock);
++++            //currposs[direction]=0;
++++            cur_poss[sec_quad]=0;
++++            //while(curr_p)
++++            //cv_broadcast(intersect_cv);
++++            inQuadrant(third_quad);
++++            cv_broadcast(intersect_cv,intersect_lock);
++++                //cur_poss[third_quad]=0;
++++            lock_release(intersect_lock);
++++              lock_acquire(intersect_lock);
++++                leaveIntersection();
++++                cur_poss[third_quad]=0;
++++                cv_broadcast(intersect_cv,intersect_lock);
++++                lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
+++-
++++  // Easy coz the vehicle is in same lane!!
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++  leaveIntersection();
++++  cur_poss[direction]=0;
++++  cv_broadcast(intersect_cv,intersect_lock);
++++  lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+++new file mode 100644
+++index 0000000..dfd7b53
+++--- /dev/null
++++++ b/kern/syscall/proc_sys.c
+++@@ -0,0 +1,445 @@
++++/*
++++
++++ * proc_sys.c
++++ *
++++ *  Created on: Mar 7, 2014
++++ *      Author: trinity
++++ */
++++
++++#include <types.h>
++++#include<mips/trapframe.h>
++++#include <kern/errno.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <addrspace.h>
++++#include <vm.h>
++++#include <vfs.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <file.h>
++++#include <synch.h>
++++#include<copyinout.h>
++++#include <spl.h>
++++#include<kern/wait.h>
++++
++++extern struct process* p_table[17];
++++
++++//struct cv* wcv;
++++
++++extern pid_t pidcount;
++++int mywait(struct process* mypro) {
++++	//lock_acquire(mypro->tlock);
++++	while (!mypro->exited) {
++++		cv_wait(mypro->wcv, mypro->tlock);
++++	}
++++	//*status=mypro->exitcode;
++++	//lock_release(mypro->tlock);
++++	//int test = mypro->exitcode;
++++	//test++;
++++	return 0;
++++}
++++
++++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++++	(void) adrs;
++++	int flag;
++++	pid_t childid;
++++	struct addrspace *adrcopy;
++++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++++			sizeof(struct trapframe));
++++	bzero(copyt, sizeof(struct trapframe));
++++
++++	//struct filetable* copyft;
++++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++++
++++	memcpy(copyt, tf, sizeof(struct trapframe));
++++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++++	//if(curthread->pid==0)
++++	//{
++++	//curthread->pid=PID_MIN;
++++	//}
++++	if (flag) {
++++		kfree(copyt);
++++		return flag;
++++	}
++++
++++	//we need to allocate pid for our new process
++++
++++	//pid_t cpid;
++++	for (childid = 0; childid <= 16; childid++) {
++++		if (p_table[childid] == NULL ) {
++++			p_table[childid] = (struct process*) kmalloc(
++++					sizeof(struct process));
++++			p_table[childid]->full = 1;
++++			pidcount++;
++++			p_table[childid]->pid = pidcount;
++++			p_table[childid]->ppid = curthread->pid;
++++			//p_table[childid]->exitsem=sem_create("process",0);
++++			p_table[childid]->tlock = lock_create("My Lock");
++++			p_table[childid]->wcv = cv_create("My CV");
++++			p_table[childid]->self = NULL;
++++			break;
++++		}
++++	}
++++	if (childid > PID_MAX) {
++++		*retval = 1;
++++		return EMPROC;
++++	}
++++	//int i;
++++
++++	copyt->tf_a0 = (int) p_table[childid]->pid;
++++	//kprintf("Ret:%d\n",copyt->tf_a0);
++++	struct thread *new_proc;
++++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++++	//int s=splhigh();
++++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++++			(unsigned long) adrcopy, &new_proc);
++++	//kprintf("Out of thread fork:%d\n",flag);
++++	if (flag) {
++++		kfree(copyt);
++++		as_destroy(adrcopy);
++++
++++		return flag;
++++	}
++++
++++	//new_proc->pid=(pid_t)childid;
++++	//new_proc=p_table[childid];
++++
++++	new_proc->pid = p_table[childid]->pid;
++++	new_proc->proc = p_table[childid];
++++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++++	//if (new_proc->t_filetable == NULL) {
++++	//return ENOMEM;
++++	//}
++++	p_table[childid]->self = new_proc;
++++
++++	//new_proc->pid=p_table[childid]->pid;
++++	//new_proc->proc->pid=p_table[childid]->pid;
++++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++++
++++	//kprintf("Child id:%d",new_proc->pid);
++++	//new_proc->t_filetable->
++++	//for(i=0;i<128;i++)
++++	//{
++++	flag = filetable_copy(&new_proc->t_filetable);
++++	//}
++++	//splx(s);
++++	// kprintf("Fork over!");
++++
++++	*retval = p_table[childid]->pid;
++++	//kprintf("Return val in fork:%d",*retval);
++++	return 0;
++++
++++	//flag=
++++	//flag=thread_fork=
++++}
++++
++++int sys_execv(char *progname, char** arguments) {
++++
++++	int flag;
++++	int numargs;
++++	int addr;
++++	int i;
++++	// first we need to copy the program name to the kernel space
++++	// then we go for arguments. Path size unknown
++++
++++	size_t actual_size = 0;
++++	char *namedes;
++++
++++	if (progname == NULL ) {
++++		return EFAULT;
++++	}
++++	if (progname == "") {
++++		return EINVAL;
++++	}
++++
++++	namedes = (char*) kmalloc(PATH_MAX);
++++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++++			&actual_size);
++++	if (flag != 0) {
++++		kfree(namedes);
++++		return flag;
++++	}
++++	//namedes[actual_size]
++++	if (strlen(namedes) == 0) {
++++		//*retval=1;
++++		return EISDIR;
++++	}
++++
++++	// now we open file using vfs_open. Same as runprogram
++++	struct vnode* vn;
++++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++++	if (flag) {
++++		return flag;
++++	}
++++	actual_size = 0;
++++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++++
++++	//char** kargv=(char**)kmalloc(sizeof(char));
++++	// get the number of arguments
++++	if (arguments == NULL ) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++++	if (flag) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++
++++	//check=wthread->exitcode;
++++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++++	//if(err)
++++	//{
++++	//	lock_release(p_table[i]->tlock);
++++	//return err;
++++	//}
++++
++++	numargs = 0;
++++	while (arguments[numargs] != NULL ) {
++++		//kprintf("%");
++++		numargs = numargs + 1;
++++	}
++++
++++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++++	//int i;
++++	for (i = 0; i < numargs; i++) {
++++		actual_size = 0;
++++		kargv[i] = (char*) kmalloc(PATH_MAX);
++++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++++				&actual_size);
++++		if (flag) {
++++			kfree(kargv);
++++			kfree(namedes);
++++			return EFAULT;
++++		}
++++
++++	}
++++	actual_size = 0;
++++
++++	curthread->t_addrspace = as_create();
++++	if (curthread->t_addrspace == NULL ) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	vaddr_t entrypoint, stackptr;
++++	as_activate(curthread->t_addrspace);
++++	flag = load_elf(vn, &entrypoint);
++++	if (flag) {
++++		// thread_exit destroys curthread->t_addrspace
++++		vfs_close(vn);
++++		return flag;
++++	}
++++
++++	vfs_close(vn);
++++
++++	// now set up the user stack with the arguments
++++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++++	if (flag) {
++++		//thread_exit destroys curthread->t_addrspace
++++		return flag;
++++	}
++++
++++	//i=0;
++++	vaddr_t stackptrv[numargs + 1];
++++	for (i = numargs - 1; i >= 0; i--) {
++++		int len = strlen(kargv[i]);
++++		int padder=0;
++++		len++;// to account for string terminator
++++		if(len%4!=0)
++++		padder = len % 4;
++++		stackptr =stackptr-(len + padder);
++++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++++				&actual_size);
++++
++++		if (flag)
++++		{
++++			kfree(kargv);
++++			kfree(namedes);
++++			return flag;
++++		}
++++
++++		stackptrv[i] = stackptr;
++++	}
++++	stackptrv[numargs] = 0;
++++
++++	//This copies the actual stack addresses of the arguments
++++	//* into the stack. Hopefully.
++++
++++	 for(i = numargs; i >= 0; i--)
++++	 {
++++	 stackptr -= sizeof(vaddr_t);
++++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++
++++	 if(flag)
++++	 {
++++	 kfree(kargv);
++++	 kfree(namedes);
++++	 return flag;
++++	 }
++++
++++	 }
++++
++++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++++	//pt_getthread();
++++
++++	//enter_new_process does not return.
++++	panic("enter_new_process returned\n");
++++	return EINVAL;
++++
++++}
++++
++++int sys_getpid(pid_t *retval) {
++++	//kprintf("In get pid:%d\n",curthread->pid);
++++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++++
++++	*retval = curthread->proc->pid;
++++	return 0;
++++}
++++
++++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++++	struct process* wthread = NULL;
++++	int check;
++++	int err;
++++	pid_t i;
++++	//kprintf("PID in wait pid:%d\n",pid);
++++	if (status == NULL )
++++		return EFAULT;
++++	if (options != 0)
++++		return EINVAL;
++++	if (pid == curthread->pid)
++++		return ECHILD;
++++	if (pid < PID_MIN || pid > PID_MAX)
++++		return ESRCH;
++++	if (status == NULL )
++++		return EFAULT;
++++	if (pid == curthread->proc->ppid)
++++		return ECHILD;
++++	//int *shit;
++++	//*shit=(int)&status;
++++	//kprintf("%d\n",*shit);
++++	//if(curthread->)
++++	//if(pid!=curthread->)
++++	//char* argv=(char*)(status);
++++	//int length=strlen(argv)+1;
++++	//int length=strlen(kargv[i])+1;
++++	//int padder=length%4;
++++	//kprintf("Hai:%d\n",padder);
++++	//if(padder!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++
++++	//if()
++++
++++	//char pathbuf[PATH_MAX];
++++	//int *buffer;
++++	//int result;
++++
++++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++++	//if (result) {
++++	//return result;
++++	//}
++++	//int addr=(int)&status;
++++	//kprintf("Status:%d\n",addr);
++++	//int *addr=&status;
++++	//if(addr%4!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++	//kprintf("Got Here\n");
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				wthread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++	if (wthread == NULL ) {
++++		return ESRCH;
++++	}
++++	if (curthread->proc->pid != wthread->ppid)
++++		return ECHILD;
++++	//panic("We are here");
++++
++++	lock_acquire(p_table[i]->tlock);
++++
++++	//while(!wthread->exited)
++++	//{
++++//
++++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++++	//}
++++	mywait(wthread);
++++
++++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++++	//kprintf("We are here!");
++++
++++	check = wthread->exitcode;
++++	err = copyout(&check, (userptr_t) status, sizeof(check));
++++	if (err) {
++++		lock_release(p_table[i]->tlock);
++++		return err;
++++	}
++++	//kprintf("Exit code After waiting:%d\n",*status);
++++	//kfree(p_table[i]->exitsem);
++++	//p_table[i]=NULL;
++++
++++	//panic("After kfree");
++++	//p_table[i]=NULL;
++++	lock_release(p_table[i]->tlock);
++++	//filetable_destroy(p_table[i]->self->t_filetable);
++++	//lock_destroy(p_table[i]->tlock);
++++	//cv_destroy(p_table[i]->wcv);
++++	//kfree(p_table[i]);
++++	p_table[i] = NULL;
++++
++++	*retval = pid;
++++	//panic("After dereferencing");
++++	return 0;
++++
++++	//return -1;
++++	//return 0;
++++}
++++
++++void sys_exit(int exitcode) {
++++	pid_t pid = curthread->proc->pid;
++++	pid_t i = PID_MIN;
++++	struct process* ethread;
++++//pid_t parent;
++++//if(pid!=2)
++++//{
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				ethread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++
++++//parent=ethread->ppid;
++++	if (ethread != NULL ) {
++++		lock_acquire(ethread->tlock);
++++//kprintf("Exit code Before:%d\n",exitcode);
++++
++++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++++		ethread->exited = 1;
++++//p_table[i]=ethread;
++++		cv_broadcast(ethread->wcv, ethread->tlock);
++++//kfree(curthread->t_filetable);
++++		lock_release(ethread->tlock);
++++	}
++++//}
++++	i = 0;
++++//
++++//kprintf("Before hanging");
++++//filetable_destroy(curthread->t_filetable);
++++//kfree(curthread->p);
++++
++++	thread_exit();
++++}
++++
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..1ada408 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,8 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
++++#include<copyinout.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -52,7 +54,7 @@
+++  * Calls vfs_open on progname and thus may destroy it.
+++  */
+++ int
+++-runprogram(char *progname)
++++runprogram(char *progname,char**argv,unsigned long argc)
+++ {
+++ 	struct vnode *v;
+++ 	vaddr_t entrypoint, stackptr;
+++@@ -66,6 +68,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	curthread->t_filetable=NULL;
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++@@ -94,9 +103,40 @@ runprogram(char *progname)
+++ 		/* thread_exit destroys curthread->t_addrspace */
+++ 		return result;
+++ 	}
++++	vaddr_t stackptrv[argc+1];
++++int i;
++++size_t actual;
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(argv[i]);
++++int padder=0;
++++len++;
++++if(len%4!=0)
++++padder = len % 4;
++++stackptr=stackptr-(len + padder);
++++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++return result;
++++}
++++}
++++
++++
++++
+++ 
+++ 	/* Warp to user mode. */
+++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++++	enter_new_process(argc, (userptr_t)stackptr,
+++ 			  stackptr, entrypoint);
+++ 	
+++ 	/* enter_new_process does not return. */
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..851f9ea 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -40,6 +40,8 @@
+++ #include <current.h>
+++ #include <synch.h>
+++ 
++++#define MAXREADERS 20;
++++
+++ ////////////////////////////////////////////////////////////
+++ //
+++ // Semaphore.
+++@@ -162,9 +164,17 @@ lock_create(const char *name)
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
+++-        // add stuff here as needed
+++-        
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
+++         return lock;
+++ }
+++ 
+++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+++ 
+++         // add stuff here as needed
+++         
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
+++         kfree(lock->lk_name);
+++         kfree(lock);
+++ }
+++@@ -183,26 +195,78 @@ void
+++ lock_acquire(struct lock *lock)
+++ {
+++         // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(&lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -225,7 +289,18 @@ cv_create(const char *name)
+++                 kfree(cv);
+++                 return NULL;
+++         }
+++-        
++++        cv->cv_wchan = wchan_create(cv->cv_name);
++++                	if (cv->cv_wchan == NULL) {
++++                		kfree(cv->cv_name);
++++                		kfree(cv);
++++                		return NULL;
++++                	}
++++
++++                	//spinlock_init(&cv->cv_lock);
++++                        //lock->hold = 0;
++++        		//lock->holder=NULL;
++++                //lock->=NULL
++++                return cv;
+++         // add stuff here as needed
+++         
+++         return cv;
+++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+++ 
+++         // add stuff here as needed
+++         
++++        //spinlock_cleanup(&cv->cv_lock);
++++        
++++        wchan_destroy(cv->cv_wchan);
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++ }
+++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	//KASSERT(lock_do_i_hold(lock));
++++	wchan_lock(cv->cv_wchan);
++++	lock_release(lock);
++++	
++++	wchan_sleep(cv->cv_wchan);
++++	lock_acquire(lock);
++++	
++++    // Write this
++++    //(void)cv;    // suppress warning until code gets written
++++    //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++         // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeone(cv->cv_wchan);
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeall(cv->cv_wchan);
++++		
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
++++}
++++
++++struct rwlock *rwlock_create(const char *name)
++++{
++++	struct rwlock *rw;
++++	rw=kmalloc(sizeof(struct rwlock));
++++	if(rw==NULL)
++++	{
++++		return NULL;
++++	}
++++	rw->rwlock_name=kstrdup(name);
++++	if(rw->rwlock_name==NULL)
++++	{
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++++	if(rw->rd_wchan==NULL)
++++	{
++++		kfree(rw->rwlock_name);
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++++		if(rw->wr_wchan==NULL)
++++		{
++++			kfree(rw->rwlock_name);
++++			kfree(rw);
++++			return NULL;
++++		}
++++		rw->rw_sem=sem_create("mysem",20);
++++		rw->rw_lock=lock_create("mylock");
++++	///rw->res_count=MAXREADERS;
++++	return rw;
++++	
++++}
++++void rwlock_destroy(struct rwlock *rw)
++++{
++++		KASSERT(rw != NULL);
++++		
++++		wchan_destroy(rw->rd_wchan);
++++		wchan_destroy(rw->wr_wchan);
++++		sem_destroy(rw->rw_sem);
++++		lock_destroy(rw->rw_lock);
++++	    kfree(rw->rwlock_name);
++++        kfree(rw);	
++++}
++++
++++void rwlock_acquire_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	P(rw->rw_sem);
++++	lock_release(rw->rw_lock);
++++}
++++void rwlock_release_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	V(rw->rw_sem);
++++	//lock_release(rw->rw_lock);
++++}
++++void rwlock_acquire_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	//rwlock->rw_sem->V();
++++	for(i=0;i<20;i++)
++++	{
++++	P(rw->rw_sem);
++++	}	
++++	lock_release(rw->rw_lock);
++++	
++++	
+++ }
++++void rwlock_release_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	for(i=0;i<20;i++)
++++	{
++++	V(rw->rw_sem);
++++	}	
++++	//lock_release(rw->rw_lock);
++++	
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+++new file mode 100644
+++index 0000000..b9680d1
+++--- /dev/null
++++++ b/kern/thread/synch.c~
+++@@ -0,0 +1,329 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Synchronization primitives.
++++ * The specifications of the functions are in synch.h.
++++ */
++++
++++#include <types.h>
++++#include <lib.h>
++++#include <spinlock.h>
++++#include <wchan.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Semaphore.
++++
++++struct semaphore *
++++sem_create(const char *name, int initial_count)
++++{
++++        struct semaphore *sem;
++++
++++        KASSERT(initial_count >= 0);
++++
++++        sem = kmalloc(sizeof(struct semaphore));
++++        if (sem == NULL) {
++++                return NULL;
++++        }
++++
++++        sem->sem_name = kstrdup(name);
++++        if (sem->sem_name == NULL) {
++++                kfree(sem);
++++                return NULL;
++++        }
++++
++++	sem->sem_wchan = wchan_create(sem->sem_name);
++++	if (sem->sem_wchan == NULL) {
++++		kfree(sem->sem_name);
++++		kfree(sem);
++++		return NULL;
++++	}
++++
++++	spinlock_init(&sem->sem_lock);
++++        sem->sem_count = initial_count;
++++
++++        return sem;
++++}
++++
++++void
++++sem_destroy(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	/* wchan_cleanup will assert if anyone's waiting on it */
++++	spinlock_cleanup(&sem->sem_lock);
++++	wchan_destroy(sem->sem_wchan);
++++        kfree(sem->sem_name);
++++        kfree(sem);
++++}
++++
++++void 
++++P(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++        /*
++++         * May not block in an interrupt handler.
++++         *
++++         * For robustness, always check, even if we can actually
++++         * complete the P without blocking.
++++         */
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++        while (sem->sem_count == 0) {
++++		/*
++++		 * Bridge to the wchan lock, so if someone else comes
++++		 * along in V right this instant the wakeup can't go
++++		 * through on the wchan until we've finished going to
++++		 * sleep. Note that wchan_sleep unlocks the wchan.
++++		 *
++++		 * Note that we don't maintain strict FIFO ordering of
++++		 * threads going through the semaphore; that is, we
++++		 * might "get" it on the first try even if other
++++		 * threads are waiting. Apparently according to some
++++		 * textbooks semaphores must for some reason have
++++		 * strict ordering. Too bad. :-)
++++		 *
++++		 * Exercise: how would you implement strict FIFO
++++		 * ordering?
++++		 */
++++		wchan_lock(sem->sem_wchan);
++++		spinlock_release(&sem->sem_lock);
++++                wchan_sleep(sem->sem_wchan);
++++
++++		spinlock_acquire(&sem->sem_lock);
++++        }
++++        KASSERT(sem->sem_count > 0);
++++        sem->sem_count--;
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++void
++++V(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++
++++        sem->sem_count++;
++++        KASSERT(sem->sem_count > 0);
++++	wchan_wakeone(sem->sem_wchan);
++++
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Lock.
++++
++++struct lock *
++++lock_create(const char *name)
++++{
++++        struct lock *lock;
++++
++++        lock = kmalloc(sizeof(struct lock));
++++        if (lock == NULL) {
++++                return NULL;
++++        }
++++
++++        lock->lk_name = kstrdup(name);
++++        if (lock->lk_name == NULL) {
++++                kfree(lock);
++++                return NULL;
++++        }
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
++++        return lock;
++++}
++++
++++void
++++lock_destroy(struct lock *lock)
++++{
++++        KASSERT(lock != NULL);
++++
++++        // add stuff here as needed
++++        
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
++++        kfree(lock->lk_name);
++++        kfree(lock);
++++}
++++
++++void
++++lock_acquire(struct lock *lock)
++++{
++++        // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
++++
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++lock_release(struct lock *lock)
++++{
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
++++        // Write this
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++bool
++++lock_do_i_hold(struct lock *lock)
++++{
++++        // Write this
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// CV
++++
++++
++++struct cv *
++++cv_create(const char *name)
++++{
++++        struct cv *cv;
++++
++++        cv = kmalloc(sizeof(struct cv));
++++        if (cv == NULL) {
++++                return NULL;
++++        }
++++
++++        cv->cv_name = kstrdup(name);
++++        if (cv->cv_name==NULL) {
++++                kfree(cv);
++++                return NULL;
++++        }
++++        
++++        // add stuff here as needed
++++        
++++        return cv;
++++}
++++
++++void
++++cv_destroy(struct cv *cv)
++++{
++++        KASSERT(cv != NULL);
++++
++++        // add stuff here as needed
++++        
++++        kfree(cv->cv_name);
++++        kfree(cv);
++++}
++++
++++void
++++cv_wait(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++        (void)cv;    // suppress warning until code gets written
++++        (void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_signal(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_broadcast(struct cv *cv, struct lock *lock)
++++{
++++	// Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..df129b9 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+++ 
+++ /* Used to wait for secondary CPUs to come online. */
+++ static struct semaphore *cpu_startup_sem;
++++pid_t pidcount;
++++struct process* p_table[17];
+++ 
+++ ////////////////////////////////////////////////////////////
+++ 
+++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -352,8 +357,15 @@ thread_bootstrap(void)
+++ {
+++ 	struct cpu *bootcpu;
+++ 	struct thread *bootthread;
++++	int i;
+++ 
+++ 	cpuarray_init(&allcpus);
++++	pidcount=PID_MIN;
++++
++++	for(i=0;i<=16;i++)
++++	{
++++		p_table[i]=NULL;
++++	}
+++ 
+++ 	/*
+++ 	 * Create the cpu structure for the bootup CPU, the one we're
+++@@ -365,6 +377,7 @@ thread_bootstrap(void)
+++ 	 */
+++ 	bootcpu = cpu_create(0);
+++ 	bootthread = bootcpu->c_curthread;
++++	//bootthread->pid=PID_MIN;
+++ 
+++ 	/*
+++ 	 * Initializing curcpu and curthread is machine-dependent
+++@@ -519,7 +532,7 @@ thread_fork(const char *name,
+++ 	 * for the spllower() that will be done releasing it.
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++-
++++	//newthread->pid=pidcount++;
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 	switch (newstate) {
+++ 	    case S_RUN:
+++ 		panic("Illegal S_RUN in thread_switch\n");
+++-		break;
+++ 	    case S_READY:
+++ 		thread_make_runnable(cur, true /*have lock*/);
+++ 		break;
+++@@ -799,6 +811,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
+++diff --git a/single10.patch b/single10.patch
+++new file mode 100644
+++index 0000000..2267436
+++--- /dev/null
++++++ b/single10.patch
+++@@ -0,0 +1,915 @@
++++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++++index 0f773bd..68c73ff 100644
++++--- a/kern/arch/mips/syscall/syscall.c
+++++++ b/kern/arch/mips/syscall/syscall.c
++++@@ -32,6 +32,7 @@
++++ #include <kern/syscall.h>
++++ #include <lib.h>
++++ #include <mips/trapframe.h>
+++++#include <copyinout.h>
++++ #include <thread.h>
++++ #include <current.h>
++++ #include <syscall.h>
++++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++++ {
++++ 	int callno;
++++ 	int32_t retval;
+++++        int32_t retvalv1 = 0;
+++++        int64_t retval64;
++++ 	int err;
+++++        int32_t stackarg1;
++++ 
++++ 	KASSERT(curthread != NULL);
++++ 	KASSERT(curthread->t_curspl == 0);
++++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++++ 		err = sys___time((userptr_t)tf->tf_a0,
++++ 				 (userptr_t)tf->tf_a1);
++++ 		break;
+++++            case SYS_open:
+++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_read:
+++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_write:
+++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++				&retval);
+++++		break;
+++++	    case SYS_close:
+++++		err = sys_close(tf->tf_a0);
+++++		break;
+++++	    case SYS_lseek:
+++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++++                                stackarg1, &retval64);
+++++                retval = retval64 >> 32;
+++++                retvalv1 = (int) retval64;
+++++		break;
+++++	    case SYS_dup2:
+++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
+++++	    case SYS_chdir:
+++++		err = sys_chdir((userptr_t)tf->tf_a0);
+++++		break;
+++++	    case SYS___getcwd:
+++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
++++ 
++++ 	    /* Add stuff here */
++++  
++++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++++ 	else {
++++ 		/* Success. */
++++ 		tf->tf_v0 = retval;
+++++                tf->tf_v1 = retvalv1;
++++ 		tf->tf_a3 = 0;      /* signal no error */
++++ 	}
++++ 	
++++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++++index d527f61..e1d7682 100644
++++--- a/kern/conf/conf.kern
+++++++ b/kern/conf/conf.kern
++++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++++ file      syscall/loadelf.c
++++ file      syscall/runprogram.c
++++ file      syscall/time_syscalls.c
+++++file      syscall/file_syscalls.c
+++++file      syscall/file.c
++++ 
++++ #
++++ # Startup and initialization
++++diff --git a/kern/include/file.h b/kern/include/file.h
++++new file mode 100644
++++index 0000000..2c63bc2
++++--- /dev/null
+++++++ b/kern/include/file.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Declarations for file handle and file table management.
+++++ * New for SOL2.
+++++ */
+++++
+++++#ifndef _FILE_H_
+++++#define _FILE_H_
+++++
+++++#include <limits.h>
+++++
+++++struct lock;
+++++struct vnode;
+++++
+++++/*** openfile section ***/
+++++
+++++/* 
+++++ * openfile struct 
+++++ * note that there's not too much to keep track of, since the vnode does most
+++++ * of that.  note that it does require synchronization, because a single
+++++ * openfile can be shared between processes (filetable inheritance).
+++++ */
+++++struct openfile {
+++++	struct vnode *of_vnode;
+++++	
+++++	struct lock *of_lock;
+++++	off_t of_offset;
+++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++++	int of_refcount;
+++++};
+++++
+++++/* opens a file (must be kernel pointers in the args) */
+++++int file_open(char *filename, int flags, int mode, int *retfd);
+++++
+++++/* closes a file */
+++++int file_close(int fd);
+++++
+++++
+++++/*** file table section ***/
+++++
+++++/*
+++++ * filetable struct
+++++ * just an array of open files.  nice and simple.  doesn't require
+++++ * synchronization, because a table can only be owned by a single process (on
+++++ * inheritance in fork, the table is copied).
+++++ */
+++++struct filetable {
+++++	struct openfile *ft_openfiles[OPEN_MAX];
+++++};
+++++
+++++/* these all have an implicit arg of the curthread's filetable */
+++++int filetable_init(const char *inpath, const char *outpath, 
+++++		   const char *errpath);
+++++int filetable_copy(struct filetable **copy);
+++++int filetable_placefile(struct openfile *file, int *fd);
+++++int filetable_findfile(int fd, struct openfile **file);
+++++int filetable_dup2file(int oldfd, int newfd);
+++++void filetable_destroy(struct filetable *ft);
+++++
+++++#endif /* _FILE_H_ */
++++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++++index befd3d8..f3a01ad 100644
++++--- a/kern/include/syscall.h
+++++++ b/kern/include/syscall.h
++++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++++  * Prototypes for IN-KERNEL entry points for system call implementations.
++++  */
++++ 
+++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_close(int fd);
+++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++++int sys_dup2(int oldfd, int newfd, int *retval);
+++++int sys_chdir(userptr_t path);
+++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++++
++++ int sys_reboot(int code);
++++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++ 
++++diff --git a/kern/include/thread.h b/kern/include/thread.h
++++index 86706ca..08b8f8c 100644
++++--- a/kern/include/thread.h
+++++++ b/kern/include/thread.h
++++@@ -112,6 +112,7 @@ struct thread {
++++ 	struct vnode *t_cwd;		/* current working directory */
++++ 
++++ 	/* add more here as needed */
+++++  struct filetable *t_filetable;
++++ };
++++ 
++++ /* Call once during system startup to allocate data structures. */
++++diff --git a/kern/include/uio.h b/kern/include/uio.h
++++index 5d97c48..c9124e8 100644
++++--- a/kern/include/uio.h
+++++++ b/kern/include/uio.h
++++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++++ void uio_kinit(struct iovec *, struct uio *,
++++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++++ 
+++++void uio_uinit(struct iovec *, struct uio *,
+++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++++
++++ 
++++ #endif /* _UIO_H_ */
++++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++++index 594fe96..83ea620 100644
++++--- a/kern/lib/uio.c
+++++++ b/kern/lib/uio.c
++++@@ -153,6 +153,7 @@ void
++++ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++++ {
+++++	KASSERT(u);
++++ 	iov->iov_kbase = kbuf;
++++ 	iov->iov_len = len;
++++ 	u->uio_iov = iov;
++++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	u->uio_rw = rw;
++++ 	u->uio_space = NULL;
++++ }
+++++
+++++void
+++++uio_uinit(struct iovec *iov, struct uio *u,
+++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++++{
+++++	KASSERT(u);
+++++	iov->iov_ubase = ubuf;
+++++	iov->iov_len = len;
+++++  u->uio_iov = iov;
+++++	u->uio_iovcnt = 1;
+++++	u->uio_offset = pos;
+++++	u->uio_resid = len;
+++++	u->uio_segflg = UIO_USERSPACE;
+++++	u->uio_rw = rw;
+++++	u->uio_space = curthread->t_addrspace;
+++++}
++++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++++new file mode 100644
++++index 0000000..dc5ffe5
++++--- /dev/null
+++++++ b/kern/syscall/file.c
++++@@ -0,0 +1,341 @@
+++++/*
+++++ * File handles and file tables.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++
+++++/*** openfile functions ***/
+++++
+++++/*
+++++ * file_open
+++++ * opens a file, places it in the filetable, sets RETFD to the file
+++++ * descriptor. the pointer arguments must be kernel pointers.
+++++ * NOTE -- the passed in filename must be a mutable string.
+++++ */
+++++int
+++++file_open(char *filename, int flags, int mode, int *retfd)
+++++{
+++++	struct vnode *vn;
+++++	struct openfile *file;
+++++	int result;
+++++	
+++++	result = vfs_open(filename, flags, mode, &vn);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	file = kmalloc(sizeof(struct openfile));
+++++	if (file == NULL) {
+++++		vfs_close(vn);
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* initialize the file struct */
+++++	file->of_lock = lock_create("file lock");
+++++	if (file->of_lock == NULL) {
+++++		vfs_close(vn);
+++++		kfree(file);
+++++		return ENOMEM;
+++++	}
+++++	file->of_vnode = vn;
+++++	file->of_offset = 0;
+++++	file->of_accmode = flags & O_ACCMODE;
+++++	file->of_refcount = 1;
+++++
+++++	/* vfs_open checks for invalid access modes */
+++++	KASSERT(file->of_accmode==O_RDONLY ||
+++++	        file->of_accmode==O_WRONLY ||
+++++	        file->of_accmode==O_RDWR);
+++++
+++++	/* place the file in the filetable, getting the file descriptor */
+++++	result = filetable_placefile(file, retfd);
+++++	if (result) {
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++		vfs_close(vn);
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * file_doclose
+++++ * shared code for file_close and filetable_destroy
+++++ */
+++++static
+++++int
+++++file_doclose(struct openfile *file)
+++++{
+++++	lock_acquire(file->of_lock);
+++++
+++++	/* if this is the last close of this file, free it up */
+++++	if (file->of_refcount == 1) {
+++++		vfs_close(file->of_vnode);
+++++		lock_release(file->of_lock);
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++	}
+++++	else {
+++++		KASSERT(file->of_refcount > 1);
+++++		file->of_refcount--;
+++++		lock_release(file->of_lock);
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * file_close
+++++ * knock off the refcount, freeing the memory if it goes to 0.
+++++ */
+++++int
+++++file_close(int fd)
+++++{
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* find the file in the filetable */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	result = file_doclose(file);
+++++	if (result) {
+++++		/* leave file open for possible retry */
+++++		return result;
+++++	}
+++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++
+++++	return 0;
+++++}
+++++
+++++/*** filetable functions ***/
+++++
+++++/* 
+++++ * filetable_init
+++++ * pretty straightforward -- allocate the space, initialize to NULL.
+++++ * note that the one careful thing is to open the std i/o in order to
+++++ * get
+++++ * stdin  == 0
+++++ * stdout == 1
+++++ * stderr == 2
+++++ */
+++++int
+++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++++{
+++++	/* the filenames come from the kernel; assume reasonable length */
+++++	char path[32];
+++++	int result;
+++++	int fd;
+++++
+++++	/* make sure we can fit these */
+++++	KASSERT(strlen(inpath) < sizeof(path));
+++++	KASSERT(strlen(outpath) < sizeof(path));
+++++	KASSERT(strlen(errpath) < sizeof(path));
+++++	
+++++	/* catch memory leaks, repeated calls */
+++++	KASSERT(curthread->t_filetable == NULL);
+++++
+++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++++	if (curthread->t_filetable == NULL) {
+++++		return ENOMEM;
+++++	}
+++++	
+++++	/* NULL-out the table */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++	}
+++++
+++++	/*
+++++	 * open the std fds.  note that the names must be copied into
+++++	 * the path buffer so that they're mutable.
+++++	 */
+++++	strcpy(path, inpath);
+++++	result = file_open(path, O_RDONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, outpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, errpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_copy
+++++ * again, pretty straightforward.  the subtle business here is that instead of
+++++ * copying the openfile structure, we just increment the refcount.  this means
+++++ * that openfile structs will, in fact, be shared between processes, as in
+++++ * Unix.
+++++ */
+++++int
+++++filetable_copy(struct filetable **copy)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int fd;
+++++
+++++	/* waste of a call, really */
+++++	if (ft == NULL) {
+++++		*copy = NULL;
+++++		return 0;
+++++	}
+++++	
+++++	*copy = kmalloc(sizeof(struct filetable));
+++++	
+++++	if (*copy == NULL) {
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* copy over the entries */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd] != NULL) {
+++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++++			ft->ft_openfiles[fd]->of_refcount++;
+++++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++++		} 
+++++		else {
+++++			(*copy)->ft_openfiles[fd] = NULL;
+++++		}
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_destroy
+++++ * closes the files in the file table, frees the table.
+++++ */
+++++void
+++++filetable_destroy(struct filetable *ft)
+++++{
+++++	int fd, result;
+++++
+++++	KASSERT(ft != NULL);
+++++
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd]) {
+++++			result = file_doclose(ft->ft_openfiles[fd]);
+++++			KASSERT(result==0);
+++++		}
+++++	}
+++++	
+++++	kfree(ft);
+++++}	
+++++
+++++/* 
+++++ * filetable_placefile
+++++ * finds the smallest available file descriptor, places the file at the point,
+++++ * sets FD to it.
+++++ */
+++++int
+++++filetable_placefile(struct openfile *file, int *fd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int i;
+++++	
+++++	for (i = 0; i < OPEN_MAX; i++) {
+++++		if (ft->ft_openfiles[i] == NULL) {
+++++			ft->ft_openfiles[i] = file;
+++++			*fd = i;
+++++			return 0;
+++++		}
+++++	}
+++++
+++++	return EMFILE;
+++++}
+++++
+++++/*
+++++ * filetable_findfile
+++++ * verifies that the file descriptor is valid and actually references an
+++++ * open file, setting the FILE to the file at that index if it's there.
+++++ */
+++++int
+++++filetable_findfile(int fd, struct openfile **file)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++
+++++	if (fd < 0 || fd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++	
+++++	*file = ft->ft_openfiles[fd];
+++++	if (*file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_dup2file
+++++ * verifies that both file descriptors are valid, and that the OLDFD is
+++++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++++ */
+++++int
+++++filetable_dup2file(int oldfd, int newfd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++
+++++	file = ft->ft_openfiles[oldfd];
+++++	if (file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++++	if (oldfd == newfd) {
+++++		return 0;
+++++	}
+++++
+++++	/* closes the newfd if it's open */
+++++	if (ft->ft_openfiles[newfd] != NULL) {
+++++		result = file_close(newfd);
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
+++++
+++++	/* up the refcount */
+++++	lock_acquire(file->of_lock);
+++++	file->of_refcount++;
+++++	lock_release(file->of_lock);
+++++
+++++	/* doesn't need to be synchronized because it's just changing the ft */
+++++	ft->ft_openfiles[newfd] = file;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++++new file mode 100644
++++index 0000000..8aa024c
++++--- /dev/null
+++++++ b/kern/syscall/file_syscalls.c
++++@@ -0,0 +1,270 @@
+++++/*
+++++ * File-related system call implementations.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <kern/seek.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++#include <copyinout.h>
+++++
+++++/*
+++++ * sys_open
+++++ * just copies in the filename, then passes work to file_open.
+++++ */
+++++int
+++++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++++{
+++++	char fname[PATH_MAX];
+++++	int result;
+++++
+++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return file_open(fname, flags, mode, retval);
+++++}
+++++
+++++/*
+++++ * sys_read
+++++ * translates the fd into its openfile, then calls VOP_READ.
+++++ */
+++++int
+++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* better be a valid file descriptor */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_WRONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++++  
+++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++++
+++++	/* does the read */
+++++	result = VOP_READ(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++	
+++++	/*
+++++	 * The amount read is the size of the buffer originally, minus
+++++	 * how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * sys_write
+++++ * translates the fd into its openfile, then calls VOP_WRITE.
+++++ */
+++++int
+++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_RDONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++++	
+++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++++
+++++	/* does the write */
+++++	result = VOP_WRITE(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	/*
+++++	 * the amount written is the size of the buffer originally,
+++++	 * minus how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_close
+++++ * just pass off the work to file_close.
+++++ */
+++++int
+++++sys_close(int fd)
+++++{
+++++	return file_close(fd);
+++++}
+++++
+++++/*
+++++ * sys_lseek
+++++ * translates the fd into its openfile, then based on the type of seek,
+++++ * figure out the new offset, try the seek, if that succeeds, update the
+++++ * openfile.
+++++ */
+++++int
+++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++++{
+++++	struct stat info;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++	
+++++	/* based on the type of seek, set the retval */ 
+++++	switch (whence) {
+++++	    case SEEK_SET:
+++++		*retval = offset;
+++++		break;
+++++	    case SEEK_CUR:
+++++		*retval = file->of_offset + offset;
+++++		break;
+++++	    case SEEK_END:
+++++		result = VOP_STAT(file->of_vnode, &info);
+++++		if (result) {
+++++			lock_release(file->of_lock);
+++++			return result;
+++++		}
+++++		*retval = info.st_size + offset;
+++++		break;
+++++	    default:
+++++		lock_release(file->of_lock);
+++++		return EINVAL;
+++++	}
+++++
+++++	/* try the seek -- if it fails, return */
+++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++	
+++++	/* success -- update the file structure */
+++++	file->of_offset = *retval;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_dup2
+++++ * just pass the work off to the filetable
+++++ */
+++++int
+++++sys_dup2(int oldfd, int newfd, int *retval)
+++++{
+++++	int result;
+++++
+++++	result = filetable_dup2file(oldfd, newfd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = newfd;
+++++	return 0;
+++++}
+++++
+++++/* really not "file" calls, per se, but might as well put it here */
+++++
+++++/*
+++++ * sys_chdir
+++++ * copyin the path and pass it off to vfs.
+++++ */
+++++int
+++++sys_chdir(userptr_t path)
+++++{
+++++	char pathbuf[PATH_MAX];
+++++	int result;
+++++	
+++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return vfs_chdir(pathbuf);
+++++}
+++++
+++++/*
+++++ * sys___getcwd
+++++ * just use vfs_getcwd.
+++++ */
+++++int
+++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	int result;
+++++  
+++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	result = vfs_getcwd(&useruio);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = buflen - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++++index a6f45c8..4ba181a 100644
++++--- a/kern/syscall/runprogram.c
+++++++ b/kern/syscall/runprogram.c
++++@@ -44,6 +44,7 @@
++++ #include <vfs.h>
++++ #include <syscall.h>
++++ #include <test.h>
+++++#include <file.h>
++++ 
++++ /*
++++  * Load program "progname" and start running it in usermode.
++++@@ -66,6 +67,13 @@ runprogram(char *progname)
++++ 
++++ 	/* We should be a new thread. */
++++ 	KASSERT(curthread->t_addrspace == NULL);
+++++	
+++++  if (curthread->t_filetable == NULL) {
+++++		result = filetable_init("con:", "con:", "con:");
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
++++ 
++++ 	/* Create a new address sp
++\ No newline at end of file
++diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
++index 287a678..db31b89 100644
++--- a/user/testbin/badcall/bad_execv.c
+++++ b/user/testbin/badcall/bad_execv.c
++@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
++ 		return;
++ 	}
++ 
+++
++ 	rv = execv("/bin/true", args);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	exit(MAGIC_STATUS);
++diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
++index 809c68c..8eb69c3 100644
++--- a/user/testbin/badcall/bad_waitpid.c
+++++ b/user/testbin/badcall/bad_waitpid.c
++@@ -36,6 +36,7 @@
++ #include <unistd.h>
++ #include <errno.h>
++ #include <err.h>
+++#include<stdio.h>
++ 
++ #include "config.h"
++ #include "test.h"
++@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Hello:%d",(int)ptr);
++ 
++ 	rv = waitpid(pid, ptr, 0);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	waitpid(pid, &x, 0);
++ }
++ 
+++
++ static
++ void
++ wait_unaligned(void)
++@@ -85,13 +88,16 @@ wait_unaligned(void)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Aligned int:%d",&status);
++ 
++ 	/* start with proper integer alignment */
++ 	ptr = (char *)(&status[0]);
++-
+++	//printf("Aligned:%c\n",*ptr);
++ 	/* generate improper alignment on platforms with restrictions*/
++ 	ptr++;
++ 
+++	//Print("UnAligned:%c\n",*ptr);
+++
++ 	rv = waitpid(pid, (int *)ptr, 0);
++ 	report_survival(rv, errno, "wait with unaligned status");
++ 	if (rv<0) {
++diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
++new file mode 100644
++index 0000000..fe21882
++--- /dev/null
+++++ b/user/testbin/myforktest/Makefile
++@@ -0,0 +1,11 @@
+++# Makefile for forktest
+++
+++TOP=../../..
+++.include "$(TOP)/mk/os161.config.mk"
+++
+++PROG=myforktest
+++SRCS=myforktest.c
+++BINDIR=/testbin
+++
+++.include "$(TOP)/mk/os161.prog.mk"
+++
++diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
++new file mode 100644
++index 0000000..7bd6663
++--- /dev/null
+++++ b/user/testbin/myforktest/myforktest.c
++@@ -0,0 +1,33 @@
+++#include <unistd.h>
+++#include <string.h>
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <err.h>
+++
+++int main()
+++{
+++	int status;
+++	int pid;
+++	int childpid;
+++	int parent;
+++	int returnCode=fork();
+++
+++	if(returnCode==0)
+++	{
+++		childpid=getpid();
+++		printf("I am child:%d\n",childpid);
+++		return -10;
+++	}
+++	else
+++	{
+++		//printf("Return:%d",returnCode);
+++		//printf("Wait for child\n");
+++		parent=getpid();
+++		printf("I am parent:%d\n",parent);
+++		pid=waitpid(returnCode,&status,0);
+++		printf("Child id returned" "%d",pid);
+++		printf(" Return code: %d\n",status);
+++
+++	}
+++	return 0;
+++}
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/submitsys1.patch b/submitsys1.patch
new file mode 100644
index 0000000..17bf5d1
--- /dev/null
+++ b/submitsys1.patch
@@ -0,0 +1,12500 @@
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..33b99ff 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -32,11 +32,14 @@
+ #include <kern/syscall.h>
+ #include <lib.h>
+ #include <mips/trapframe.h>
++#include <addrspace.h>
++#include <copyinout.h>
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
+ 
+ 
++
+ /*
+  * System call dispatcher.
+  *
+@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++        int32_t retvalv1 = 0;
++        int64_t retval64;
+ 	int err;
++        int32_t stackarg1;
+ 
+ 	KASSERT(curthread != NULL);
+ 	KASSERT(curthread->t_curspl == 0);
+@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+ 		err = sys___time((userptr_t)tf->tf_a0,
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
++            case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++			       &retval);
++		break;
++	    case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++				&retval);
++		break;
++	    case SYS_close:
++		err = sys_close(tf->tf_a0);
++		break;
++	    case SYS_lseek:
++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++                                stackarg1, &retval64);
++                retval = retval64 >> 32;
++                retvalv1 = (int) retval64;
++                break;
++	    case SYS_dup2:
++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_chdir:
++		err = sys_chdir((userptr_t)tf->tf_a0);
++			break;
++	    case SYS___getcwd:
++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++			break;
++	    case SYS_fork:
++	    	err=0;
++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++	    	break;
++	    case SYS_execv:
++	    	err=0;
++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++	    	break;
++	    case SYS_getpid:
++	    	err=0;
++	    	err=sys_getpid(&retval);
++	    	break;
++	    case SYS_waitpid:
++	    	err=0;
++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++	    	//panic("Waitpid over");
++	    	break;
++	    case SYS__exit:
++	    	sys_exit((int)tf->tf_a0);
++	    	break;
++
+ 
+ 	    /* Add stuff here */
+  
+@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++                tf->tf_v1 = retvalv1;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+  */
+-void
+-enter_forked_process(struct trapframe *tf)
++//void
++//enter_forked_process(struct trapframe *tf)
++//{
++	//(void)tf;
++//}
++
++void enter_forked_process(void*tf,unsigned long adrspace)
+ {
+-	(void)tf;
++	tf=(struct trapframe*)tf;
++	struct trapframe newtf;
++	int flag;
++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++	if(flag)
++	{
++		newtf.tf_v0=ENOMEM;
++		newtf.tf_a3=1;
++	}
++
++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++	kfree(tf);
++	//tf=NULL;
++	//int flag;
++
++	curthread->pid=newtf.tf_a0;
++
++	as_activate(curthread->t_addrspace);
++
++
++
++	newtf.tf_v0=0;
++	newtf.tf_a3=0;
++	newtf.tf_epc+=4;
++	mips_usermode(&newtf);
+ }
+diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+new file mode 100644
+index 0000000..3e8d5b9
+--- /dev/null
++++ b/kern/arch/mips/syscall/syscall.c~
+@@ -0,0 +1,165 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++
++
++/*
++ * System call dispatcher.
++ *
++ * A pointer to the trapframe created during exception entry (in
++ * exception.S) is passed in.
++ *
++ * The calling conventions for syscalls are as follows: Like ordinary
++ * function calls, the first 4 32-bit arguments are passed in the 4
++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++ * unused.
++ *
++ * This much is the same as the calling conventions for ordinary
++ * function calls. In addition, the system call number is passed in
++ * the v0 register.
++ *
++ * On successful return, the return value is passed back in the v0
++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++ * function call, and additionally the a3 register is also set to 0 to
++ * indicate success.
++ *
++ * On an error return, the error code is passed back in the v0
++ * register, and the a3 register is set to 1 to indicate failure.
++ * (Userlevel code takes care of storing the error code in errno and
++ * returning the value -1 from the actual userlevel syscall function.
++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++ *
++ * Upon syscall return the program counter stored in the trapframe
++ * must be incremented by one instruction; otherwise the exception
++ * return code will restart the "syscall" instruction and the system
++ * call will repeat forever.
++ *
++ * If you run out of registers (which happens quickly with 64-bit
++ * values) further arguments must be fetched from the user-level
++ * stack, starting at sp+16 to skip over the slots for the
++ * registerized values, with copyin().
++ */
++void
++syscall(struct trapframe *tf)
++{
++	int callno;
++	int32_t retval;
++	int err;
++
++	KASSERT(curthread != NULL);
++	KASSERT(curthread->t_curspl == 0);
++	KASSERT(curthread->t_iplhigh_count == 0);
++
++	callno = tf->tf_v0;
++
++	/*
++	 * Initialize retval to 0. Many of the system calls don't
++	 * really return a value, just 0 for success and -1 on
++	 * error. Since retval is the value returned on success,
++	 * initialize it to 0 by default; thus it's not necessary to
++	 * deal with it except for calls that return other values, 
++	 * like write.
++	 */
++
++	retval = 0;
++
++	switch (callno) {
++	    case SYS_reboot:
++		err = sys_reboot(tf->tf_a0);
++		break;
++
++	    case SYS___time:
++		err = sys___time((userptr_t)tf->tf_a0,
++				 (userptr_t)tf->tf_a1);
++		break;
++		
++	    case SYS_open:
++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++	    break;
++
++	    /* Add stuff here */
++ 
++	    default:
++		kprintf("Unknown syscall %d\n", callno);
++		err = ENOSYS;
++		break;
++	}
++
++
++	if (err) {
++		/*
++		 * Return the error code. This gets converted at
++		 * userlevel to a return value of -1 and the error
++		 * code in errno.
++		 */
++		tf->tf_v0 = err;
++		tf->tf_a3 = 1;      /* signal an error */
++	}
++	else {
++		/* Success. */
++		tf->tf_v0 = retval;
++		tf->tf_a3 = 0;      /* signal no error */
++	}
++	
++	/*
++	 * Now, advance the program counter, to avoid restarting
++	 * the syscall over and over again.
++	 */
++	
++	tf->tf_epc += 4;
++
++	/* Make sure the syscall code didn't forget to lower spl */
++	KASSERT(curthread->t_curspl == 0);
++	/* ...or leak any spinlocks */
++	KASSERT(curthread->t_iplhigh_count == 0);
++}
++
++/*
++ * Enter user mode for a newly forked process.
++ *
++ * This function is provided as a reminder. You need to write
++ * both it and the code that calls it.
++ *
++ * Thus, you can trash it and do things another way if you prefer.
++ */
++void
++enter_forked_process(struct trapframe *tf)
++{
++	(void)tf;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7d5df71 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file      syscall/file.c
++file	  syscall/proc_sys.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file.h b/kern/include/file.h
+new file mode 100644
+index 0000000..2c63bc2
+--- /dev/null
++++ b/kern/include/file.h
+@@ -0,0 +1,59 @@
++/*
++ * Declarations for file handle and file table management.
++ * New for SOL2.
++ */
++
++#ifndef _FILE_H_
++#define _FILE_H_
++
++#include <limits.h>
++
++struct lock;
++struct vnode;
++
++/*** openfile section ***/
++
++/* 
++ * openfile struct 
++ * note that there's not too much to keep track of, since the vnode does most
++ * of that.  note that it does require synchronization, because a single
++ * openfile can be shared between processes (filetable inheritance).
++ */
++struct openfile {
++	struct vnode *of_vnode;
++	
++	struct lock *of_lock;
++	off_t of_offset;
++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++	int of_refcount;
++};
++
++/* opens a file (must be kernel pointers in the args) */
++int file_open(char *filename, int flags, int mode, int *retfd);
++
++/* closes a file */
++int file_close(int fd);
++
++
++/*** file table section ***/
++
++/*
++ * filetable struct
++ * just an array of open files.  nice and simple.  doesn't require
++ * synchronization, because a table can only be owned by a single process (on
++ * inheritance in fork, the table is copied).
++ */
++struct filetable {
++	struct openfile *ft_openfiles[OPEN_MAX];
++};
++
++/* these all have an implicit arg of the curthread's filetable */
++int filetable_init(const char *inpath, const char *outpath, 
++		   const char *errpath);
++int filetable_copy(struct filetable **copy);
++int filetable_placefile(struct openfile *file, int *fd);
++int filetable_findfile(int fd, struct openfile **file);
++int filetable_dup2file(int oldfd, int newfd);
++void filetable_destroy(struct filetable *ft);
++
++#endif /* _FILE_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..3a54e24 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,6 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++//#define OPEN_MAX        64
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..df9fe64 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,11 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        //struct spinlock cv_lock;
++        struct wchan *cv_wchan;
++        //volatile int hold;
++        //struct thread *holder;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int res_count;
++        struct wchan *rd_wchan;
++        struct wchan *wr_wchan;
++        struct semaphore *rw_sem;
++        struct lock *rw_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+new file mode 100644
+index 0000000..d98aeb7
+--- /dev/null
++++ b/kern/include/synch.h~
+@@ -0,0 +1,161 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _SYNCH_H_
++#define _SYNCH_H_
++
++/*
++ * Header file for synchronization primitives.
++ */
++
++
++#include <spinlock.h>
++
++/*
++ * Dijkstra-style semaphore.
++ *
++ * The name field is for easier debugging. A copy of the name is made
++ * internally.
++ */
++struct semaphore {
++        char *sem_name;
++	struct wchan *sem_wchan;
++	struct spinlock sem_lock;
++        volatile int sem_count;
++};
++
++struct semaphore *sem_create(const char *name, int initial_count);
++void sem_destroy(struct semaphore *);
++
++/*
++ * Operations (both atomic):
++ *     P (proberen): decrement count. If the count is 0, block until
++ *                   the count is 1 again before decrementing.
++ *     V (verhogen): increment count.
++ */
++void P(struct semaphore *);
++void V(struct semaphore *);
++
++
++/*
++ * Simple lock for mutual exclusion.
++ *
++ * When the lock is created, no thread should be holding it. Likewise,
++ * when the lock is destroyed, no thread should be holding it.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++struct lock {
++        char *lk_name;
++//volatile struct thread *lockNeed;
++        struct spinlock mut_lock;
++        struct wchan *mut_wchan;
++        volatile int hold;
++struct thread *holder;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct lock *lock_create(const char *name);
++void lock_acquire(struct lock *);
++
++/*
++ * Operations:
++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++ *                   same time.
++ *    lock_release - Free the lock. Only the thread holding the lock may do
++ *                   this.
++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++ *                   false otherwise.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void lock_release(struct lock *);
++bool lock_do_i_hold(struct lock *);
++void lock_destroy(struct lock *);
++
++
++/*
++ * Condition variable.
++ *
++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++ * to wait until a variable meets a particular condition, but there's no
++ * actual variable, as such, in the CV.
++ *
++ * These CVs are expected to support Mesa semantics, that is, no
++ * guarantees are made about scheduling.
++ *
++ * The name field is for easier debugging. A copy of the name is
++ * (should be) made internally.
++ */
++
++struct cv {
++        char *cv_name;
++        // add what you need here
++        // (don't forget to mark things volatile as needed)
++};
++
++struct cv *cv_create(const char *name);
++void cv_destroy(struct cv *);
++
++/*
++ * Operations:
++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++ *                   waking up again, re-acquire the lock.
++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++ *
++ * For all three operations, the current thread must hold the lock passed 
++ * in. Note that under normal circumstances the same lock should be used
++ * on all operations with any particular CV.
++ *
++ * These operations must be atomic. You get to write them.
++ */
++void cv_wait(struct cv *cv, struct lock *lock);
++void cv_signal(struct cv *cv, struct lock *lock);
++void cv_broadcast(struct cv *cv, struct lock *lock);
++
++/*
++ * 13 Feb 2012 : GWA : Reader-writer locks.
++ */
++
++struct rwlock {
++        char *rwlock_name;
++};
++
++struct rwlock * rwlock_create(const char *);
++void rwlock_destroy(struct rwlock *);
++
++void rwlock_acquire_read(struct rwlock *);
++void rwlock_release_read(struct rwlock *);
++void rwlock_acquire_write(struct rwlock *);
++void rwlock_release_write(struct rwlock *);
++
++#endif /* _SYNCH_H_ */
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ea96700 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -26,6 +26,7 @@
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  */
++#include<thread.h>
+ 
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+  * Support functions.
+  */
+ 
++
+ /* Helper for fork(). You write this. */
+-void enter_forked_process(struct trapframe *tf);
++void enter_forked_process(void *tf,unsigned long adrspace);
+ 
+ /* Enter user mode. Does not return. */
+ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+  * Prototypes for IN-KERNEL entry points for system call implementations.
+  */
+ 
++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++int sys_close(int fd);
++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++int sys_dup2(int oldfd, int newfd, int *retval);
++int sys_chdir(userptr_t path);
++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++int sys_execv(char* progname,char** arguments);
++int sys_getpid(pid_t *retval);
++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++void sys_exit(int exitcode);
++int mywait(struct process* mypro);
+ 
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..84f60fc 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname,char** argv,unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..77a3515 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -73,7 +73,10 @@ struct thread {
+ 	 */
+ 	char *t_name;			/* Name of this thread */
+ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+-	threadstate_t t_state;		/* State this thread is in */
++	threadstate_t t_state;
++	/* State this thread is in */
++
++	pid_t pid;
+ 
+ 	/*
+ 	 * Thread subsystem internal fields.
+@@ -104,7 +107,7 @@ struct thread {
+ 	/*
+ 	 * Public fields
+ 	 */
+-
++	struct process* proc;
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+ 
+@@ -112,6 +115,19 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++  struct filetable *t_filetable;
++};
++
++struct process {
++	int full;
++	pid_t pid;
++    pid_t ppid;
++    //struct semaphore* exitsem;
++    struct lock* tlock;
++    struct cv* wcv;
++    bool exited;
++    int exitcode;
++    struct thread* self;
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..c9124e8 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..83ea620 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -153,6 +153,7 @@ void
+ uio_kinit(struct iovec *iov, struct uio *u,
+ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+ {
++	KASSERT(u);
+ 	iov->iov_kbase = kbuf;
+ 	iov->iov_len = len;
+ 	u->uio_iov = iov;
+@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	KASSERT(u);
++	iov->iov_ubase = ubuf;
++	iov->iov_len = len;
++  u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..4d8e7e2 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+new file mode 100644
+index 0000000..4d8e7e2
+--- /dev/null
++++ b/kern/startup/main.c~
+@@ -0,0 +1,211 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Main.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/reboot.h>
++#include <kern/unistd.h>
++#include <lib.h>
++#include <spl.h>
++#include <clock.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <vm.h>
++#include <mainbus.h>
++#include <vfs.h>
++#include <device.h>
++#include <syscall.h>
++#include <test.h>
++#include <version.h>
++#include "autoconf.h"  // for pseudoconfig
++
++
++/*
++ * These two pieces of data are maintained by the makefiles and build system.
++ * buildconfig is the name of the config file the kernel was configured with.
++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++ *
++ * The purpose is not to show off how many kernels you've linked, but
++ * to make it easy to make sure that the kernel you just booted is the
++ * same one you just built.
++ */
++extern const int buildversion;
++extern const char buildconfig[];
++
++/*
++ * Copyright message for the OS/161 base code.
++ */
++static const char harvard_copyright[] =
++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++
++
++/*
++ * Initial boot sequence.
++ */
++static
++void
++boot(void)
++{
++	/*
++	 * The order of these is important!
++	 * Don't go changing it without thinking about the consequences.
++	 *
++	 * Among other things, be aware that console output gets
++	 * buffered up at first and does not actually appear until
++	 * mainbus_bootstrap() attaches the console device. This can
++	 * be remarkably confusing if a bug occurs at this point. So
++	 * don't put new code before mainbus_bootstrap if you don't
++	 * absolutely have to.
++	 *
++	 * Also note that the buffer for this is only 1k. If you
++	 * overflow it, the system will crash without printing
++	 * anything at all. You can make it larger though (it's in
++	 * dev/generic/console.c).
++	 */
++
++	kprintf("\n");
++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++	kprintf("%s", harvard_copyright);
++	kprintf("\n");
++
++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++		GROUP_VERSION, buildconfig, buildversion);
++	kprintf("\n");
++
++	/* Early initialization. */
++	ram_bootstrap();
++	thread_bootstrap();
++	hardclock_bootstrap();
++	vfs_bootstrap();
++
++	/* Probe and initialize devices. Interrupts should come on. */
++	kprintf("Device probe...\n");
++	KASSERT(curthread->t_curspl > 0);
++	mainbus_bootstrap();
++	KASSERT(curthread->t_curspl == 0);
++	/* Now do pseudo-devices. */
++	pseudoconfig();
++	kprintf("\n");
++
++	/* Late phase of initialization. */
++	vm_bootstrap();
++	kprintf_bootstrap();
++	thread_start_cpus();
++
++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++	vfs_setbootfs("emu0");
++
++
++	/*
++	 * Make sure various things aren't screwed up.
++	 */
++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++}
++
++/*
++ * Shutdown sequence. Opposite to boot().
++ */
++static
++void
++shutdown(void)
++{
++
++	kprintf("Shutting down.\n");
++	
++	vfs_clearbootfs();
++	vfs_clearcurdir();
++	vfs_unmountall();
++
++	thread_shutdown();
++
++	splhigh();
++}
++
++/*****************************************/
++
++/*
++ * reboot() system call.
++ *
++ * Note: this is here because it's directly related to the code above,
++ * not because this is where system call code should go. Other syscall
++ * code should probably live in the "syscall" directory.
++ */
++int
++sys_reboot(int code)
++{
++	switch (code) {
++	    case RB_REBOOT:
++	    case RB_HALT:
++	    case RB_POWEROFF:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	shutdown();
++
++	switch (code) {
++	    case RB_HALT:
++		kprintf("The system is halted.\n");
++		mainbus_halt();
++		break;
++	    case RB_REBOOT:
++		kprintf("Rebooting...\n");
++		mainbus_reboot();
++		break;
++	    case RB_POWEROFF:
++		kprintf("The system is halted.\n");
++		mainbus_poweroff();
++		break;
++	}
++
++	panic("reboot operation failed\n");
++	return 0;
++}
++
++/*
++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++ * request, and then shut down.
++ */
++void
++kmain(char *arguments)
++{
++	boot();
++
++	menu(arguments);
++
++	/* Should not get here */
++}
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..a4c2750 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -40,9 +40,13 @@
+ #include <sfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include<thread.h>
++#include<synch.h>
+ #include "opt-synchprobs.h"
+ #include "opt-sfs.h"
+ #include "opt-net.h"
++#include <copyinout.h>
++//#include "proc_sys.c"
+ 
+ /*
+  * In-kernel menu and command dispatcher.
+@@ -51,6 +55,7 @@
+ #define _PATH_SHELL "/bin/sh"
+ 
+ #define MAXMENUARGS  16
++extern struct process* p_table[17];
+ 
+ // XXX this should not be in this file
+ void
+@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args,nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -127,6 +132,8 @@ int
+ common_prog(int nargs, char **args)
+ {
+ 	int result;
++	struct thread* fthread;
++	//int err;
+ 
+ #if OPT_SYNCHPROBS
+ 	kprintf("Warning: this probably won't work with a "
+@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&fthread);
++	//fthread->
++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++
++	fthread->pid=PID_MIN;
++	fthread->proc->pid=PID_MIN;
++
++	fthread->proc->self=fthread;
++	fthread->proc->wcv=cv_create("First CV");
++	fthread->proc->tlock=lock_create("First Lock");
++	p_table[0]=fthread->proc;
++
++	lock_acquire(p_table[0]->tlock);
++	mywait(p_table[0]);
++	lock_release(p_table[0]->tlock);
++
++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++
++	//fthread->proc->
++	//while(!p_table[0]->exited)
++
++
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..6c0bb3f 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -43,11 +43,25 @@
+  * You should implement your solution to the whalemating problem below.
+  */
+ 
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+-// the top of the corresponding driver code.
++// the top of the corresponding driver code
++
++struct semaphore *male_sem;
++struct semaphore *female_sem;
++struct lock *hold;
++struct cv* mate_cv;
++volatile int male_count;
++volatile int female_count;
+ 
+ void whalemating_init() {
++ hold=lock_create("My lock");
++ male_sem=sem_create("Male Semaphore",0);
++ female_sem=sem_create("Female Semaphore",0);
++mate_cv=cv_create("mating cv");
++male_count=0;
++female_count=0;
+   return;
+ }
+ 
+@@ -55,6 +69,11 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	sem_destroy(male_sem);
++	sem_destroy(female_sem);
++	lock_destroy(hold);
++	cv_destroy(mate_cv);
+   return;
+ }
+ 
+@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+   (void)which;
+   
+   male_start();
++
++  lock_acquire(hold);
++
++  V(male_sem);
++  male_count++;
++  if(female_count!=0)
++  cv_signal(mate_cv,hold);
++  else
++	  cv_wait(mate_cv,hold);
++  lock_release(hold);
++
+ 	// Implement this function 
+   male_end();
+ 
+@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+   (void)which;
+   
+   female_start();
++  lock_acquire(hold);
++   V(female_sem);
++   female_count++;
++   if(male_count!=0)
++   cv_signal(mate_cv,hold);
++   else
++	   cv_wait(mate_cv,hold);
++  lock_release(hold);
+ 	// Implement this function 
+   female_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+   (void)which;
+   
+   matchmaker_start();
++  lock_acquire(hold);
++ P(male_sem);
++ male_count--;
++ lock_release(hold);
++ lock_acquire(hold);
++  P(female_sem);
++  female_count--;
++  lock_release(hold);
+ 	// Implement this function 
+   matchmaker_end();
+-  
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock* intersect_lock;
++struct cv* intersect_cv;
++volatile int cur_poss[4];// an array to store the possible positions of the car
++//currently
+ 
+ void stoplight_init() {
++	intersect_cv=cv_create("Intersection Condition Variable");
++	if(intersect_cv==NULL)
++	{
++		///return NULL;
++		panic("condition variable not created");
++	}
++	intersect_lock=lock_create("A lock on the intersection");
++	if(intersect_lock==NULL)
++	{
++		//return NULL;
++		panic("Lock could not be created");
++	}
++	
++	
+   return;
+ }
+ 
+@@ -145,6 +210,8 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(intersect_cv);
++	lock_destroy(intersect_lock);
+   return;
+ }
+ 
+@@ -152,8 +219,29 @@ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++  //(void)direction;
++	int sec_quad=(direction+3)%4;
++	lock_acquire(intersect_lock);
++	// So while any of the two possible quadrants are already set, It means some 
++	//thread is waiting...Hopefully
++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++		cv_wait(intersect_cv,intersect_lock);
++	cur_poss[direction]=1;
++	cur_poss[sec_quad]=1;
++	inQuadrant(direction);
++	lock_release(intersect_lock);
++	lock_acquire(intersect_lock);
++    cur_poss[direction]=0;
++    //while(curr_p)
++    //cv_broadcast(intersect_cv);
++    inQuadrant(sec_quad);
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++    cur_poss[sec_quad]=0;
++    leaveIntersection();
++    cv_broadcast(intersect_cv,intersect_lock);
++    lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  int sec_quad=(direction+3)%4;
++  int third_quad=(direction+2)%4;
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  cur_poss[sec_quad]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++  lock_acquire(intersect_lock);
++  cur_poss[direction]=0;
+   
++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++  //cv_wait(intersect_cv,intersect_lock);
++      cur_poss[third_quad]=1;
++      //while(curr_p)
++      //cv_broadcast(intersect_cv);
++      inQuadrant(sec_quad);
++      cv_broadcast(intersect_cv,intersect_lock);
++      lock_release(intersect_lock);
++        lock_acquire(intersect_lock);
++            //currposs[direction]=0;
++            cur_poss[sec_quad]=0;
++            //while(curr_p)
++            //cv_broadcast(intersect_cv);
++            inQuadrant(third_quad);
++            cv_broadcast(intersect_cv,intersect_lock);
++                //cur_poss[third_quad]=0;
++            lock_release(intersect_lock);
++              lock_acquire(intersect_lock);
++                leaveIntersection();
++                cur_poss[third_quad]=0;
++                cv_broadcast(intersect_cv,intersect_lock);
++                lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
+-
++  // Easy coz the vehicle is in same lane!!
++  lock_acquire(intersect_lock);
++  while(cur_poss[direction]==1)
++	  cv_wait(intersect_cv,intersect_lock);
++  cur_poss[direction]=1;
++  inQuadrant(direction);
++  lock_release(intersect_lock);
++    lock_acquire(intersect_lock);
++  leaveIntersection();
++  cur_poss[direction]=0;
++  cv_broadcast(intersect_cv,intersect_lock);
++  lock_release(intersect_lock);
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+new file mode 100644
+index 0000000..dc5ffe5
+--- /dev/null
++++ b/kern/syscall/file.c
+@@ -0,0 +1,341 @@
++/*
++ * File handles and file tables.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++
++/*** openfile functions ***/
++
++/*
++ * file_open
++ * opens a file, places it in the filetable, sets RETFD to the file
++ * descriptor. the pointer arguments must be kernel pointers.
++ * NOTE -- the passed in filename must be a mutable string.
++ */
++int
++file_open(char *filename, int flags, int mode, int *retfd)
++{
++	struct vnode *vn;
++	struct openfile *file;
++	int result;
++	
++	result = vfs_open(filename, flags, mode, &vn);
++	if (result) {
++		return result;
++	}
++
++	file = kmalloc(sizeof(struct openfile));
++	if (file == NULL) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	/* initialize the file struct */
++	file->of_lock = lock_create("file lock");
++	if (file->of_lock == NULL) {
++		vfs_close(vn);
++		kfree(file);
++		return ENOMEM;
++	}
++	file->of_vnode = vn;
++	file->of_offset = 0;
++	file->of_accmode = flags & O_ACCMODE;
++	file->of_refcount = 1;
++
++	/* vfs_open checks for invalid access modes */
++	KASSERT(file->of_accmode==O_RDONLY ||
++	        file->of_accmode==O_WRONLY ||
++	        file->of_accmode==O_RDWR);
++
++	/* place the file in the filetable, getting the file descriptor */
++	result = filetable_placefile(file, retfd);
++	if (result) {
++		lock_destroy(file->of_lock);
++		kfree(file);
++		vfs_close(vn);
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * file_doclose
++ * shared code for file_close and filetable_destroy
++ */
++static
++int
++file_doclose(struct openfile *file)
++{
++	lock_acquire(file->of_lock);
++
++	/* if this is the last close of this file, free it up */
++	if (file->of_refcount == 1) {
++		vfs_close(file->of_vnode);
++		lock_release(file->of_lock);
++		lock_destroy(file->of_lock);
++		kfree(file);
++	}
++	else {
++		KASSERT(file->of_refcount > 1);
++		file->of_refcount--;
++		lock_release(file->of_lock);
++	}
++
++	return 0;
++}
++
++/* 
++ * file_close
++ * knock off the refcount, freeing the memory if it goes to 0.
++ */
++int
++file_close(int fd)
++{
++	struct openfile *file;
++	int result;
++
++	/* find the file in the filetable */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	result = file_doclose(file);
++	if (result) {
++		/* leave file open for possible retry */
++		return result;
++	}
++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++
++	return 0;
++}
++
++/*** filetable functions ***/
++
++/* 
++ * filetable_init
++ * pretty straightforward -- allocate the space, initialize to NULL.
++ * note that the one careful thing is to open the std i/o in order to
++ * get
++ * stdin  == 0
++ * stdout == 1
++ * stderr == 2
++ */
++int
++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++{
++	/* the filenames come from the kernel; assume reasonable length */
++	char path[32];
++	int result;
++	int fd;
++
++	/* make sure we can fit these */
++	KASSERT(strlen(inpath) < sizeof(path));
++	KASSERT(strlen(outpath) < sizeof(path));
++	KASSERT(strlen(errpath) < sizeof(path));
++	
++	/* catch memory leaks, repeated calls */
++	KASSERT(curthread->t_filetable == NULL);
++
++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++	if (curthread->t_filetable == NULL) {
++		return ENOMEM;
++	}
++	
++	/* NULL-out the table */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++	}
++
++	/*
++	 * open the std fds.  note that the names must be copied into
++	 * the path buffer so that they're mutable.
++	 */
++	strcpy(path, inpath);
++	result = file_open(path, O_RDONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, outpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	strcpy(path, errpath);
++	result = file_open(path, O_WRONLY, 0, &fd);
++	if (result) {
++		return result;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_copy
++ * again, pretty straightforward.  the subtle business here is that instead of
++ * copying the openfile structure, we just increment the refcount.  this means
++ * that openfile structs will, in fact, be shared between processes, as in
++ * Unix.
++ */
++int
++filetable_copy(struct filetable **copy)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int fd;
++
++	/* waste of a call, really */
++	if (ft == NULL) {
++		*copy = NULL;
++		return 0;
++	}
++	
++	*copy = kmalloc(sizeof(struct filetable));
++	
++	if (*copy == NULL) {
++		return ENOMEM;
++	}
++
++	/* copy over the entries */
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd] != NULL) {
++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++			ft->ft_openfiles[fd]->of_refcount++;
++			lock_release(ft->ft_openfiles[fd]->of_lock);
++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++		} 
++		else {
++			(*copy)->ft_openfiles[fd] = NULL;
++		}
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_destroy
++ * closes the files in the file table, frees the table.
++ */
++void
++filetable_destroy(struct filetable *ft)
++{
++	int fd, result;
++
++	KASSERT(ft != NULL);
++
++	for (fd = 0; fd < OPEN_MAX; fd++) {
++		if (ft->ft_openfiles[fd]) {
++			result = file_doclose(ft->ft_openfiles[fd]);
++			KASSERT(result==0);
++		}
++	}
++	
++	kfree(ft);
++}	
++
++/* 
++ * filetable_placefile
++ * finds the smallest available file descriptor, places the file at the point,
++ * sets FD to it.
++ */
++int
++filetable_placefile(struct openfile *file, int *fd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	int i;
++	
++	for (i = 0; i < OPEN_MAX; i++) {
++		if (ft->ft_openfiles[i] == NULL) {
++			ft->ft_openfiles[i] = file;
++			*fd = i;
++			return 0;
++		}
++	}
++
++	return EMFILE;
++}
++
++/*
++ * filetable_findfile
++ * verifies that the file descriptor is valid and actually references an
++ * open file, setting the FILE to the file at that index if it's there.
++ */
++int
++filetable_findfile(int fd, struct openfile **file)
++{
++	struct filetable *ft = curthread->t_filetable;
++
++	if (fd < 0 || fd >= OPEN_MAX) {
++		return EBADF;
++	}
++	
++	*file = ft->ft_openfiles[fd];
++	if (*file == NULL) {
++		return EBADF;
++	}
++
++	return 0;
++}
++
++/*
++ * filetable_dup2file
++ * verifies that both file descriptors are valid, and that the OLDFD is
++ * actually an open file.  then, if the NEWFD is open, it closes it.
++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++ */
++int
++filetable_dup2file(int oldfd, int newfd)
++{
++	struct filetable *ft = curthread->t_filetable;
++	struct openfile *file;
++	int result;
++
++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++		return EBADF;
++	}
++
++	file = ft->ft_openfiles[oldfd];
++	if (file == NULL) {
++		return EBADF;
++	}
++
++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++	if (oldfd == newfd) {
++		return 0;
++	}
++
++	/* closes the newfd if it's open */
++	if (ft->ft_openfiles[newfd] != NULL) {
++		result = file_close(newfd);
++		if (result) {
++			return result;
++		}
++	}
++
++	/* up the refcount */
++	lock_acquire(file->of_lock);
++	file->of_refcount++;
++	lock_release(file->of_lock);
++
++	/* doesn't need to be synchronized because it's just changing the ft */
++	ft->ft_openfiles[newfd] = file;
++
++	return 0;
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..8aa024c
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,270 @@
++/*
++ * File-related system call implementations.
++ * New for SOL2.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/limits.h>
++#include <kern/stat.h>
++#include <kern/unistd.h>
++#include <kern/fcntl.h>
++#include <kern/seek.h>
++#include <lib.h>
++#include <synch.h>
++#include <uio.h>
++#include <thread.h>
++#include <current.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <file.h>
++#include <syscall.h>
++#include <copyinout.h>
++
++/*
++ * sys_open
++ * just copies in the filename, then passes work to file_open.
++ */
++int
++sys_open(userptr_t filename, int flags, int mode, int *retval)
++{
++	char fname[PATH_MAX];
++	int result;
++
++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++	if (result) {
++		return result;
++	}
++
++	return file_open(fname, flags, mode, retval);
++}
++
++/*
++ * sys_read
++ * translates the fd into its openfile, then calls VOP_READ.
++ */
++int
++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	/* better be a valid file descriptor */
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_WRONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++  
++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++
++	/* does the read */
++	result = VOP_READ(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++	
++	/*
++	 * The amount read is the size of the buffer originally, minus
++	 * how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/*
++ * sys_write
++ * translates the fd into its openfile, then calls VOP_WRITE.
++ */
++int
++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++
++	if (file->of_accmode == O_RDONLY) {
++		lock_release(file->of_lock);
++		return EBADF;
++	}
++
++	/* set up a uio with the buffer, its size, and the current offset */
++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++	
++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++
++	/* does the write */
++	result = VOP_WRITE(file->of_vnode, &useruio);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++
++	/* set the offset to the updated offset in the uio */
++	file->of_offset = useruio.uio_offset;
++
++	lock_release(file->of_lock);
++
++	/*
++	 * the amount written is the size of the buffer originally,
++	 * minus how much is left in it.
++	 */
++	*retval = size - useruio.uio_resid;
++
++	return 0;
++}
++
++/* 
++ * sys_close
++ * just pass off the work to file_close.
++ */
++int
++sys_close(int fd)
++{
++	return file_close(fd);
++}
++
++/*
++ * sys_lseek
++ * translates the fd into its openfile, then based on the type of seek,
++ * figure out the new offset, try the seek, if that succeeds, update the
++ * openfile.
++ */
++int
++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++{
++	struct stat info;
++	struct openfile *file;
++	int result;
++
++	result = filetable_findfile(fd, &file);
++	if (result) {
++		return result;
++	}
++
++	lock_acquire(file->of_lock);
++	
++	/* based on the type of seek, set the retval */ 
++	switch (whence) {
++	    case SEEK_SET:
++		*retval = offset;
++		break;
++	    case SEEK_CUR:
++		*retval = file->of_offset + offset;
++		break;
++	    case SEEK_END:
++		result = VOP_STAT(file->of_vnode, &info);
++		if (result) {
++			lock_release(file->of_lock);
++			return result;
++		}
++		*retval = info.st_size + offset;
++		break;
++	    default:
++		lock_release(file->of_lock);
++		return EINVAL;
++	}
++
++	/* try the seek -- if it fails, return */
++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++	if (result) {
++		lock_release(file->of_lock);
++		return result;
++	}
++	
++	/* success -- update the file structure */
++	file->of_offset = *retval;
++
++	lock_release(file->of_lock);
++
++	return 0;
++}
++
++/* 
++ * sys_dup2
++ * just pass the work off to the filetable
++ */
++int
++sys_dup2(int oldfd, int newfd, int *retval)
++{
++	int result;
++
++	result = filetable_dup2file(oldfd, newfd);
++	if (result) {
++		return result;
++	}
++
++	*retval = newfd;
++	return 0;
++}
++
++/* really not "file" calls, per se, but might as well put it here */
++
++/*
++ * sys_chdir
++ * copyin the path and pass it off to vfs.
++ */
++int
++sys_chdir(userptr_t path)
++{
++	char pathbuf[PATH_MAX];
++	int result;
++	
++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++	if (result) {
++		return result;
++	}
++
++	return vfs_chdir(pathbuf);
++}
++
++/*
++ * sys___getcwd
++ * just use vfs_getcwd.
++ */
++int
++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++{
++  struct iovec iov;
++	struct uio useruio;
++	int result;
++  
++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++
++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++
++	result = vfs_getcwd(&useruio);
++	if (result) {
++		return result;
++	}
++
++	*retval = buflen - useruio.uio_resid;
++
++	return 0;
++}
+diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+new file mode 100644
+index 0000000..56698c9
+--- /dev/null
++++ b/kern/syscall/proc_sys.c
+@@ -0,0 +1,446 @@
++/*
++
++ * proc_sys.c
++ *
++ *  Created on: Mar 7, 2014
++ *      Author: trinity
++ */
++
++#include <types.h>
++#include<mips/trapframe.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file.h>
++#include <synch.h>
++#include<copyinout.h>
++#include <spl.h>
++#include<kern/wait.h>
++
++extern struct process* p_table[17];
++
++//struct cv* wcv;
++
++extern pid_t pidcount;
++int mywait(struct process* mypro) {
++	//lock_acquire(mypro->tlock);
++	while (!mypro->exited) {
++		cv_wait(mypro->wcv, mypro->tlock);
++	}
++	//*status=mypro->exitcode;
++	//lock_release(mypro->tlock);
++	//int test = mypro->exitcode;
++	//test++;
++	return 0;
++}
++
++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++	(void) adrs;
++	int flag;
++	pid_t childid;
++	struct addrspace *adrcopy;
++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++			sizeof(struct trapframe));
++	bzero(copyt, sizeof(struct trapframe));
++
++	//struct filetable* copyft;
++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++
++	memcpy(copyt, tf, sizeof(struct trapframe));
++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++	//if(curthread->pid==0)
++	//{
++	//curthread->pid=PID_MIN;
++	//}
++	if (flag) {
++		kfree(copyt);
++		return flag;
++	}
++
++	//we need to allocate pid for our new process
++
++	//pid_t cpid;
++	for (childid = 0; childid <= 16; childid++) {
++		if (p_table[childid] == NULL ) {
++			p_table[childid] = (struct process*) kmalloc(
++					sizeof(struct process));
++			p_table[childid]->full = 1;
++			pidcount++;
++			p_table[childid]->pid = pidcount;
++			p_table[childid]->ppid = curthread->pid;
++			//p_table[childid]->exitsem=sem_create("process",0);
++			p_table[childid]->tlock = lock_create("My Lock");
++			p_table[childid]->wcv = cv_create("My CV");
++			p_table[childid]->self = NULL;
++			break;
++		}
++	}
++	if (childid > PID_MAX) {
++		*retval = 1;
++		return EMPROC;
++	}
++	//int i;
++
++	copyt->tf_a0 = (int) p_table[childid]->pid;
++	//kprintf("Ret:%d\n",copyt->tf_a0);
++	struct thread *new_proc;
++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++	//int s=splhigh();
++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++			(unsigned long) adrcopy, &new_proc);
++	//kprintf("Out of thread fork:%d\n",flag);
++	if (flag) {
++		kfree(copyt);
++		as_destroy(adrcopy);
++
++		return flag;
++	}
++
++	//new_proc->pid=(pid_t)childid;
++	//new_proc=p_table[childid];
++
++	new_proc->pid = p_table[childid]->pid;
++	new_proc->proc = p_table[childid];
++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++	//if (new_proc->t_filetable == NULL) {
++	//return ENOMEM;
++	//}
++	p_table[childid]->self = new_proc;
++
++	//new_proc->pid=p_table[childid]->pid;
++	//new_proc->proc->pid=p_table[childid]->pid;
++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++
++	//kprintf("Child id:%d",new_proc->pid);
++	//new_proc->t_filetable->
++	//for(i=0;i<128;i++)
++	//{
++	flag = filetable_copy(&new_proc->t_filetable);
++	//}
++	//splx(s);
++	// kprintf("Fork over!");
++
++	*retval = p_table[childid]->pid;
++	//kprintf("Return val in fork:%d",*retval);
++	return 0;
++
++	//flag=
++	//flag=thread_fork=
++}
++
++int sys_execv(char *progname, char** arguments) {
++
++	int flag;
++	int numargs;
++	int addr;
++	int i;
++	// first we need to copy the program name to the kernel space
++	// then we go for arguments. Path size unknown
++
++	size_t actual_size = 0;
++	char *namedes;
++
++	if (progname == NULL ) {
++		return EFAULT;
++	}
++	if (progname == "") {
++		return EINVAL;
++	}
++
++	namedes = (char*) kmalloc(PATH_MAX);
++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++			&actual_size);
++	if (flag != 0) {
++		kfree(namedes);
++		return flag;
++	}
++	//namedes[actual_size]
++	if (strlen(namedes) == 0) {
++		//*retval=1;
++		return EISDIR;
++	}
++
++	// now we open file using vfs_open. Same as runprogram
++	struct vnode* vn;
++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++	if (flag) {
++		return flag;
++	}
++	actual_size = 0;
++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++
++	//char** kargv=(char**)kmalloc(sizeof(char));
++	// get the number of arguments
++	if (arguments == NULL ) {
++		kfree(namedes);
++		return EFAULT;
++	}
++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++	if (flag) {
++		kfree(namedes);
++		return EFAULT;
++	}
++
++	//check=wthread->exitcode;
++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++	//if(err)
++	//{
++	//	lock_release(p_table[i]->tlock);
++	//return err;
++	//}
++
++	numargs = 0;
++	while (arguments[numargs] != NULL ) {
++		//kprintf("%");
++		numargs = numargs + 1;
++	}
++
++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++	//int i;
++	for (i = 0; i < numargs; i++) {
++		actual_size = 0;
++		kargv[i] = (char*) kmalloc(PATH_MAX);
++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++				&actual_size);
++		if (flag) {
++			kfree(kargv);
++			kfree(namedes);
++			return EFAULT;
++		}
++
++	}
++	actual_size = 0;
++
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace == NULL ) {
++		vfs_close(vn);
++		return ENOMEM;
++	}
++
++	vaddr_t entrypoint, stackptr;
++	as_activate(curthread->t_addrspace);
++	flag = load_elf(vn, &entrypoint);
++	if (flag) {
++		// thread_exit destroys curthread->t_addrspace
++		vfs_close(vn);
++		return flag;
++	}
++
++	vfs_close(vn);
++
++	// now set up the user stack with the arguments
++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (flag) {
++		//thread_exit destroys curthread->t_addrspace
++		return flag;
++	}
++
++	//i=0;
++	vaddr_t stackptrv[numargs + 1];
++	for (i = numargs - 1; i >= 0; i--) {
++		int len = strlen(kargv[i]);
++		int padder=0;
++		len++;// to account for string terminator
++		//if(len%4!=0)
++		padder = len % 4;
++		stackptr =stackptr-( len + (4-padder));
++
++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++				&actual_size);
++
++		if (flag)
++		{
++			kfree(kargv);
++			kfree(namedes);
++			return flag;
++		}
++
++		stackptrv[i] = stackptr;
++	}
++	stackptrv[numargs] = 0;
++
++	//This copies the actual stack addresses of the arguments
++	//* into the stack. Hopefully.
++
++	 for(i = numargs; i >= 0; i--)
++	 {
++	 stackptr -= sizeof(vaddr_t);
++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++
++	 if(flag)
++	 {
++	 kfree(kargv);
++	 kfree(namedes);
++	 return flag;
++	 }
++
++	 }
++
++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++	//pt_getthread();
++
++	//enter_new_process does not return.
++	panic("enter_new_process returned\n");
++	return EINVAL;
++
++}
++
++int sys_getpid(pid_t *retval) {
++	//kprintf("In get pid:%d\n",curthread->pid);
++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++
++	*retval = curthread->proc->pid;
++	return 0;
++}
++
++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++	struct process* wthread = NULL;
++	int check;
++	int err;
++	pid_t i;
++	//kprintf("PID in wait pid:%d\n",pid);
++	if (status == NULL )
++		return EFAULT;
++	if (options != 0)
++		return EINVAL;
++	if (pid == curthread->pid)
++		return ECHILD;
++	if (pid < PID_MIN || pid > PID_MAX)
++		return ESRCH;
++	if (status == NULL )
++		return EFAULT;
++	if (pid == curthread->proc->ppid)
++		return ECHILD;
++	//int *shit;
++	//*shit=(int)&status;
++	//kprintf("%d\n",*shit);
++	//if(curthread->)
++	//if(pid!=curthread->)
++	//char* argv=(char*)(status);
++	//int length=strlen(argv)+1;
++	//int length=strlen(kargv[i])+1;
++	//int padder=length%4;
++	//kprintf("Hai:%d\n",padder);
++	//if(padder!=0)
++	//{
++	//return EFAULT;
++	//}
++
++	//if()
++
++	//char pathbuf[PATH_MAX];
++	//int *buffer;
++	//int result;
++
++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++	//if (result) {
++	//return result;
++	//}
++	//int addr=(int)&status;
++	//kprintf("Status:%d\n",addr);
++	//int *addr=&status;
++	//if(addr%4!=0)
++	//{
++	//return EFAULT;
++	//}
++	//kprintf("Got Here\n");
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				wthread = p_table[i];
++				break;
++			}
++		}
++	}
++	if (wthread == NULL ) {
++		return ESRCH;
++	}
++	if (curthread->proc->pid != wthread->ppid)
++		return ECHILD;
++	//panic("We are here");
++
++	lock_acquire(p_table[i]->tlock);
++
++	//while(!wthread->exited)
++	//{
++//
++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++	//}
++	mywait(wthread);
++
++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++	//kprintf("We are here!");
++
++	check = wthread->exitcode;
++	err = copyout(&check, (userptr_t) status, sizeof(check));
++	if (err) {
++		lock_release(p_table[i]->tlock);
++		return err;
++	}
++	//kprintf("Exit code After waiting:%d\n",*status);
++	//kfree(p_table[i]->exitsem);
++	//p_table[i]=NULL;
++
++	//panic("After kfree");
++	//p_table[i]=NULL;
++	lock_release(p_table[i]->tlock);
++	//filetable_destroy(p_table[i]->self->t_filetable);
++	//lock_destroy(p_table[i]->tlock);
++	//cv_destroy(p_table[i]->wcv);
++	//kfree(p_table[i]);
++	p_table[i] = NULL;
++
++	*retval = pid;
++	//panic("After dereferencing");
++	return 0;
++
++	//return -1;
++	//return 0;
++}
++
++void sys_exit(int exitcode) {
++	pid_t pid = curthread->proc->pid;
++	pid_t i = PID_MIN;
++	struct process* ethread;
++//pid_t parent;
++//if(pid!=2)
++//{
++	for (i = 0; i <= 16; i++) {
++		if (p_table[i] != NULL ) {
++			if (p_table[i]->pid == pid) {
++				ethread = p_table[i];
++				break;
++			}
++		}
++	}
++
++//parent=ethread->ppid;
++	if (ethread != NULL ) {
++		lock_acquire(ethread->tlock);
++//kprintf("Exit code Before:%d\n",exitcode);
++
++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++		ethread->exited = 1;
++//p_table[i]=ethread;
++		cv_broadcast(ethread->wcv, ethread->tlock);
++//kfree(curthread->t_filetable);
++		lock_release(ethread->tlock);
++	}
++//}
++	i = 0;
++//
++//kprintf("Before hanging");
++//filetable_destroy(curthread->t_filetable);
++//kfree(curthread->p);
++
++	thread_exit();
++}
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..6d6dc37 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file.h>
++#include<copyinout.h>
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,7 +54,7 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char**argv,unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+@@ -66,6 +68,13 @@ runprogram(char *progname)
+ 
+ 	/* We should be a new thread. */
+ 	KASSERT(curthread->t_addrspace == NULL);
++	curthread->t_filetable=NULL;
++  if (curthread->t_filetable == NULL) {
++		result = filetable_init("con:", "con:", "con:");
++		if (result) {
++			return result;
++		}
++	}
+ 
+ 	/* Create a new address space. */
+ 	curthread->t_addrspace = as_create();
+@@ -94,9 +103,40 @@ runprogram(char *progname)
+ 		/* thread_exit destroys curthread->t_addrspace */
+ 		return result;
+ 	}
++	vaddr_t stackptrv[argc+1];
++int i;
++size_t actual;
++for(i = argc-1; i >= 0; i--)
++{
++int len = strlen(argv[i]);
++int padder=0;
++len++;
++if(len%4!=0)
++padder = len % 4;
++stackptr=stackptr-( len + (4-padder));
++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++if(result)
++{
++return result;
++}
++stackptrv[i] = stackptr;
++}
++stackptrv[argc] = 0;
++for(i = argc; i >= 0; i--)
++{
++stackptr -= sizeof(vaddr_t);
++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++if(result)
++{
++return result;
++}
++}
++
++
++
+ 
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	enter_new_process(argc, (userptr_t)stackptr,
+ 			  stackptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..851f9ea 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,8 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++#define MAXREADERS 20;
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -162,9 +164,17 @@ lock_create(const char *name)
+                 kfree(lock);
+                 return NULL;
+         }
+-        
+-        // add stuff here as needed
+-        
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
+         return lock;
+ }
+ 
+@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+ 
+         // add stuff here as needed
+         
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +195,78 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(&lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -225,7 +289,18 @@ cv_create(const char *name)
+                 kfree(cv);
+                 return NULL;
+         }
+-        
++        cv->cv_wchan = wchan_create(cv->cv_name);
++                	if (cv->cv_wchan == NULL) {
++                		kfree(cv->cv_name);
++                		kfree(cv);
++                		return NULL;
++                	}
++
++                	//spinlock_init(&cv->cv_lock);
++                        //lock->hold = 0;
++        		//lock->holder=NULL;
++                //lock->=NULL
++                return cv;
+         // add stuff here as needed
+         
+         return cv;
+@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+ 
+         // add stuff here as needed
+         
++        //spinlock_cleanup(&cv->cv_lock);
++        
++        wchan_destroy(cv->cv_wchan);
+         kfree(cv->cv_name);
+         kfree(cv);
+ }
+@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	//KASSERT(lock_do_i_hold(lock));
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
++	
++    // Write this
++    //(void)cv;    // suppress warning until code gets written
++    //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeone(cv->cv_wchan);
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv!=NULL);
++	KASSERT(lock!=NULL);
++	KASSERT(lock_do_i_hold(lock));
++	wchan_wakeall(cv->cv_wchan);
++		
++	
++	//(void)cv;    // suppress warning until code gets written
++	//(void)lock;  // suppress warning until code gets written
++}
++
++struct rwlock *rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++	rw=kmalloc(sizeof(struct rwlock));
++	if(rw==NULL)
++	{
++		return NULL;
++	}
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL)
++	{
++		kfree(rw);
++		return NULL;
++	}
++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++	if(rw->rd_wchan==NULL)
++	{
++		kfree(rw->rwlock_name);
++		kfree(rw);
++		return NULL;
++	}
++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++		if(rw->wr_wchan==NULL)
++		{
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++		}
++		rw->rw_sem=sem_create("mysem",20);
++		rw->rw_lock=lock_create("mylock");
++	///rw->res_count=MAXREADERS;
++	return rw;
++	
++}
++void rwlock_destroy(struct rwlock *rw)
++{
++		KASSERT(rw != NULL);
++		
++		wchan_destroy(rw->rd_wchan);
++		wchan_destroy(rw->wr_wchan);
++		sem_destroy(rw->rw_sem);
++		lock_destroy(rw->rw_lock);
++	    kfree(rw->rwlock_name);
++        kfree(rw);	
++}
++
++void rwlock_acquire_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	P(rw->rw_sem);
++	lock_release(rw->rw_lock);
++}
++void rwlock_release_read(struct rwlock *rw)
++{
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	V(rw->rw_sem);
++	//lock_release(rw->rw_lock);
++}
++void rwlock_acquire_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	lock_acquire(rw->rw_lock);
++	//rwlock->rw_sem->V();
++	for(i=0;i<20;i++)
++	{
++	P(rw->rw_sem);
++	}	
++	lock_release(rw->rw_lock);
++	
++	
+ }
++void rwlock_release_write(struct rwlock *rw)
++{
++	int i;
++	KASSERT(rw!=NULL);
++	//lock_acquire(rw->rw_lock);
++	for(i=0;i<20;i++)
++	{
++	V(rw->rw_sem);
++	}	
++	//lock_release(rw->rw_lock);
++	
++}
++
++
++
++
++
++
++
++
++
++
+diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+new file mode 100644
+index 0000000..b9680d1
+--- /dev/null
++++ b/kern/thread/synch.c~
+@@ -0,0 +1,329 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++/*
++ * Synchronization primitives.
++ * The specifications of the functions are in synch.h.
++ */
++
++#include <types.h>
++#include <lib.h>
++#include <spinlock.h>
++#include <wchan.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++
++////////////////////////////////////////////////////////////
++//
++// Semaphore.
++
++struct semaphore *
++sem_create(const char *name, int initial_count)
++{
++        struct semaphore *sem;
++
++        KASSERT(initial_count >= 0);
++
++        sem = kmalloc(sizeof(struct semaphore));
++        if (sem == NULL) {
++                return NULL;
++        }
++
++        sem->sem_name = kstrdup(name);
++        if (sem->sem_name == NULL) {
++                kfree(sem);
++                return NULL;
++        }
++
++	sem->sem_wchan = wchan_create(sem->sem_name);
++	if (sem->sem_wchan == NULL) {
++		kfree(sem->sem_name);
++		kfree(sem);
++		return NULL;
++	}
++
++	spinlock_init(&sem->sem_lock);
++        sem->sem_count = initial_count;
++
++        return sem;
++}
++
++void
++sem_destroy(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&sem->sem_lock);
++	wchan_destroy(sem->sem_wchan);
++        kfree(sem->sem_name);
++        kfree(sem);
++}
++
++void 
++P(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++        /*
++         * May not block in an interrupt handler.
++         *
++         * For robustness, always check, even if we can actually
++         * complete the P without blocking.
++         */
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&sem->sem_lock);
++        while (sem->sem_count == 0) {
++		/*
++		 * Bridge to the wchan lock, so if someone else comes
++		 * along in V right this instant the wakeup can't go
++		 * through on the wchan until we've finished going to
++		 * sleep. Note that wchan_sleep unlocks the wchan.
++		 *
++		 * Note that we don't maintain strict FIFO ordering of
++		 * threads going through the semaphore; that is, we
++		 * might "get" it on the first try even if other
++		 * threads are waiting. Apparently according to some
++		 * textbooks semaphores must for some reason have
++		 * strict ordering. Too bad. :-)
++		 *
++		 * Exercise: how would you implement strict FIFO
++		 * ordering?
++		 */
++		wchan_lock(sem->sem_wchan);
++		spinlock_release(&sem->sem_lock);
++                wchan_sleep(sem->sem_wchan);
++
++		spinlock_acquire(&sem->sem_lock);
++        }
++        KASSERT(sem->sem_count > 0);
++        sem->sem_count--;
++	spinlock_release(&sem->sem_lock);
++}
++
++void
++V(struct semaphore *sem)
++{
++        KASSERT(sem != NULL);
++
++	spinlock_acquire(&sem->sem_lock);
++
++        sem->sem_count++;
++        KASSERT(sem->sem_count > 0);
++	wchan_wakeone(sem->sem_wchan);
++
++	spinlock_release(&sem->sem_lock);
++}
++
++////////////////////////////////////////////////////////////
++//
++// Lock.
++
++struct lock *
++lock_create(const char *name)
++{
++        struct lock *lock;
++
++        lock = kmalloc(sizeof(struct lock));
++        if (lock == NULL) {
++                return NULL;
++        }
++
++        lock->lk_name = kstrdup(name);
++        if (lock->lk_name == NULL) {
++                kfree(lock);
++                return NULL;
++        }
++        lock->mut_wchan = wchan_create(lock->lk_name);
++        	if (lock->mut_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++
++        	spinlock_init(&lock->mut_lock);
++                lock->hold = 0;
++		lock->holder=NULL;
++        //lock->=NULL
++        return lock;
++}
++
++void
++lock_destroy(struct lock *lock)
++{
++        KASSERT(lock != NULL);
++
++        // add stuff here as needed
++        
++        spinlock_cleanup(&lock->mut_lock);
++        	wchan_destroy(lock->mut_wchan);
++        kfree(lock->lk_name);
++        kfree(lock);
++}
++
++void
++lock_acquire(struct lock *lock)
++{
++        // Write this
++KASSERT(lock!=NULL);
++
++
++//KASSERT(sem != NULL);
++
++        
++        KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->mut_lock);
++        while (lock->hold ) {
++		
++		wchan_lock(lock->mut_wchan);
++		spinlock_release(&lock->mut_lock);
++                wchan_sleep(lock->mut_wchan);
++
++		spinlock_acquire(lock->mut_lock);
++        }
++        KASSERT(lock->hold ==0 );
++        lock->hold=1;
++	lock->holder=curthread;
++        //sem->sem_count--;
++	spinlock_release(&lock->mut_lock);
++
++        //(void)lock;  // suppress warning until code gets written
++}
++
++void
++lock_release(struct lock *lock)
++{
++	KASSERT(lock!=NULL);
++	KASSERT(lock->hold);
++	KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->mut_lock);
++	lock->hold=0;
++	
++	        //sem->sem_count++;
++	        KASSERT(lock->hold == 0);
++lock->holder=NULL;
++		wchan_wakeone(lock->mut_wchan);
++
++		spinlock_release(&lock->mut_lock);
++        // Write this
++	/*
++	
++	KASSERT(lock!=NULL);
++	KASSERT(lock->lockNeed==curthread);
++	spinlock_acquire(&lock->lockNeed);
++	lock->lockNeed==NULL;
++	
++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++	spinlock_release(&lock->lockNeed);
++*/
++        //(void)lock;  // suppress warning until code gets written
++}
++
++bool
++lock_do_i_hold(struct lock *lock)
++{
++        // Write this
++	
++
++        //(void)lock;  // suppress warning until code gets written
++	KASSERT(lock!=NULL);
++	//spinlock_acquire(&lock->mut_lock);
++	if(!lock->hold) return false;
++if(lock->holder==curthread) return true;
++else 
++return false;
++	
++    //spinlock_release(&lock->mut_lock);
++    
++        //return res; // dummy until code gets written
++}
++
++////////////////////////////////////////////////////////////
++//
++// CV
++
++
++struct cv *
++cv_create(const char *name)
++{
++        struct cv *cv;
++
++        cv = kmalloc(sizeof(struct cv));
++        if (cv == NULL) {
++                return NULL;
++        }
++
++        cv->cv_name = kstrdup(name);
++        if (cv->cv_name==NULL) {
++                kfree(cv);
++                return NULL;
++        }
++        
++        // add stuff here as needed
++        
++        return cv;
++}
++
++void
++cv_destroy(struct cv *cv)
++{
++        KASSERT(cv != NULL);
++
++        // add stuff here as needed
++        
++        kfree(cv->cv_name);
++        kfree(cv);
++}
++
++void
++cv_wait(struct cv *cv, struct lock *lock)
++{
++        // Write this
++        (void)cv;    // suppress warning until code gets written
++        (void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_signal(struct cv *cv, struct lock *lock)
++{
++        // Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
++
++void
++cv_broadcast(struct cv *cv, struct lock *lock)
++{
++	// Write this
++	(void)cv;    // suppress warning until code gets written
++	(void)lock;  // suppress warning until code gets written
++}
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..df129b9 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,7 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <file.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+ 
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
++pid_t pidcount;
++struct process* p_table[17];
+ 
+ ////////////////////////////////////////////////////////////
+ 
+@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+ 
+ /*
+  * Check the magic number we put on the bottom end of the stack in
+- * thread_checkstack_init. If these assertions go off, it most likely
++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+  * means you overflowed your stack at some point, which can cause all
+  * kinds of mysterious other things to happen.
+  *
+@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++  KASSERT(thread->t_filetable == NULL);
++
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+ }
+@@ -352,8 +357,15 @@ thread_bootstrap(void)
+ {
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
++	int i;
+ 
+ 	cpuarray_init(&allcpus);
++	pidcount=PID_MIN;
++
++	for(i=0;i<=16;i++)
++	{
++		p_table[i]=NULL;
++	}
+ 
+ 	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+@@ -365,6 +377,7 @@ thread_bootstrap(void)
+ 	 */
+ 	bootcpu = cpu_create(0);
+ 	bootthread = bootcpu->c_curthread;
++	//bootthread->pid=PID_MIN;
+ 
+ 	/*
+ 	 * Initializing curcpu and curthread is machine-dependent
+@@ -519,7 +532,7 @@ thread_fork(const char *name,
+ 	 * for the spllower() that will be done releasing it.
+ 	 */
+ 	newthread->t_iplhigh_count++;
+-
++	//newthread->pid=pidcount++;
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	switch (newstate) {
+ 	    case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+-		break;
+ 	    case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+@@ -799,6 +811,11 @@ thread_exit(void)
+ 		VOP_DECREF(cur->t_cwd);
+ 		cur->t_cwd = NULL;
+ 	}
++	
++	if (curthread->t_filetable) {
++		filetable_destroy(curthread->t_filetable);
++		curthread->t_filetable = NULL;
++	}
+ 
+ 	/* VM fields */
+ 	if (cur->t_addrspace) {
+diff --git a/single10.patch b/single10.patch
+new file mode 100644
+index 0000000..2267436
+--- /dev/null
++++ b/single10.patch
+@@ -0,0 +1,915 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..68c73ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,6 +32,7 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++		break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++		break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++		break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++		break;
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..e1d7682 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..f3a01ad 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++ 
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..08b8f8c 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -112,6 +112,7 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..4ba181a 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,7 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -66,6 +67,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index 5b8099e..60108d3 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -798,6 +801,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..04fc72b
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,8279 @@
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..33b99ff 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -32,11 +32,14 @@
++ #include <kern/syscall.h>
++ #include <lib.h>
++ #include <mips/trapframe.h>
+++#include <addrspace.h>
+++#include <copyinout.h>
++ #include <thread.h>
++ #include <current.h>
++ #include <syscall.h>
++ 
++ 
+++
++ /*
++  * System call dispatcher.
++  *
++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++        int32_t retvalv1 = 0;
+++        int64_t retval64;
++ 	int err;
+++        int32_t stackarg1;
++ 
++ 	KASSERT(curthread != NULL);
++ 	KASSERT(curthread->t_curspl == 0);
++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
++ 		err = sys___time((userptr_t)tf->tf_a0,
++ 				 (userptr_t)tf->tf_a1);
++ 		break;
+++            case SYS_open:
+++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_read:
+++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++			       &retval);
+++		break;
+++	    case SYS_write:
+++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++				&retval);
+++		break;
+++	    case SYS_close:
+++		err = sys_close(tf->tf_a0);
+++		break;
+++	    case SYS_lseek:
+++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++                                stackarg1, &retval64);
+++                retval = retval64 >> 32;
+++                retvalv1 = (int) retval64;
+++                break;
+++	    case SYS_dup2:
+++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_chdir:
+++		err = sys_chdir((userptr_t)tf->tf_a0);
+++			break;
+++	    case SYS___getcwd:
+++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++			break;
+++	    case SYS_fork:
+++	    	err=0;
+++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
+++	    	break;
+++	    case SYS_execv:
+++	    	err=0;
+++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
+++	    	break;
+++	    case SYS_getpid:
+++	    	err=0;
+++	    	err=sys_getpid(&retval);
+++	    	break;
+++	    case SYS_waitpid:
+++	    	err=0;
+++	    	//kprintf("Dispatch:%d",tf->tf_a0);
+++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++	    	//panic("Waitpid over");
+++	    	break;
+++	    case SYS__exit:
+++	    	sys_exit((int)tf->tf_a0);
+++	    	break;
+++
++ 
++ 	    /* Add stuff here */
++  
++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
++ 	else {
++ 		/* Success. */
++ 		tf->tf_v0 = retval;
+++                tf->tf_v1 = retvalv1;
++ 		tf->tf_a3 = 0;      /* signal no error */
++ 	}
++ 	
++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
++  *
++  * Thus, you can trash it and do things another way if you prefer.
++  */
++-void
++-enter_forked_process(struct trapframe *tf)
+++//void
+++//enter_forked_process(struct trapframe *tf)
+++//{
+++	//(void)tf;
+++//}
+++
+++void enter_forked_process(void*tf,unsigned long adrspace)
++ {
++-	(void)tf;
+++	tf=(struct trapframe*)tf;
+++	struct trapframe newtf;
+++	int flag;
+++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
+++	if(flag)
+++	{
+++		newtf.tf_v0=ENOMEM;
+++		newtf.tf_a3=1;
+++	}
+++
+++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
+++	kfree(tf);
+++	//tf=NULL;
+++	//int flag;
+++
+++	curthread->pid=newtf.tf_a0;
+++
+++	as_activate(curthread->t_addrspace);
+++
+++
+++
+++	newtf.tf_v0=0;
+++	newtf.tf_a3=0;
+++	newtf.tf_epc+=4;
+++	mips_usermode(&newtf);
++ }
++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
++new file mode 100644
++index 0000000..3e8d5b9
++--- /dev/null
+++++ b/kern/arch/mips/syscall/syscall.c~
++@@ -0,0 +1,165 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/syscall.h>
+++#include <lib.h>
+++#include <mips/trapframe.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <syscall.h>
+++
+++
+++/*
+++ * System call dispatcher.
+++ *
+++ * A pointer to the trapframe created during exception entry (in
+++ * exception.S) is passed in.
+++ *
+++ * The calling conventions for syscalls are as follows: Like ordinary
+++ * function calls, the first 4 32-bit arguments are passed in the 4
+++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
+++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
+++ * if the first argument is 32-bit and the second is 64-bit, a1 is
+++ * unused.
+++ *
+++ * This much is the same as the calling conventions for ordinary
+++ * function calls. In addition, the system call number is passed in
+++ * the v0 register.
+++ *
+++ * On successful return, the return value is passed back in the v0
+++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
+++ * function call, and additionally the a3 register is also set to 0 to
+++ * indicate success.
+++ *
+++ * On an error return, the error code is passed back in the v0
+++ * register, and the a3 register is set to 1 to indicate failure.
+++ * (Userlevel code takes care of storing the error code in errno and
+++ * returning the value -1 from the actual userlevel syscall function.
+++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
+++ *
+++ * Upon syscall return the program counter stored in the trapframe
+++ * must be incremented by one instruction; otherwise the exception
+++ * return code will restart the "syscall" instruction and the system
+++ * call will repeat forever.
+++ *
+++ * If you run out of registers (which happens quickly with 64-bit
+++ * values) further arguments must be fetched from the user-level
+++ * stack, starting at sp+16 to skip over the slots for the
+++ * registerized values, with copyin().
+++ */
+++void
+++syscall(struct trapframe *tf)
+++{
+++	int callno;
+++	int32_t retval;
+++	int err;
+++
+++	KASSERT(curthread != NULL);
+++	KASSERT(curthread->t_curspl == 0);
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++
+++	callno = tf->tf_v0;
+++
+++	/*
+++	 * Initialize retval to 0. Many of the system calls don't
+++	 * really return a value, just 0 for success and -1 on
+++	 * error. Since retval is the value returned on success,
+++	 * initialize it to 0 by default; thus it's not necessary to
+++	 * deal with it except for calls that return other values, 
+++	 * like write.
+++	 */
+++
+++	retval = 0;
+++
+++	switch (callno) {
+++	    case SYS_reboot:
+++		err = sys_reboot(tf->tf_a0);
+++		break;
+++
+++	    case SYS___time:
+++		err = sys___time((userptr_t)tf->tf_a0,
+++				 (userptr_t)tf->tf_a1);
+++		break;
+++		
+++	    case SYS_open:
+++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
+++	    break;
+++
+++	    /* Add stuff here */
+++ 
+++	    default:
+++		kprintf("Unknown syscall %d\n", callno);
+++		err = ENOSYS;
+++		break;
+++	}
+++
+++
+++	if (err) {
+++		/*
+++		 * Return the error code. This gets converted at
+++		 * userlevel to a return value of -1 and the error
+++		 * code in errno.
+++		 */
+++		tf->tf_v0 = err;
+++		tf->tf_a3 = 1;      /* signal an error */
+++	}
+++	else {
+++		/* Success. */
+++		tf->tf_v0 = retval;
+++		tf->tf_a3 = 0;      /* signal no error */
+++	}
+++	
+++	/*
+++	 * Now, advance the program counter, to avoid restarting
+++	 * the syscall over and over again.
+++	 */
+++	
+++	tf->tf_epc += 4;
+++
+++	/* Make sure the syscall code didn't forget to lower spl */
+++	KASSERT(curthread->t_curspl == 0);
+++	/* ...or leak any spinlocks */
+++	KASSERT(curthread->t_iplhigh_count == 0);
+++}
+++
+++/*
+++ * Enter user mode for a newly forked process.
+++ *
+++ * This function is provided as a reminder. You need to write
+++ * both it and the code that calls it.
+++ *
+++ * Thus, you can trash it and do things another way if you prefer.
+++ */
+++void
+++enter_forked_process(struct trapframe *tf)
+++{
+++	(void)tf;
+++}
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..7d5df71 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,9 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file      syscall/file_syscalls.c
+++file      syscall/file.c
+++file	  syscall/proc_sys.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/file.h b/kern/include/file.h
++new file mode 100644
++index 0000000..2c63bc2
++--- /dev/null
+++++ b/kern/include/file.h
++@@ -0,0 +1,59 @@
+++/*
+++ * Declarations for file handle and file table management.
+++ * New for SOL2.
+++ */
+++
+++#ifndef _FILE_H_
+++#define _FILE_H_
+++
+++#include <limits.h>
+++
+++struct lock;
+++struct vnode;
+++
+++/*** openfile section ***/
+++
+++/* 
+++ * openfile struct 
+++ * note that there's not too much to keep track of, since the vnode does most
+++ * of that.  note that it does require synchronization, because a single
+++ * openfile can be shared between processes (filetable inheritance).
+++ */
+++struct openfile {
+++	struct vnode *of_vnode;
+++	
+++	struct lock *of_lock;
+++	off_t of_offset;
+++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++	int of_refcount;
+++};
+++
+++/* opens a file (must be kernel pointers in the args) */
+++int file_open(char *filename, int flags, int mode, int *retfd);
+++
+++/* closes a file */
+++int file_close(int fd);
+++
+++
+++/*** file table section ***/
+++
+++/*
+++ * filetable struct
+++ * just an array of open files.  nice and simple.  doesn't require
+++ * synchronization, because a table can only be owned by a single process (on
+++ * inheritance in fork, the table is copied).
+++ */
+++struct filetable {
+++	struct openfile *ft_openfiles[OPEN_MAX];
+++};
+++
+++/* these all have an implicit arg of the curthread's filetable */
+++int filetable_init(const char *inpath, const char *outpath, 
+++		   const char *errpath);
+++int filetable_copy(struct filetable **copy);
+++int filetable_placefile(struct openfile *file, int *fd);
+++int filetable_findfile(int fd, struct openfile **file);
+++int filetable_dup2file(int oldfd, int newfd);
+++void filetable_destroy(struct filetable *ft);
+++
+++#endif /* _FILE_H_ */
++diff --git a/kern/include/limits.h b/kern/include/limits.h
++index 01684c4..3a54e24 100644
++--- a/kern/include/limits.h
+++++ b/kern/include/limits.h
++@@ -48,5 +48,6 @@
++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
++ #define OPEN_MAX        __OPEN_MAX
++ #define IOV_MAX         __IOV_MAX
+++//#define OPEN_MAX        64
++ 
++ #endif /* _LIMITS_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..df9fe64 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,11 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        //struct spinlock cv_lock;
+++        struct wchan *cv_wchan;
+++        //volatile int hold;
+++        //struct thread *holder;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ 
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int res_count;
+++        struct wchan *rd_wchan;
+++        struct wchan *wr_wchan;
+++        struct semaphore *rw_sem;
+++        struct lock *rw_lock;
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
++new file mode 100644
++index 0000000..d98aeb7
++--- /dev/null
+++++ b/kern/include/synch.h~
++@@ -0,0 +1,161 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _SYNCH_H_
+++#define _SYNCH_H_
+++
+++/*
+++ * Header file for synchronization primitives.
+++ */
+++
+++
+++#include <spinlock.h>
+++
+++/*
+++ * Dijkstra-style semaphore.
+++ *
+++ * The name field is for easier debugging. A copy of the name is made
+++ * internally.
+++ */
+++struct semaphore {
+++        char *sem_name;
+++	struct wchan *sem_wchan;
+++	struct spinlock sem_lock;
+++        volatile int sem_count;
+++};
+++
+++struct semaphore *sem_create(const char *name, int initial_count);
+++void sem_destroy(struct semaphore *);
+++
+++/*
+++ * Operations (both atomic):
+++ *     P (proberen): decrement count. If the count is 0, block until
+++ *                   the count is 1 again before decrementing.
+++ *     V (verhogen): increment count.
+++ */
+++void P(struct semaphore *);
+++void V(struct semaphore *);
+++
+++
+++/*
+++ * Simple lock for mutual exclusion.
+++ *
+++ * When the lock is created, no thread should be holding it. Likewise,
+++ * when the lock is destroyed, no thread should be holding it.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++struct lock {
+++        char *lk_name;
+++//volatile struct thread *lockNeed;
+++        struct spinlock mut_lock;
+++        struct wchan *mut_wchan;
+++        volatile int hold;
+++struct thread *holder;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct lock *lock_create(const char *name);
+++void lock_acquire(struct lock *);
+++
+++/*
+++ * Operations:
+++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+++ *                   same time.
+++ *    lock_release - Free the lock. Only the thread holding the lock may do
+++ *                   this.
+++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+++ *                   false otherwise.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void lock_release(struct lock *);
+++bool lock_do_i_hold(struct lock *);
+++void lock_destroy(struct lock *);
+++
+++
+++/*
+++ * Condition variable.
+++ *
+++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+++ * to wait until a variable meets a particular condition, but there's no
+++ * actual variable, as such, in the CV.
+++ *
+++ * These CVs are expected to support Mesa semantics, that is, no
+++ * guarantees are made about scheduling.
+++ *
+++ * The name field is for easier debugging. A copy of the name is
+++ * (should be) made internally.
+++ */
+++
+++struct cv {
+++        char *cv_name;
+++        // add what you need here
+++        // (don't forget to mark things volatile as needed)
+++};
+++
+++struct cv *cv_create(const char *name);
+++void cv_destroy(struct cv *);
+++
+++/*
+++ * Operations:
+++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+++ *                   waking up again, re-acquire the lock.
+++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+++ *    cv_broadcast - Wake up all threads sleeping on this CV.
+++ *
+++ * For all three operations, the current thread must hold the lock passed 
+++ * in. Note that under normal circumstances the same lock should be used
+++ * on all operations with any particular CV.
+++ *
+++ * These operations must be atomic. You get to write them.
+++ */
+++void cv_wait(struct cv *cv, struct lock *lock);
+++void cv_signal(struct cv *cv, struct lock *lock);
+++void cv_broadcast(struct cv *cv, struct lock *lock);
+++
+++/*
+++ * 13 Feb 2012 : GWA : Reader-writer locks.
+++ */
+++
+++struct rwlock {
+++        char *rwlock_name;
+++};
+++
+++struct rwlock * rwlock_create(const char *);
+++void rwlock_destroy(struct rwlock *);
+++
+++void rwlock_acquire_read(struct rwlock *);
+++void rwlock_release_read(struct rwlock *);
+++void rwlock_acquire_write(struct rwlock *);
+++void rwlock_release_write(struct rwlock *);
+++
+++#endif /* _SYNCH_H_ */
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..ea96700 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -26,6 +26,7 @@
++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++  * SUCH DAMAGE.
++  */
+++#include<thread.h>
++ 
++ #ifndef _SYSCALL_H_
++ #define _SYSCALL_H_
++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
++  * Support functions.
++  */
++ 
+++
++ /* Helper for fork(). You write this. */
++-void enter_forked_process(struct trapframe *tf);
+++void enter_forked_process(void *tf,unsigned long adrspace);
++ 
++ /* Enter user mode. Does not return. */
++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++  * Prototypes for IN-KERNEL entry points for system call implementations.
++  */
++ 
+++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++int sys_close(int fd);
+++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++int sys_dup2(int oldfd, int newfd, int *retval);
+++int sys_chdir(userptr_t path);
+++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
+++int sys_execv(char* progname,char** arguments);
+++int sys_getpid(pid_t *retval);
+++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
+++void sys_exit(int exitcode);
+++int mywait(struct process* mypro);
++ 
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..84f60fc 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
++ int nettest(int, char **);
++ 
++ /* Routine for running a user-level program. */
++-int runprogram(char *progname);
+++int runprogram(char *progname,char** argv,unsigned long argc);
++ 
++ /* Kernel menu system. */
++ void menu(char *argstr);
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..77a3515 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -73,7 +73,10 @@ struct thread {
++ 	 */
++ 	char *t_name;			/* Name of this thread */
++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
++-	threadstate_t t_state;		/* State this thread is in */
+++	threadstate_t t_state;
+++	/* State this thread is in */
+++
+++	pid_t pid;
++ 
++ 	/*
++ 	 * Thread subsystem internal fields.
++@@ -104,7 +107,7 @@ struct thread {
++ 	/*
++ 	 * Public fields
++ 	 */
++-
+++	struct process* proc;
++ 	/* VM */
++ 	struct addrspace *t_addrspace;	/* virtual address space */
++ 
++@@ -112,6 +115,19 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++  struct filetable *t_filetable;
+++};
+++
+++struct process {
+++	int full;
+++	pid_t pid;
+++    pid_t ppid;
+++    //struct semaphore* exitsem;
+++    struct lock* tlock;
+++    struct cv* wcv;
+++    bool exited;
+++    int exitcode;
+++    struct thread* self;
++ };
++ 
++ /* Call once during system startup to allocate data structures. */
++diff --git a/kern/include/uio.h b/kern/include/uio.h
++index 5d97c48..c9124e8 100644
++--- a/kern/include/uio.h
+++++ b/kern/include/uio.h
++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++ void uio_kinit(struct iovec *, struct uio *,
++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++ 
+++void uio_uinit(struct iovec *, struct uio *,
+++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++
++ 
++ #endif /* _UIO_H_ */
++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++index 594fe96..83ea620 100644
++--- a/kern/lib/uio.c
+++++ b/kern/lib/uio.c
++@@ -153,6 +153,7 @@ void
++ uio_kinit(struct iovec *iov, struct uio *u,
++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++ {
+++	KASSERT(u);
++ 	iov->iov_kbase = kbuf;
++ 	iov->iov_len = len;
++ 	u->uio_iov = iov;
++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++ 	u->uio_rw = rw;
++ 	u->uio_space = NULL;
++ }
+++
+++void
+++uio_uinit(struct iovec *iov, struct uio *u,
+++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++{
+++	KASSERT(u);
+++	iov->iov_ubase = ubuf;
+++	iov->iov_len = len;
+++  u->uio_iov = iov;
+++	u->uio_iovcnt = 1;
+++	u->uio_offset = pos;
+++	u->uio_resid = len;
+++	u->uio_segflg = UIO_USERSPACE;
+++	u->uio_rw = rw;
+++	u->uio_space = curthread->t_addrspace;
+++}
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..4d8e7e2 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -100,7 +100,7 @@ boot(void)
++ 	kprintf("%s", harvard_copyright);
++ 	kprintf("\n");
++ 
++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++ 		GROUP_VERSION, buildconfig, buildversion);
++ 	kprintf("\n");
++ 
++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
++new file mode 100644
++index 0000000..4d8e7e2
++--- /dev/null
+++++ b/kern/startup/main.c~
++@@ -0,0 +1,211 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Main.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/reboot.h>
+++#include <kern/unistd.h>
+++#include <lib.h>
+++#include <spl.h>
+++#include <clock.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++#include <vm.h>
+++#include <mainbus.h>
+++#include <vfs.h>
+++#include <device.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <version.h>
+++#include "autoconf.h"  // for pseudoconfig
+++
+++
+++/*
+++ * These two pieces of data are maintained by the makefiles and build system.
+++ * buildconfig is the name of the config file the kernel was configured with.
+++ * buildversion starts at 1 and is incremented every time you link a kernel. 
+++ *
+++ * The purpose is not to show off how many kernels you've linked, but
+++ * to make it easy to make sure that the kernel you just booted is the
+++ * same one you just built.
+++ */
+++extern const int buildversion;
+++extern const char buildconfig[];
+++
+++/*
+++ * Copyright message for the OS/161 base code.
+++ */
+++static const char harvard_copyright[] =
+++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
+++    "   President and Fellows of Harvard College.  All rights reserved.\n";
+++
+++
+++/*
+++ * Initial boot sequence.
+++ */
+++static
+++void
+++boot(void)
+++{
+++	/*
+++	 * The order of these is important!
+++	 * Don't go changing it without thinking about the consequences.
+++	 *
+++	 * Among other things, be aware that console output gets
+++	 * buffered up at first and does not actually appear until
+++	 * mainbus_bootstrap() attaches the console device. This can
+++	 * be remarkably confusing if a bug occurs at this point. So
+++	 * don't put new code before mainbus_bootstrap if you don't
+++	 * absolutely have to.
+++	 *
+++	 * Also note that the buffer for this is only 1k. If you
+++	 * overflow it, the system will crash without printing
+++	 * anything at all. You can make it larger though (it's in
+++	 * dev/generic/console.c).
+++	 */
+++
+++	kprintf("\n");
+++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+++	kprintf("%s", harvard_copyright);
+++	kprintf("\n");
+++
+++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++		GROUP_VERSION, buildconfig, buildversion);
+++	kprintf("\n");
+++
+++	/* Early initialization. */
+++	ram_bootstrap();
+++	thread_bootstrap();
+++	hardclock_bootstrap();
+++	vfs_bootstrap();
+++
+++	/* Probe and initialize devices. Interrupts should come on. */
+++	kprintf("Device probe...\n");
+++	KASSERT(curthread->t_curspl > 0);
+++	mainbus_bootstrap();
+++	KASSERT(curthread->t_curspl == 0);
+++	/* Now do pseudo-devices. */
+++	pseudoconfig();
+++	kprintf("\n");
+++
+++	/* Late phase of initialization. */
+++	vm_bootstrap();
+++	kprintf_bootstrap();
+++	thread_start_cpus();
+++
+++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+++	vfs_setbootfs("emu0");
+++
+++
+++	/*
+++	 * Make sure various things aren't screwed up.
+++	 */
+++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+++}
+++
+++/*
+++ * Shutdown sequence. Opposite to boot().
+++ */
+++static
+++void
+++shutdown(void)
+++{
+++
+++	kprintf("Shutting down.\n");
+++	
+++	vfs_clearbootfs();
+++	vfs_clearcurdir();
+++	vfs_unmountall();
+++
+++	thread_shutdown();
+++
+++	splhigh();
+++}
+++
+++/*****************************************/
+++
+++/*
+++ * reboot() system call.
+++ *
+++ * Note: this is here because it's directly related to the code above,
+++ * not because this is where system call code should go. Other syscall
+++ * code should probably live in the "syscall" directory.
+++ */
+++int
+++sys_reboot(int code)
+++{
+++	switch (code) {
+++	    case RB_REBOOT:
+++	    case RB_HALT:
+++	    case RB_POWEROFF:
+++		break;
+++	    default:
+++		return EINVAL;
+++	}
+++
+++	shutdown();
+++
+++	switch (code) {
+++	    case RB_HALT:
+++		kprintf("The system is halted.\n");
+++		mainbus_halt();
+++		break;
+++	    case RB_REBOOT:
+++		kprintf("Rebooting...\n");
+++		mainbus_reboot();
+++		break;
+++	    case RB_POWEROFF:
+++		kprintf("The system is halted.\n");
+++		mainbus_poweroff();
+++		break;
+++	}
+++
+++	panic("reboot operation failed\n");
+++	return 0;
+++}
+++
+++/*
+++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+++ * request, and then shut down.
+++ */
+++void
+++kmain(char *arguments)
+++{
+++	boot();
+++
+++	menu(arguments);
+++
+++	/* Should not get here */
+++}
++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
++index 6c71551..a4c2750 100644
++--- a/kern/startup/menu.c
+++++ b/kern/startup/menu.c
++@@ -40,9 +40,13 @@
++ #include <sfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include<thread.h>
+++#include<synch.h>
++ #include "opt-synchprobs.h"
++ #include "opt-sfs.h"
++ #include "opt-net.h"
+++#include <copyinout.h>
+++//#include "proc_sys.c"
++ 
++ /*
++  * In-kernel menu and command dispatcher.
++@@ -51,6 +55,7 @@
++ #define _PATH_SHELL "/bin/sh"
++ 
++ #define MAXMENUARGS  16
+++extern struct process* p_table[17];
++ 
++ // XXX this should not be in this file
++ void
++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
++ 
++ 	strcpy(progname, args[0]);
++ 
++-	result = runprogram(progname);
+++	result = runprogram(progname,args,nargs);
++ 	if (result) {
++ 		kprintf("Running program %s failed: %s\n", args[0],
++ 			strerror(result));
++@@ -127,6 +132,8 @@ int
++ common_prog(int nargs, char **args)
++ {
++ 	int result;
+++	struct thread* fthread;
+++	//int err;
++ 
++ #if OPT_SYNCHPROBS
++ 	kprintf("Warning: this probably won't work with a "
++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
++ 	result = thread_fork(args[0] /* thread name */,
++ 			cmd_progthread /* thread function */,
++ 			args /* thread arg */, nargs /* thread arg */,
++-			NULL);
+++			&fthread);
+++	//fthread->
+++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
+++
+++	fthread->pid=PID_MIN;
+++	fthread->proc->pid=PID_MIN;
+++
+++	fthread->proc->self=fthread;
+++	fthread->proc->wcv=cv_create("First CV");
+++	fthread->proc->tlock=lock_create("First Lock");
+++	p_table[0]=fthread->proc;
+++
+++	lock_acquire(p_table[0]->tlock);
+++	mywait(p_table[0]);
+++	lock_release(p_table[0]->tlock);
+++
+++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
+++
+++	//fthread->proc->
+++	//while(!p_table[0]->exited)
+++
+++
++ 	if (result) {
++ 		kprintf("thread_fork failed: %s\n", strerror(result));
++ 		return result;
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..6c0bb3f 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -43,11 +43,25 @@
++  * You should implement your solution to the whalemating problem below.
++  */
++ 
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++-// the top of the corresponding driver code.
+++// the top of the corresponding driver code
+++
+++struct semaphore *male_sem;
+++struct semaphore *female_sem;
+++struct lock *hold;
+++struct cv* mate_cv;
+++volatile int male_count;
+++volatile int female_count;
++ 
++ void whalemating_init() {
+++ hold=lock_create("My lock");
+++ male_sem=sem_create("Male Semaphore",0);
+++ female_sem=sem_create("Female Semaphore",0);
+++mate_cv=cv_create("mating cv");
+++male_count=0;
+++female_count=0;
++   return;
++ }
++ 
++@@ -55,6 +69,11 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++
+++	sem_destroy(male_sem);
+++	sem_destroy(female_sem);
+++	lock_destroy(hold);
+++	cv_destroy(mate_cv);
++   return;
++ }
++ 
++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
++   (void)which;
++   
++   male_start();
+++
+++  lock_acquire(hold);
+++
+++  V(male_sem);
+++  male_count++;
+++  if(female_count!=0)
+++  cv_signal(mate_cv,hold);
+++  else
+++	  cv_wait(mate_cv,hold);
+++  lock_release(hold);
+++
++ 	// Implement this function 
++   male_end();
++ 
++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
+++  lock_acquire(hold);
+++   V(female_sem);
+++   female_count++;
+++   if(male_count!=0)
+++   cv_signal(mate_cv,hold);
+++   else
+++	   cv_wait(mate_cv,hold);
+++  lock_release(hold);
++ 	// Implement this function 
++   female_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
+++  lock_acquire(hold);
+++ P(male_sem);
+++ male_count--;
+++ lock_release(hold);
+++ lock_acquire(hold);
+++  P(female_sem);
+++  female_count--;
+++  lock_release(hold);
++ 	// Implement this function 
++   matchmaker_end();
++-  
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
+++
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
+++struct lock* intersect_lock;
+++struct cv* intersect_cv;
+++volatile int cur_poss[4];// an array to store the possible positions of the car
+++//currently
++ 
++ void stoplight_init() {
+++	intersect_cv=cv_create("Intersection Condition Variable");
+++	if(intersect_cv==NULL)
+++	{
+++		///return NULL;
+++		panic("condition variable not created");
+++	}
+++	intersect_lock=lock_create("A lock on the intersection");
+++	if(intersect_lock==NULL)
+++	{
+++		//return NULL;
+++		panic("Lock could not be created");
+++	}
+++	
+++	
++   return;
++ }
++ 
++@@ -145,6 +210,8 @@ void stoplight_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
+++	cv_destroy(intersect_cv);
+++	lock_destroy(intersect_lock);
++   return;
++ }
++ 
++@@ -152,8 +219,29 @@ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++  //(void)direction;
+++	int sec_quad=(direction+3)%4;
+++	lock_acquire(intersect_lock);
+++	// So while any of the two possible quadrants are already set, It means some 
+++	//thread is waiting...Hopefully
+++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
+++		cv_wait(intersect_cv,intersect_lock);
+++	cur_poss[direction]=1;
+++	cur_poss[sec_quad]=1;
+++	inQuadrant(direction);
+++	lock_release(intersect_lock);
+++	lock_acquire(intersect_lock);
+++    cur_poss[direction]=0;
+++    //while(curr_p)
+++    //cv_broadcast(intersect_cv);
+++    inQuadrant(sec_quad);
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++    cur_poss[sec_quad]=0;
+++    leaveIntersection();
+++    cv_broadcast(intersect_cv,intersect_lock);
+++    lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
+++  int sec_quad=(direction+3)%4;
+++  int third_quad=(direction+2)%4;
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  cur_poss[sec_quad]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++  lock_acquire(intersect_lock);
+++  cur_poss[direction]=0;
++   
+++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
+++  //cv_wait(intersect_cv,intersect_lock);
+++      cur_poss[third_quad]=1;
+++      //while(curr_p)
+++      //cv_broadcast(intersect_cv);
+++      inQuadrant(sec_quad);
+++      cv_broadcast(intersect_cv,intersect_lock);
+++      lock_release(intersect_lock);
+++        lock_acquire(intersect_lock);
+++            //currposs[direction]=0;
+++            cur_poss[sec_quad]=0;
+++            //while(curr_p)
+++            //cv_broadcast(intersect_cv);
+++            inQuadrant(third_quad);
+++            cv_broadcast(intersect_cv,intersect_lock);
+++                //cur_poss[third_quad]=0;
+++            lock_release(intersect_lock);
+++              lock_acquire(intersect_lock);
+++                leaveIntersection();
+++                cur_poss[third_quad]=0;
+++                cv_broadcast(intersect_cv,intersect_lock);
+++                lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++   (void)direction;
++-
+++  // Easy coz the vehicle is in same lane!!
+++  lock_acquire(intersect_lock);
+++  while(cur_poss[direction]==1)
+++	  cv_wait(intersect_cv,intersect_lock);
+++  cur_poss[direction]=1;
+++  inQuadrant(direction);
+++  lock_release(intersect_lock);
+++    lock_acquire(intersect_lock);
+++  leaveIntersection();
+++  cur_poss[direction]=0;
+++  cv_broadcast(intersect_cv,intersect_lock);
+++  lock_release(intersect_lock);
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++new file mode 100644
++index 0000000..dc5ffe5
++--- /dev/null
+++++ b/kern/syscall/file.c
++@@ -0,0 +1,341 @@
+++/*
+++ * File handles and file tables.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++
+++/*** openfile functions ***/
+++
+++/*
+++ * file_open
+++ * opens a file, places it in the filetable, sets RETFD to the file
+++ * descriptor. the pointer arguments must be kernel pointers.
+++ * NOTE -- the passed in filename must be a mutable string.
+++ */
+++int
+++file_open(char *filename, int flags, int mode, int *retfd)
+++{
+++	struct vnode *vn;
+++	struct openfile *file;
+++	int result;
+++	
+++	result = vfs_open(filename, flags, mode, &vn);
+++	if (result) {
+++		return result;
+++	}
+++
+++	file = kmalloc(sizeof(struct openfile));
+++	if (file == NULL) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	/* initialize the file struct */
+++	file->of_lock = lock_create("file lock");
+++	if (file->of_lock == NULL) {
+++		vfs_close(vn);
+++		kfree(file);
+++		return ENOMEM;
+++	}
+++	file->of_vnode = vn;
+++	file->of_offset = 0;
+++	file->of_accmode = flags & O_ACCMODE;
+++	file->of_refcount = 1;
+++
+++	/* vfs_open checks for invalid access modes */
+++	KASSERT(file->of_accmode==O_RDONLY ||
+++	        file->of_accmode==O_WRONLY ||
+++	        file->of_accmode==O_RDWR);
+++
+++	/* place the file in the filetable, getting the file descriptor */
+++	result = filetable_placefile(file, retfd);
+++	if (result) {
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++		vfs_close(vn);
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * file_doclose
+++ * shared code for file_close and filetable_destroy
+++ */
+++static
+++int
+++file_doclose(struct openfile *file)
+++{
+++	lock_acquire(file->of_lock);
+++
+++	/* if this is the last close of this file, free it up */
+++	if (file->of_refcount == 1) {
+++		vfs_close(file->of_vnode);
+++		lock_release(file->of_lock);
+++		lock_destroy(file->of_lock);
+++		kfree(file);
+++	}
+++	else {
+++		KASSERT(file->of_refcount > 1);
+++		file->of_refcount--;
+++		lock_release(file->of_lock);
+++	}
+++
+++	return 0;
+++}
+++
+++/* 
+++ * file_close
+++ * knock off the refcount, freeing the memory if it goes to 0.
+++ */
+++int
+++file_close(int fd)
+++{
+++	struct openfile *file;
+++	int result;
+++
+++	/* find the file in the filetable */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	result = file_doclose(file);
+++	if (result) {
+++		/* leave file open for possible retry */
+++		return result;
+++	}
+++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++
+++	return 0;
+++}
+++
+++/*** filetable functions ***/
+++
+++/* 
+++ * filetable_init
+++ * pretty straightforward -- allocate the space, initialize to NULL.
+++ * note that the one careful thing is to open the std i/o in order to
+++ * get
+++ * stdin  == 0
+++ * stdout == 1
+++ * stderr == 2
+++ */
+++int
+++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++{
+++	/* the filenames come from the kernel; assume reasonable length */
+++	char path[32];
+++	int result;
+++	int fd;
+++
+++	/* make sure we can fit these */
+++	KASSERT(strlen(inpath) < sizeof(path));
+++	KASSERT(strlen(outpath) < sizeof(path));
+++	KASSERT(strlen(errpath) < sizeof(path));
+++	
+++	/* catch memory leaks, repeated calls */
+++	KASSERT(curthread->t_filetable == NULL);
+++
+++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++	if (curthread->t_filetable == NULL) {
+++		return ENOMEM;
+++	}
+++	
+++	/* NULL-out the table */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++	}
+++
+++	/*
+++	 * open the std fds.  note that the names must be copied into
+++	 * the path buffer so that they're mutable.
+++	 */
+++	strcpy(path, inpath);
+++	result = file_open(path, O_RDONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, outpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	strcpy(path, errpath);
+++	result = file_open(path, O_WRONLY, 0, &fd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_copy
+++ * again, pretty straightforward.  the subtle business here is that instead of
+++ * copying the openfile structure, we just increment the refcount.  this means
+++ * that openfile structs will, in fact, be shared between processes, as in
+++ * Unix.
+++ */
+++int
+++filetable_copy(struct filetable **copy)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int fd;
+++
+++	/* waste of a call, really */
+++	if (ft == NULL) {
+++		*copy = NULL;
+++		return 0;
+++	}
+++	
+++	*copy = kmalloc(sizeof(struct filetable));
+++	
+++	if (*copy == NULL) {
+++		return ENOMEM;
+++	}
+++
+++	/* copy over the entries */
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd] != NULL) {
+++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++			ft->ft_openfiles[fd]->of_refcount++;
+++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++		} 
+++		else {
+++			(*copy)->ft_openfiles[fd] = NULL;
+++		}
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_destroy
+++ * closes the files in the file table, frees the table.
+++ */
+++void
+++filetable_destroy(struct filetable *ft)
+++{
+++	int fd, result;
+++
+++	KASSERT(ft != NULL);
+++
+++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++		if (ft->ft_openfiles[fd]) {
+++			result = file_doclose(ft->ft_openfiles[fd]);
+++			KASSERT(result==0);
+++		}
+++	}
+++	
+++	kfree(ft);
+++}	
+++
+++/* 
+++ * filetable_placefile
+++ * finds the smallest available file descriptor, places the file at the point,
+++ * sets FD to it.
+++ */
+++int
+++filetable_placefile(struct openfile *file, int *fd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	int i;
+++	
+++	for (i = 0; i < OPEN_MAX; i++) {
+++		if (ft->ft_openfiles[i] == NULL) {
+++			ft->ft_openfiles[i] = file;
+++			*fd = i;
+++			return 0;
+++		}
+++	}
+++
+++	return EMFILE;
+++}
+++
+++/*
+++ * filetable_findfile
+++ * verifies that the file descriptor is valid and actually references an
+++ * open file, setting the FILE to the file at that index if it's there.
+++ */
+++int
+++filetable_findfile(int fd, struct openfile **file)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++
+++	if (fd < 0 || fd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++	
+++	*file = ft->ft_openfiles[fd];
+++	if (*file == NULL) {
+++		return EBADF;
+++	}
+++
+++	return 0;
+++}
+++
+++/*
+++ * filetable_dup2file
+++ * verifies that both file descriptors are valid, and that the OLDFD is
+++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++ */
+++int
+++filetable_dup2file(int oldfd, int newfd)
+++{
+++	struct filetable *ft = curthread->t_filetable;
+++	struct openfile *file;
+++	int result;
+++
+++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++		return EBADF;
+++	}
+++
+++	file = ft->ft_openfiles[oldfd];
+++	if (file == NULL) {
+++		return EBADF;
+++	}
+++
+++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++	if (oldfd == newfd) {
+++		return 0;
+++	}
+++
+++	/* closes the newfd if it's open */
+++	if (ft->ft_openfiles[newfd] != NULL) {
+++		result = file_close(newfd);
+++		if (result) {
+++			return result;
+++		}
+++	}
+++
+++	/* up the refcount */
+++	lock_acquire(file->of_lock);
+++	file->of_refcount++;
+++	lock_release(file->of_lock);
+++
+++	/* doesn't need to be synchronized because it's just changing the ft */
+++	ft->ft_openfiles[newfd] = file;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..8aa024c
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,270 @@
+++/*
+++ * File-related system call implementations.
+++ * New for SOL2.
+++ */
+++
+++#include <types.h>
+++#include <kern/errno.h>
+++#include <kern/limits.h>
+++#include <kern/stat.h>
+++#include <kern/unistd.h>
+++#include <kern/fcntl.h>
+++#include <kern/seek.h>
+++#include <lib.h>
+++#include <synch.h>
+++#include <uio.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <file.h>
+++#include <syscall.h>
+++#include <copyinout.h>
+++
+++/*
+++ * sys_open
+++ * just copies in the filename, then passes work to file_open.
+++ */
+++int
+++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++{
+++	char fname[PATH_MAX];
+++	int result;
+++
+++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return file_open(fname, flags, mode, retval);
+++}
+++
+++/*
+++ * sys_read
+++ * translates the fd into its openfile, then calls VOP_READ.
+++ */
+++int
+++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	/* better be a valid file descriptor */
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_WRONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++  
+++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++
+++	/* does the read */
+++	result = VOP_READ(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++	
+++	/*
+++	 * The amount read is the size of the buffer originally, minus
+++	 * how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/*
+++ * sys_write
+++ * translates the fd into its openfile, then calls VOP_WRITE.
+++ */
+++int
+++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++
+++	if (file->of_accmode == O_RDONLY) {
+++		lock_release(file->of_lock);
+++		return EBADF;
+++	}
+++
+++	/* set up a uio with the buffer, its size, and the current offset */
+++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++	
+++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++
+++	/* does the write */
+++	result = VOP_WRITE(file->of_vnode, &useruio);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++
+++	/* set the offset to the updated offset in the uio */
+++	file->of_offset = useruio.uio_offset;
+++
+++	lock_release(file->of_lock);
+++
+++	/*
+++	 * the amount written is the size of the buffer originally,
+++	 * minus how much is left in it.
+++	 */
+++	*retval = size - useruio.uio_resid;
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_close
+++ * just pass off the work to file_close.
+++ */
+++int
+++sys_close(int fd)
+++{
+++	return file_close(fd);
+++}
+++
+++/*
+++ * sys_lseek
+++ * translates the fd into its openfile, then based on the type of seek,
+++ * figure out the new offset, try the seek, if that succeeds, update the
+++ * openfile.
+++ */
+++int
+++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++{
+++	struct stat info;
+++	struct openfile *file;
+++	int result;
+++
+++	result = filetable_findfile(fd, &file);
+++	if (result) {
+++		return result;
+++	}
+++
+++	lock_acquire(file->of_lock);
+++	
+++	/* based on the type of seek, set the retval */ 
+++	switch (whence) {
+++	    case SEEK_SET:
+++		*retval = offset;
+++		break;
+++	    case SEEK_CUR:
+++		*retval = file->of_offset + offset;
+++		break;
+++	    case SEEK_END:
+++		result = VOP_STAT(file->of_vnode, &info);
+++		if (result) {
+++			lock_release(file->of_lock);
+++			return result;
+++		}
+++		*retval = info.st_size + offset;
+++		break;
+++	    default:
+++		lock_release(file->of_lock);
+++		return EINVAL;
+++	}
+++
+++	/* try the seek -- if it fails, return */
+++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++	if (result) {
+++		lock_release(file->of_lock);
+++		return result;
+++	}
+++	
+++	/* success -- update the file structure */
+++	file->of_offset = *retval;
+++
+++	lock_release(file->of_lock);
+++
+++	return 0;
+++}
+++
+++/* 
+++ * sys_dup2
+++ * just pass the work off to the filetable
+++ */
+++int
+++sys_dup2(int oldfd, int newfd, int *retval)
+++{
+++	int result;
+++
+++	result = filetable_dup2file(oldfd, newfd);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = newfd;
+++	return 0;
+++}
+++
+++/* really not "file" calls, per se, but might as well put it here */
+++
+++/*
+++ * sys_chdir
+++ * copyin the path and pass it off to vfs.
+++ */
+++int
+++sys_chdir(userptr_t path)
+++{
+++	char pathbuf[PATH_MAX];
+++	int result;
+++	
+++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++	if (result) {
+++		return result;
+++	}
+++
+++	return vfs_chdir(pathbuf);
+++}
+++
+++/*
+++ * sys___getcwd
+++ * just use vfs_getcwd.
+++ */
+++int
+++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++{
+++  struct iovec iov;
+++	struct uio useruio;
+++	int result;
+++  
+++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++
+++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++
+++	result = vfs_getcwd(&useruio);
+++	if (result) {
+++		return result;
+++	}
+++
+++	*retval = buflen - useruio.uio_resid;
+++
+++	return 0;
+++}
++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
++new file mode 100644
++index 0000000..dfd7b53
++--- /dev/null
+++++ b/kern/syscall/proc_sys.c
++@@ -0,0 +1,445 @@
+++/*
+++
+++ * proc_sys.c
+++ *
+++ *  Created on: Mar 7, 2014
+++ *      Author: trinity
+++ */
+++
+++#include <types.h>
+++#include<mips/trapframe.h>
+++#include <kern/errno.h>
+++#include <kern/fcntl.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <addrspace.h>
+++#include <vm.h>
+++#include <vfs.h>
+++#include <syscall.h>
+++#include <test.h>
+++#include <file.h>
+++#include <synch.h>
+++#include<copyinout.h>
+++#include <spl.h>
+++#include<kern/wait.h>
+++
+++extern struct process* p_table[17];
+++
+++//struct cv* wcv;
+++
+++extern pid_t pidcount;
+++int mywait(struct process* mypro) {
+++	//lock_acquire(mypro->tlock);
+++	while (!mypro->exited) {
+++		cv_wait(mypro->wcv, mypro->tlock);
+++	}
+++	//*status=mypro->exitcode;
+++	//lock_release(mypro->tlock);
+++	//int test = mypro->exitcode;
+++	//test++;
+++	return 0;
+++}
+++
+++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
+++	(void) adrs;
+++	int flag;
+++	pid_t childid;
+++	struct addrspace *adrcopy;
+++	struct trapframe* copyt = (struct trapframe*) kmalloc(
+++			sizeof(struct trapframe));
+++	bzero(copyt, sizeof(struct trapframe));
+++
+++	//struct filetable* copyft;
+++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
+++
+++	memcpy(copyt, tf, sizeof(struct trapframe));
+++	flag = as_copy(curthread->t_addrspace, &adrcopy);
+++	//if(curthread->pid==0)
+++	//{
+++	//curthread->pid=PID_MIN;
+++	//}
+++	if (flag) {
+++		kfree(copyt);
+++		return flag;
+++	}
+++
+++	//we need to allocate pid for our new process
+++
+++	//pid_t cpid;
+++	for (childid = 0; childid <= 16; childid++) {
+++		if (p_table[childid] == NULL ) {
+++			p_table[childid] = (struct process*) kmalloc(
+++					sizeof(struct process));
+++			p_table[childid]->full = 1;
+++			pidcount++;
+++			p_table[childid]->pid = pidcount;
+++			p_table[childid]->ppid = curthread->pid;
+++			//p_table[childid]->exitsem=sem_create("process",0);
+++			p_table[childid]->tlock = lock_create("My Lock");
+++			p_table[childid]->wcv = cv_create("My CV");
+++			p_table[childid]->self = NULL;
+++			break;
+++		}
+++	}
+++	if (childid > PID_MAX) {
+++		*retval = 1;
+++		return EMPROC;
+++	}
+++	//int i;
+++
+++	copyt->tf_a0 = (int) p_table[childid]->pid;
+++	//kprintf("Ret:%d\n",copyt->tf_a0);
+++	struct thread *new_proc;
+++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
+++	//int s=splhigh();
+++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
+++			(unsigned long) adrcopy, &new_proc);
+++	//kprintf("Out of thread fork:%d\n",flag);
+++	if (flag) {
+++		kfree(copyt);
+++		as_destroy(adrcopy);
+++
+++		return flag;
+++	}
+++
+++	//new_proc->pid=(pid_t)childid;
+++	//new_proc=p_table[childid];
+++
+++	new_proc->pid = p_table[childid]->pid;
+++	new_proc->proc = p_table[childid];
+++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
+++	//if (new_proc->t_filetable == NULL) {
+++	//return ENOMEM;
+++	//}
+++	p_table[childid]->self = new_proc;
+++
+++	//new_proc->pid=p_table[childid]->pid;
+++	//new_proc->proc->pid=p_table[childid]->pid;
+++	//kprintf("Child id in fork: %d\n",new_proc->pid);
+++
+++	//kprintf("Child id:%d",new_proc->pid);
+++	//new_proc->t_filetable->
+++	//for(i=0;i<128;i++)
+++	//{
+++	flag = filetable_copy(&new_proc->t_filetable);
+++	//}
+++	//splx(s);
+++	// kprintf("Fork over!");
+++
+++	*retval = p_table[childid]->pid;
+++	//kprintf("Return val in fork:%d",*retval);
+++	return 0;
+++
+++	//flag=
+++	//flag=thread_fork=
+++}
+++
+++int sys_execv(char *progname, char** arguments) {
+++
+++	int flag;
+++	int numargs;
+++	int addr;
+++	int i;
+++	// first we need to copy the program name to the kernel space
+++	// then we go for arguments. Path size unknown
+++
+++	size_t actual_size = 0;
+++	char *namedes;
+++
+++	if (progname == NULL ) {
+++		return EFAULT;
+++	}
+++	if (progname == "") {
+++		return EINVAL;
+++	}
+++
+++	namedes = (char*) kmalloc(PATH_MAX);
+++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
+++			&actual_size);
+++	if (flag != 0) {
+++		kfree(namedes);
+++		return flag;
+++	}
+++	//namedes[actual_size]
+++	if (strlen(namedes) == 0) {
+++		//*retval=1;
+++		return EISDIR;
+++	}
+++
+++	// now we open file using vfs_open. Same as runprogram
+++	struct vnode* vn;
+++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
+++	if (flag) {
+++		return flag;
+++	}
+++	actual_size = 0;
+++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
+++
+++	//char** kargv=(char**)kmalloc(sizeof(char));
+++	// get the number of arguments
+++	if (arguments == NULL ) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
+++	if (flag) {
+++		kfree(namedes);
+++		return EFAULT;
+++	}
+++
+++	//check=wthread->exitcode;
+++	//err=copyout(&check,(userptr_t)status,sizeof(check));
+++	//if(err)
+++	//{
+++	//	lock_release(p_table[i]->tlock);
+++	//return err;
+++	//}
+++
+++	numargs = 0;
+++	while (arguments[numargs] != NULL ) {
+++		//kprintf("%");
+++		numargs = numargs + 1;
+++	}
+++
+++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
+++	//int i;
+++	for (i = 0; i < numargs; i++) {
+++		actual_size = 0;
+++		kargv[i] = (char*) kmalloc(PATH_MAX);
+++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
+++				&actual_size);
+++		if (flag) {
+++			kfree(kargv);
+++			kfree(namedes);
+++			return EFAULT;
+++		}
+++
+++	}
+++	actual_size = 0;
+++
+++	curthread->t_addrspace = as_create();
+++	if (curthread->t_addrspace == NULL ) {
+++		vfs_close(vn);
+++		return ENOMEM;
+++	}
+++
+++	vaddr_t entrypoint, stackptr;
+++	as_activate(curthread->t_addrspace);
+++	flag = load_elf(vn, &entrypoint);
+++	if (flag) {
+++		// thread_exit destroys curthread->t_addrspace
+++		vfs_close(vn);
+++		return flag;
+++	}
+++
+++	vfs_close(vn);
+++
+++	// now set up the user stack with the arguments
+++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
+++	if (flag) {
+++		//thread_exit destroys curthread->t_addrspace
+++		return flag;
+++	}
+++
+++	//i=0;
+++	vaddr_t stackptrv[numargs + 1];
+++	for (i = numargs - 1; i >= 0; i--) {
+++		int len = strlen(kargv[i]);
+++		int padder=0;
+++		len++;// to account for string terminator
+++		if(len%4!=0)
+++		padder = len % 4;
+++		stackptr =stackptr-(len + padder);
+++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
+++				&actual_size);
+++
+++		if (flag)
+++		{
+++			kfree(kargv);
+++			kfree(namedes);
+++			return flag;
+++		}
+++
+++		stackptrv[i] = stackptr;
+++	}
+++	stackptrv[numargs] = 0;
+++
+++	//This copies the actual stack addresses of the arguments
+++	//* into the stack. Hopefully.
+++
+++	 for(i = numargs; i >= 0; i--)
+++	 {
+++	 stackptr -= sizeof(vaddr_t);
+++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++
+++	 if(flag)
+++	 {
+++	 kfree(kargv);
+++	 kfree(namedes);
+++	 return flag;
+++	 }
+++
+++	 }
+++
+++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
+++	//pt_getthread();
+++
+++	//enter_new_process does not return.
+++	panic("enter_new_process returned\n");
+++	return EINVAL;
+++
+++}
+++
+++int sys_getpid(pid_t *retval) {
+++	//kprintf("In get pid:%d\n",curthread->pid);
+++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
+++
+++	*retval = curthread->proc->pid;
+++	return 0;
+++}
+++
+++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
+++	struct process* wthread = NULL;
+++	int check;
+++	int err;
+++	pid_t i;
+++	//kprintf("PID in wait pid:%d\n",pid);
+++	if (status == NULL )
+++		return EFAULT;
+++	if (options != 0)
+++		return EINVAL;
+++	if (pid == curthread->pid)
+++		return ECHILD;
+++	if (pid < PID_MIN || pid > PID_MAX)
+++		return ESRCH;
+++	if (status == NULL )
+++		return EFAULT;
+++	if (pid == curthread->proc->ppid)
+++		return ECHILD;
+++	//int *shit;
+++	//*shit=(int)&status;
+++	//kprintf("%d\n",*shit);
+++	//if(curthread->)
+++	//if(pid!=curthread->)
+++	//char* argv=(char*)(status);
+++	//int length=strlen(argv)+1;
+++	//int length=strlen(kargv[i])+1;
+++	//int padder=length%4;
+++	//kprintf("Hai:%d\n",padder);
+++	//if(padder!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++
+++	//if()
+++
+++	//char pathbuf[PATH_MAX];
+++	//int *buffer;
+++	//int result;
+++
+++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
+++	//if (result) {
+++	//return result;
+++	//}
+++	//int addr=(int)&status;
+++	//kprintf("Status:%d\n",addr);
+++	//int *addr=&status;
+++	//if(addr%4!=0)
+++	//{
+++	//return EFAULT;
+++	//}
+++	//kprintf("Got Here\n");
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				wthread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++	if (wthread == NULL ) {
+++		return ESRCH;
+++	}
+++	if (curthread->proc->pid != wthread->ppid)
+++		return ECHILD;
+++	//panic("We are here");
+++
+++	lock_acquire(p_table[i]->tlock);
+++
+++	//while(!wthread->exited)
+++	//{
+++//
+++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
+++	//}
+++	mywait(wthread);
+++
+++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
+++	//kprintf("We are here!");
+++
+++	check = wthread->exitcode;
+++	err = copyout(&check, (userptr_t) status, sizeof(check));
+++	if (err) {
+++		lock_release(p_table[i]->tlock);
+++		return err;
+++	}
+++	//kprintf("Exit code After waiting:%d\n",*status);
+++	//kfree(p_table[i]->exitsem);
+++	//p_table[i]=NULL;
+++
+++	//panic("After kfree");
+++	//p_table[i]=NULL;
+++	lock_release(p_table[i]->tlock);
+++	//filetable_destroy(p_table[i]->self->t_filetable);
+++	//lock_destroy(p_table[i]->tlock);
+++	//cv_destroy(p_table[i]->wcv);
+++	//kfree(p_table[i]);
+++	p_table[i] = NULL;
+++
+++	*retval = pid;
+++	//panic("After dereferencing");
+++	return 0;
+++
+++	//return -1;
+++	//return 0;
+++}
+++
+++void sys_exit(int exitcode) {
+++	pid_t pid = curthread->proc->pid;
+++	pid_t i = PID_MIN;
+++	struct process* ethread;
+++//pid_t parent;
+++//if(pid!=2)
+++//{
+++	for (i = 0; i <= 16; i++) {
+++		if (p_table[i] != NULL ) {
+++			if (p_table[i]->pid == pid) {
+++				ethread = p_table[i];
+++				break;
+++			}
+++		}
+++	}
+++
+++//parent=ethread->ppid;
+++	if (ethread != NULL ) {
+++		lock_acquire(ethread->tlock);
+++//kprintf("Exit code Before:%d\n",exitcode);
+++
+++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
+++//kprintf("Exitcode After:%d\n",ethread->exitcode);
+++		ethread->exited = 1;
+++//p_table[i]=ethread;
+++		cv_broadcast(ethread->wcv, ethread->tlock);
+++//kfree(curthread->t_filetable);
+++		lock_release(ethread->tlock);
+++	}
+++//}
+++	i = 0;
+++//
+++//kprintf("Before hanging");
+++//filetable_destroy(curthread->t_filetable);
+++//kfree(curthread->p);
+++
+++	thread_exit();
+++}
+++
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..1ada408 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,6 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
+++#include <file.h>
+++#include<copyinout.h>
++ 
++ /*
++  * Load program "progname" and start running it in usermode.
++@@ -52,7 +54,7 @@
++  * Calls vfs_open on progname and thus may destroy it.
++  */
++ int
++-runprogram(char *progname)
+++runprogram(char *progname,char**argv,unsigned long argc)
++ {
++ 	struct vnode *v;
++ 	vaddr_t entrypoint, stackptr;
++@@ -66,6 +68,13 @@ runprogram(char *progname)
++ 
++ 	/* We should be a new thread. */
++ 	KASSERT(curthread->t_addrspace == NULL);
+++	curthread->t_filetable=NULL;
+++  if (curthread->t_filetable == NULL) {
+++		result = filetable_init("con:", "con:", "con:");
+++		if (result) {
+++			return result;
+++		}
+++	}
++ 
++ 	/* Create a new address space. */
++ 	curthread->t_addrspace = as_create();
++@@ -94,9 +103,40 @@ runprogram(char *progname)
++ 		/* thread_exit destroys curthread->t_addrspace */
++ 		return result;
++ 	}
+++	vaddr_t stackptrv[argc+1];
+++int i;
+++size_t actual;
+++for(i = argc-1; i >= 0; i--)
+++{
+++int len = strlen(argv[i]);
+++int padder=0;
+++len++;
+++if(len%4!=0)
+++padder = len % 4;
+++stackptr=stackptr-(len + padder);
+++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
+++if(result)
+++{
+++return result;
+++}
+++stackptrv[i] = stackptr;
+++}
+++stackptrv[argc] = 0;
+++for(i = argc; i >= 0; i--)
+++{
+++stackptr -= sizeof(vaddr_t);
+++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
+++if(result)
+++{
+++return result;
+++}
+++}
+++
+++
+++
++ 
++ 	/* Warp to user mode. */
++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+++	enter_new_process(argc, (userptr_t)stackptr,
++ 			  stackptr, entrypoint);
++ 	
++ 	/* enter_new_process does not return. */
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..851f9ea 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -40,6 +40,8 @@
++ #include <current.h>
++ #include <synch.h>
++ 
+++#define MAXREADERS 20;
+++
++ ////////////////////////////////////////////////////////////
++ //
++ // Semaphore.
++@@ -162,9 +164,17 @@ lock_create(const char *name)
++                 kfree(lock);
++                 return NULL;
++         }
++-        
++-        // add stuff here as needed
++-        
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
++         return lock;
++ }
++ 
++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
++ 
++         // add stuff here as needed
++         
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
++         kfree(lock->lk_name);
++         kfree(lock);
++ }
++@@ -183,26 +195,78 @@ void
++ lock_acquire(struct lock *lock)
++ {
++         // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(&lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
++ 
++-        (void)lock;  // suppress warning until code gets written
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -225,7 +289,18 @@ cv_create(const char *name)
++                 kfree(cv);
++                 return NULL;
++         }
++-        
+++        cv->cv_wchan = wchan_create(cv->cv_name);
+++                	if (cv->cv_wchan == NULL) {
+++                		kfree(cv->cv_name);
+++                		kfree(cv);
+++                		return NULL;
+++                	}
+++
+++                	//spinlock_init(&cv->cv_lock);
+++                        //lock->hold = 0;
+++        		//lock->holder=NULL;
+++                //lock->=NULL
+++                return cv;
++         // add stuff here as needed
++         
++         return cv;
++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
++ 
++         // add stuff here as needed
++         
+++        //spinlock_cleanup(&cv->cv_lock);
+++        
+++        wchan_destroy(cv->cv_wchan);
++         kfree(cv->cv_name);
++         kfree(cv);
++ }
++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	//KASSERT(lock_do_i_hold(lock));
+++	wchan_lock(cv->cv_wchan);
+++	lock_release(lock);
+++	
+++	wchan_sleep(cv->cv_wchan);
+++	lock_acquire(lock);
+++	
+++    // Write this
+++    //(void)cv;    // suppress warning until code gets written
+++    //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++         // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeone(cv->cv_wchan);
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv!=NULL);
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock_do_i_hold(lock));
+++	wchan_wakeall(cv->cv_wchan);
+++		
+++	
+++	//(void)cv;    // suppress warning until code gets written
+++	//(void)lock;  // suppress warning until code gets written
+++}
+++
+++struct rwlock *rwlock_create(const char *name)
+++{
+++	struct rwlock *rw;
+++	rw=kmalloc(sizeof(struct rwlock));
+++	if(rw==NULL)
+++	{
+++		return NULL;
+++	}
+++	rw->rwlock_name=kstrdup(name);
+++	if(rw->rwlock_name==NULL)
+++	{
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->rd_wchan=wchan_create(rw->rwlock_name);
+++	if(rw->rd_wchan==NULL)
+++	{
+++		kfree(rw->rwlock_name);
+++		kfree(rw);
+++		return NULL;
+++	}
+++	rw->wr_wchan=wchan_create(rw->rwlock_name);
+++		if(rw->wr_wchan==NULL)
+++		{
+++			kfree(rw->rwlock_name);
+++			kfree(rw);
+++			return NULL;
+++		}
+++		rw->rw_sem=sem_create("mysem",20);
+++		rw->rw_lock=lock_create("mylock");
+++	///rw->res_count=MAXREADERS;
+++	return rw;
+++	
+++}
+++void rwlock_destroy(struct rwlock *rw)
+++{
+++		KASSERT(rw != NULL);
+++		
+++		wchan_destroy(rw->rd_wchan);
+++		wchan_destroy(rw->wr_wchan);
+++		sem_destroy(rw->rw_sem);
+++		lock_destroy(rw->rw_lock);
+++	    kfree(rw->rwlock_name);
+++        kfree(rw);	
+++}
+++
+++void rwlock_acquire_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	P(rw->rw_sem);
+++	lock_release(rw->rw_lock);
+++}
+++void rwlock_release_read(struct rwlock *rw)
+++{
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	V(rw->rw_sem);
+++	//lock_release(rw->rw_lock);
+++}
+++void rwlock_acquire_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	lock_acquire(rw->rw_lock);
+++	//rwlock->rw_sem->V();
+++	for(i=0;i<20;i++)
+++	{
+++	P(rw->rw_sem);
+++	}	
+++	lock_release(rw->rw_lock);
+++	
+++	
++ }
+++void rwlock_release_write(struct rwlock *rw)
+++{
+++	int i;
+++	KASSERT(rw!=NULL);
+++	//lock_acquire(rw->rw_lock);
+++	for(i=0;i<20;i++)
+++	{
+++	V(rw->rw_sem);
+++	}	
+++	//lock_release(rw->rw_lock);
+++	
+++}
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
++new file mode 100644
++index 0000000..b9680d1
++--- /dev/null
+++++ b/kern/thread/synch.c~
++@@ -0,0 +1,329 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++/*
+++ * Synchronization primitives.
+++ * The specifications of the functions are in synch.h.
+++ */
+++
+++#include <types.h>
+++#include <lib.h>
+++#include <spinlock.h>
+++#include <wchan.h>
+++#include <thread.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Semaphore.
+++
+++struct semaphore *
+++sem_create(const char *name, int initial_count)
+++{
+++        struct semaphore *sem;
+++
+++        KASSERT(initial_count >= 0);
+++
+++        sem = kmalloc(sizeof(struct semaphore));
+++        if (sem == NULL) {
+++                return NULL;
+++        }
+++
+++        sem->sem_name = kstrdup(name);
+++        if (sem->sem_name == NULL) {
+++                kfree(sem);
+++                return NULL;
+++        }
+++
+++	sem->sem_wchan = wchan_create(sem->sem_name);
+++	if (sem->sem_wchan == NULL) {
+++		kfree(sem->sem_name);
+++		kfree(sem);
+++		return NULL;
+++	}
+++
+++	spinlock_init(&sem->sem_lock);
+++        sem->sem_count = initial_count;
+++
+++        return sem;
+++}
+++
+++void
+++sem_destroy(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	/* wchan_cleanup will assert if anyone's waiting on it */
+++	spinlock_cleanup(&sem->sem_lock);
+++	wchan_destroy(sem->sem_wchan);
+++        kfree(sem->sem_name);
+++        kfree(sem);
+++}
+++
+++void 
+++P(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++        /*
+++         * May not block in an interrupt handler.
+++         *
+++         * For robustness, always check, even if we can actually
+++         * complete the P without blocking.
+++         */
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++        while (sem->sem_count == 0) {
+++		/*
+++		 * Bridge to the wchan lock, so if someone else comes
+++		 * along in V right this instant the wakeup can't go
+++		 * through on the wchan until we've finished going to
+++		 * sleep. Note that wchan_sleep unlocks the wchan.
+++		 *
+++		 * Note that we don't maintain strict FIFO ordering of
+++		 * threads going through the semaphore; that is, we
+++		 * might "get" it on the first try even if other
+++		 * threads are waiting. Apparently according to some
+++		 * textbooks semaphores must for some reason have
+++		 * strict ordering. Too bad. :-)
+++		 *
+++		 * Exercise: how would you implement strict FIFO
+++		 * ordering?
+++		 */
+++		wchan_lock(sem->sem_wchan);
+++		spinlock_release(&sem->sem_lock);
+++                wchan_sleep(sem->sem_wchan);
+++
+++		spinlock_acquire(&sem->sem_lock);
+++        }
+++        KASSERT(sem->sem_count > 0);
+++        sem->sem_count--;
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++void
+++V(struct semaphore *sem)
+++{
+++        KASSERT(sem != NULL);
+++
+++	spinlock_acquire(&sem->sem_lock);
+++
+++        sem->sem_count++;
+++        KASSERT(sem->sem_count > 0);
+++	wchan_wakeone(sem->sem_wchan);
+++
+++	spinlock_release(&sem->sem_lock);
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// Lock.
+++
+++struct lock *
+++lock_create(const char *name)
+++{
+++        struct lock *lock;
+++
+++        lock = kmalloc(sizeof(struct lock));
+++        if (lock == NULL) {
+++                return NULL;
+++        }
+++
+++        lock->lk_name = kstrdup(name);
+++        if (lock->lk_name == NULL) {
+++                kfree(lock);
+++                return NULL;
+++        }
+++        lock->mut_wchan = wchan_create(lock->lk_name);
+++        	if (lock->mut_wchan == NULL) {
+++        		kfree(lock->lk_name);
+++        		kfree(lock);
+++        		return NULL;
+++        	}
+++
+++        	spinlock_init(&lock->mut_lock);
+++                lock->hold = 0;
+++		lock->holder=NULL;
+++        //lock->=NULL
+++        return lock;
+++}
+++
+++void
+++lock_destroy(struct lock *lock)
+++{
+++        KASSERT(lock != NULL);
+++
+++        // add stuff here as needed
+++        
+++        spinlock_cleanup(&lock->mut_lock);
+++        	wchan_destroy(lock->mut_wchan);
+++        kfree(lock->lk_name);
+++        kfree(lock);
+++}
+++
+++void
+++lock_acquire(struct lock *lock)
+++{
+++        // Write this
+++KASSERT(lock!=NULL);
+++
+++
+++//KASSERT(sem != NULL);
+++
+++        
+++        KASSERT(curthread->t_in_interrupt == false);
+++
+++	spinlock_acquire(&lock->mut_lock);
+++        while (lock->hold ) {
+++		
+++		wchan_lock(lock->mut_wchan);
+++		spinlock_release(&lock->mut_lock);
+++                wchan_sleep(lock->mut_wchan);
+++
+++		spinlock_acquire(lock->mut_lock);
+++        }
+++        KASSERT(lock->hold ==0 );
+++        lock->hold=1;
+++	lock->holder=curthread;
+++        //sem->sem_count--;
+++	spinlock_release(&lock->mut_lock);
+++
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++lock_release(struct lock *lock)
+++{
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->hold);
+++	KASSERT(lock_do_i_hold(lock));
+++	spinlock_acquire(&lock->mut_lock);
+++	lock->hold=0;
+++	
+++	        //sem->sem_count++;
+++	        KASSERT(lock->hold == 0);
+++lock->holder=NULL;
+++		wchan_wakeone(lock->mut_wchan);
+++
+++		spinlock_release(&lock->mut_lock);
+++        // Write this
+++	/*
+++	
+++	KASSERT(lock!=NULL);
+++	KASSERT(lock->lockNeed==curthread);
+++	spinlock_acquire(&lock->lockNeed);
+++	lock->lockNeed==NULL;
+++	
+++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
+++	spinlock_release(&lock->lockNeed);
+++*/
+++        //(void)lock;  // suppress warning until code gets written
+++}
+++
+++bool
+++lock_do_i_hold(struct lock *lock)
+++{
+++        // Write this
+++	
+++
+++        //(void)lock;  // suppress warning until code gets written
+++	KASSERT(lock!=NULL);
+++	//spinlock_acquire(&lock->mut_lock);
+++	if(!lock->hold) return false;
+++if(lock->holder==curthread) return true;
+++else 
+++return false;
+++	
+++    //spinlock_release(&lock->mut_lock);
+++    
+++        //return res; // dummy until code gets written
+++}
+++
+++////////////////////////////////////////////////////////////
+++//
+++// CV
+++
+++
+++struct cv *
+++cv_create(const char *name)
+++{
+++        struct cv *cv;
+++
+++        cv = kmalloc(sizeof(struct cv));
+++        if (cv == NULL) {
+++                return NULL;
+++        }
+++
+++        cv->cv_name = kstrdup(name);
+++        if (cv->cv_name==NULL) {
+++                kfree(cv);
+++                return NULL;
+++        }
+++        
+++        // add stuff here as needed
+++        
+++        return cv;
+++}
+++
+++void
+++cv_destroy(struct cv *cv)
+++{
+++        KASSERT(cv != NULL);
+++
+++        // add stuff here as needed
+++        
+++        kfree(cv->cv_name);
+++        kfree(cv);
+++}
+++
+++void
+++cv_wait(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++        (void)cv;    // suppress warning until code gets written
+++        (void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_signal(struct cv *cv, struct lock *lock)
+++{
+++        // Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
+++
+++void
+++cv_broadcast(struct cv *cv, struct lock *lock)
+++{
+++	// Write this
+++	(void)cv;    // suppress warning until code gets written
+++	(void)lock;  // suppress warning until code gets written
+++}
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..df129b9 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <file.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
++ 
++ /* Used to wait for secondary CPUs to come online. */
++ static struct semaphore *cpu_startup_sem;
+++pid_t pidcount;
+++struct process* p_table[17];
++ 
++ ////////////////////////////////////////////////////////////
++ 
++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
++ 
++ /*
++  * Check the magic number we put on the bottom end of the stack in
++- * thread_checkstack_init. If these assertions go off, it most likely
+++ * thread_checkstack_init. If these KASSERTions go off, it most likely
++  * means you overflowed your stack at some point, which can cause all
++  * kinds of mysterious other things to happen.
++  *
++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
++ 	/* sheer paranoia */
++ 	thread->t_wchan_name = "DESTROYED";
++ 
+++  KASSERT(thread->t_filetable == NULL);
+++
++ 	kfree(thread->t_name);
++ 	kfree(thread);
++ }
++@@ -352,8 +357,15 @@ thread_bootstrap(void)
++ {
++ 	struct cpu *bootcpu;
++ 	struct thread *bootthread;
+++	int i;
++ 
++ 	cpuarray_init(&allcpus);
+++	pidcount=PID_MIN;
+++
+++	for(i=0;i<=16;i++)
+++	{
+++		p_table[i]=NULL;
+++	}
++ 
++ 	/*
++ 	 * Create the cpu structure for the bootup CPU, the one we're
++@@ -365,6 +377,7 @@ thread_bootstrap(void)
++ 	 */
++ 	bootcpu = cpu_create(0);
++ 	bootthread = bootcpu->c_curthread;
+++	//bootthread->pid=PID_MIN;
++ 
++ 	/*
++ 	 * Initializing curcpu and curthread is machine-dependent
++@@ -519,7 +532,7 @@ thread_fork(const char *name,
++ 	 * for the spllower() that will be done releasing it.
++ 	 */
++ 	newthread->t_iplhigh_count++;
++-
+++	//newthread->pid=pidcount++;
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	switch (newstate) {
++ 	    case S_RUN:
++ 		panic("Illegal S_RUN in thread_switch\n");
++-		break;
++ 	    case S_READY:
++ 		thread_make_runnable(cur, true /*have lock*/);
++ 		break;
++@@ -799,6 +811,11 @@ thread_exit(void)
++ 		VOP_DECREF(cur->t_cwd);
++ 		cur->t_cwd = NULL;
++ 	}
+++	
+++	if (curthread->t_filetable) {
+++		filetable_destroy(curthread->t_filetable);
+++		curthread->t_filetable = NULL;
+++	}
++ 
++ 	/* VM fields */
++ 	if (cur->t_addrspace) {
++diff --git a/single10.patch b/single10.patch
++new file mode 100644
++index 0000000..2267436
++--- /dev/null
+++++ b/single10.patch
++@@ -0,0 +1,915 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..68c73ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,6 +32,7 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++		break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++		break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++		break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++		break;
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..e1d7682 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,8 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..f3a01ad 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++ 
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..08b8f8c 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -112,6 +112,7 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..4ba181a 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,7 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -66,6 +67,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index 5b8099e..60108d3 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -89,7 +90,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +263,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -798,6 +801,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..e07fb23
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,4058 @@
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..33b99ff 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -32,11 +32,14 @@
+++ #include <kern/syscall.h>
+++ #include <lib.h>
+++ #include <mips/trapframe.h>
++++#include <addrspace.h>
++++#include <copyinout.h>
+++ #include <thread.h>
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
+++ 
++++
+++ /*
+++  * System call dispatcher.
+++  *
+++@@ -80,7 +83,10 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++        int32_t retvalv1 = 0;
++++        int64_t retval64;
+++ 	int err;
++++        int32_t stackarg1;
+++ 
+++ 	KASSERT(curthread != NULL);
+++ 	KASSERT(curthread->t_curspl == 0);
+++@@ -108,6 +114,59 @@ syscall(struct trapframe *tf)
+++ 		err = sys___time((userptr_t)tf->tf_a0,
+++ 				 (userptr_t)tf->tf_a1);
+++ 		break;
++++            case SYS_open:
++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_read:
++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++			       &retval);
++++		break;
++++	    case SYS_write:
++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
++++				&retval);
++++		break;
++++	    case SYS_close:
++++		err = sys_close(tf->tf_a0);
++++		break;
++++	    case SYS_lseek:
++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
++++                                stackarg1, &retval64);
++++                retval = retval64 >> 32;
++++                retvalv1 = (int) retval64;
++++                break;
++++	    case SYS_dup2:
++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_chdir:
++++		err = sys_chdir((userptr_t)tf->tf_a0);
++++			break;
++++	    case SYS___getcwd:
++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++++			break;
++++	    case SYS_fork:
++++	    	err=0;
++++	    	err=sys_fork(tf,(unsigned long)curthread->t_addrspace,&retval);
++++	    	break;
++++	    case SYS_execv:
++++	    	err=0;
++++	    	err=sys_execv((char*)tf->tf_a0,(char**)tf->tf_a1);
++++	    	break;
++++	    case SYS_getpid:
++++	    	err=0;
++++	    	err=sys_getpid(&retval);
++++	    	break;
++++	    case SYS_waitpid:
++++	    	err=0;
++++	    	//kprintf("Dispatch:%d",tf->tf_a0);
++++	    	err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++	    	//panic("Waitpid over");
++++	    	break;
++++	    case SYS__exit:
++++	    	sys_exit((int)tf->tf_a0);
++++	    	break;
++++
+++ 
+++ 	    /* Add stuff here */
+++  
+++@@ -130,6 +189,7 @@ syscall(struct trapframe *tf)
+++ 	else {
+++ 		/* Success. */
+++ 		tf->tf_v0 = retval;
++++                tf->tf_v1 = retvalv1;
+++ 		tf->tf_a3 = 0;      /* signal no error */
+++ 	}
+++ 	
+++@@ -154,8 +214,37 @@ syscall(struct trapframe *tf)
+++  *
+++  * Thus, you can trash it and do things another way if you prefer.
+++  */
+++-void
+++-enter_forked_process(struct trapframe *tf)
++++//void
++++//enter_forked_process(struct trapframe *tf)
++++//{
++++	//(void)tf;
++++//}
++++
++++void enter_forked_process(void*tf,unsigned long adrspace)
+++ {
+++-	(void)tf;
++++	tf=(struct trapframe*)tf;
++++	struct trapframe newtf;
++++	int flag;
++++	flag=as_copy((struct addrspace*)adrspace,&curthread->t_addrspace);
++++	if(flag)
++++	{
++++		newtf.tf_v0=ENOMEM;
++++		newtf.tf_a3=1;
++++	}
++++
++++	memcpy(&newtf,(const void*)tf,sizeof(struct trapframe));
++++	kfree(tf);
++++	//tf=NULL;
++++	//int flag;
++++
++++	curthread->pid=newtf.tf_a0;
++++
++++	as_activate(curthread->t_addrspace);
++++
++++
++++
++++	newtf.tf_v0=0;
++++	newtf.tf_a3=0;
++++	newtf.tf_epc+=4;
++++	mips_usermode(&newtf);
+++ }
+++diff --git a/kern/arch/mips/syscall/syscall.c~ b/kern/arch/mips/syscall/syscall.c~
+++new file mode 100644
+++index 0000000..3e8d5b9
+++--- /dev/null
++++++ b/kern/arch/mips/syscall/syscall.c~
+++@@ -0,0 +1,165 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/syscall.h>
++++#include <lib.h>
++++#include <mips/trapframe.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <syscall.h>
++++
++++
++++/*
++++ * System call dispatcher.
++++ *
++++ * A pointer to the trapframe created during exception entry (in
++++ * exception.S) is passed in.
++++ *
++++ * The calling conventions for syscalls are as follows: Like ordinary
++++ * function calls, the first 4 32-bit arguments are passed in the 4
++++ * argument registers a0-a3. 64-bit arguments are passed in *aligned*
++++ * pairs of registers, that is, either a0/a1 or a2/a3. This means that
++++ * if the first argument is 32-bit and the second is 64-bit, a1 is
++++ * unused.
++++ *
++++ * This much is the same as the calling conventions for ordinary
++++ * function calls. In addition, the system call number is passed in
++++ * the v0 register.
++++ *
++++ * On successful return, the return value is passed back in the v0
++++ * register, or v0 and v1 if 64-bit. This is also like an ordinary
++++ * function call, and additionally the a3 register is also set to 0 to
++++ * indicate success.
++++ *
++++ * On an error return, the error code is passed back in the v0
++++ * register, and the a3 register is set to 1 to indicate failure.
++++ * (Userlevel code takes care of storing the error code in errno and
++++ * returning the value -1 from the actual userlevel syscall function.
++++ * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
++++ *
++++ * Upon syscall return the program counter stored in the trapframe
++++ * must be incremented by one instruction; otherwise the exception
++++ * return code will restart the "syscall" instruction and the system
++++ * call will repeat forever.
++++ *
++++ * If you run out of registers (which happens quickly with 64-bit
++++ * values) further arguments must be fetched from the user-level
++++ * stack, starting at sp+16 to skip over the slots for the
++++ * registerized values, with copyin().
++++ */
++++void
++++syscall(struct trapframe *tf)
++++{
++++	int callno;
++++	int32_t retval;
++++	int err;
++++
++++	KASSERT(curthread != NULL);
++++	KASSERT(curthread->t_curspl == 0);
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++
++++	callno = tf->tf_v0;
++++
++++	/*
++++	 * Initialize retval to 0. Many of the system calls don't
++++	 * really return a value, just 0 for success and -1 on
++++	 * error. Since retval is the value returned on success,
++++	 * initialize it to 0 by default; thus it's not necessary to
++++	 * deal with it except for calls that return other values, 
++++	 * like write.
++++	 */
++++
++++	retval = 0;
++++
++++	switch (callno) {
++++	    case SYS_reboot:
++++		err = sys_reboot(tf->tf_a0);
++++		break;
++++
++++	    case SYS___time:
++++		err = sys___time((userptr_t)tf->tf_a0,
++++				 (userptr_t)tf->tf_a1);
++++		break;
++++		
++++	    case SYS_open:
++++	    err=sys_open((char*)tf->tf_a0,tf->tf_a1,(mode_t )tf->tf_a2, &retval);	
++++	    break;
++++
++++	    /* Add stuff here */
++++ 
++++	    default:
++++		kprintf("Unknown syscall %d\n", callno);
++++		err = ENOSYS;
++++		break;
++++	}
++++
++++
++++	if (err) {
++++		/*
++++		 * Return the error code. This gets converted at
++++		 * userlevel to a return value of -1 and the error
++++		 * code in errno.
++++		 */
++++		tf->tf_v0 = err;
++++		tf->tf_a3 = 1;      /* signal an error */
++++	}
++++	else {
++++		/* Success. */
++++		tf->tf_v0 = retval;
++++		tf->tf_a3 = 0;      /* signal no error */
++++	}
++++	
++++	/*
++++	 * Now, advance the program counter, to avoid restarting
++++	 * the syscall over and over again.
++++	 */
++++	
++++	tf->tf_epc += 4;
++++
++++	/* Make sure the syscall code didn't forget to lower spl */
++++	KASSERT(curthread->t_curspl == 0);
++++	/* ...or leak any spinlocks */
++++	KASSERT(curthread->t_iplhigh_count == 0);
++++}
++++
++++/*
++++ * Enter user mode for a newly forked process.
++++ *
++++ * This function is provided as a reminder. You need to write
++++ * both it and the code that calls it.
++++ *
++++ * Thus, you can trash it and do things another way if you prefer.
++++ */
++++void
++++enter_forked_process(struct trapframe *tf)
++++{
++++	(void)tf;
++++}
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..7d5df71 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,9 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file      syscall/file_syscalls.c
++++file      syscall/file.c
++++file	  syscall/proc_sys.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/file.h b/kern/include/file.h
+++new file mode 100644
+++index 0000000..2c63bc2
+++--- /dev/null
++++++ b/kern/include/file.h
+++@@ -0,0 +1,59 @@
++++/*
++++ * Declarations for file handle and file table management.
++++ * New for SOL2.
++++ */
++++
++++#ifndef _FILE_H_
++++#define _FILE_H_
++++
++++#include <limits.h>
++++
++++struct lock;
++++struct vnode;
++++
++++/*** openfile section ***/
++++
++++/* 
++++ * openfile struct 
++++ * note that there's not too much to keep track of, since the vnode does most
++++ * of that.  note that it does require synchronization, because a single
++++ * openfile can be shared between processes (filetable inheritance).
++++ */
++++struct openfile {
++++	struct vnode *of_vnode;
++++	
++++	struct lock *of_lock;
++++	off_t of_offset;
++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
++++	int of_refcount;
++++};
++++
++++/* opens a file (must be kernel pointers in the args) */
++++int file_open(char *filename, int flags, int mode, int *retfd);
++++
++++/* closes a file */
++++int file_close(int fd);
++++
++++
++++/*** file table section ***/
++++
++++/*
++++ * filetable struct
++++ * just an array of open files.  nice and simple.  doesn't require
++++ * synchronization, because a table can only be owned by a single process (on
++++ * inheritance in fork, the table is copied).
++++ */
++++struct filetable {
++++	struct openfile *ft_openfiles[OPEN_MAX];
++++};
++++
++++/* these all have an implicit arg of the curthread's filetable */
++++int filetable_init(const char *inpath, const char *outpath, 
++++		   const char *errpath);
++++int filetable_copy(struct filetable **copy);
++++int filetable_placefile(struct openfile *file, int *fd);
++++int filetable_findfile(int fd, struct openfile **file);
++++int filetable_dup2file(int oldfd, int newfd);
++++void filetable_destroy(struct filetable *ft);
++++
++++#endif /* _FILE_H_ */
+++diff --git a/kern/include/limits.h b/kern/include/limits.h
+++index 01684c4..3a54e24 100644
+++--- a/kern/include/limits.h
++++++ b/kern/include/limits.h
+++@@ -48,5 +48,6 @@
+++ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+++ #define OPEN_MAX        __OPEN_MAX
+++ #define IOV_MAX         __IOV_MAX
++++//#define OPEN_MAX        64
+++ 
+++ #endif /* _LIMITS_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..df9fe64 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,11 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +118,10 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        //struct spinlock cv_lock;
++++        struct wchan *cv_wchan;
++++        //volatile int hold;
++++        //struct thread *holder;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -143,6 +152,11 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ 
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int res_count;
++++        struct wchan *rd_wchan;
++++        struct wchan *wr_wchan;
++++        struct semaphore *rw_sem;
++++        struct lock *rw_lock;
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/synch.h~ b/kern/include/synch.h~
+++new file mode 100644
+++index 0000000..d98aeb7
+++--- /dev/null
++++++ b/kern/include/synch.h~
+++@@ -0,0 +1,161 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _SYNCH_H_
++++#define _SYNCH_H_
++++
++++/*
++++ * Header file for synchronization primitives.
++++ */
++++
++++
++++#include <spinlock.h>
++++
++++/*
++++ * Dijkstra-style semaphore.
++++ *
++++ * The name field is for easier debugging. A copy of the name is made
++++ * internally.
++++ */
++++struct semaphore {
++++        char *sem_name;
++++	struct wchan *sem_wchan;
++++	struct spinlock sem_lock;
++++        volatile int sem_count;
++++};
++++
++++struct semaphore *sem_create(const char *name, int initial_count);
++++void sem_destroy(struct semaphore *);
++++
++++/*
++++ * Operations (both atomic):
++++ *     P (proberen): decrement count. If the count is 0, block until
++++ *                   the count is 1 again before decrementing.
++++ *     V (verhogen): increment count.
++++ */
++++void P(struct semaphore *);
++++void V(struct semaphore *);
++++
++++
++++/*
++++ * Simple lock for mutual exclusion.
++++ *
++++ * When the lock is created, no thread should be holding it. Likewise,
++++ * when the lock is destroyed, no thread should be holding it.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++struct lock {
++++        char *lk_name;
++++//volatile struct thread *lockNeed;
++++        struct spinlock mut_lock;
++++        struct wchan *mut_wchan;
++++        volatile int hold;
++++struct thread *holder;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct lock *lock_create(const char *name);
++++void lock_acquire(struct lock *);
++++
++++/*
++++ * Operations:
++++ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
++++ *                   same time.
++++ *    lock_release - Free the lock. Only the thread holding the lock may do
++++ *                   this.
++++ *    lock_do_i_hold - Return true if the current thread holds the lock; 
++++ *                   false otherwise.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void lock_release(struct lock *);
++++bool lock_do_i_hold(struct lock *);
++++void lock_destroy(struct lock *);
++++
++++
++++/*
++++ * Condition variable.
++++ *
++++ * Note that the "variable" is a bit of a misnomer: a CV is normally used
++++ * to wait until a variable meets a particular condition, but there's no
++++ * actual variable, as such, in the CV.
++++ *
++++ * These CVs are expected to support Mesa semantics, that is, no
++++ * guarantees are made about scheduling.
++++ *
++++ * The name field is for easier debugging. A copy of the name is
++++ * (should be) made internally.
++++ */
++++
++++struct cv {
++++        char *cv_name;
++++        // add what you need here
++++        // (don't forget to mark things volatile as needed)
++++};
++++
++++struct cv *cv_create(const char *name);
++++void cv_destroy(struct cv *);
++++
++++/*
++++ * Operations:
++++ *    cv_wait      - Release the supplied lock, go to sleep, and, after
++++ *                   waking up again, re-acquire the lock.
++++ *    cv_signal    - Wake up one thread that's sleeping on this CV.
++++ *    cv_broadcast - Wake up all threads sleeping on this CV.
++++ *
++++ * For all three operations, the current thread must hold the lock passed 
++++ * in. Note that under normal circumstances the same lock should be used
++++ * on all operations with any particular CV.
++++ *
++++ * These operations must be atomic. You get to write them.
++++ */
++++void cv_wait(struct cv *cv, struct lock *lock);
++++void cv_signal(struct cv *cv, struct lock *lock);
++++void cv_broadcast(struct cv *cv, struct lock *lock);
++++
++++/*
++++ * 13 Feb 2012 : GWA : Reader-writer locks.
++++ */
++++
++++struct rwlock {
++++        char *rwlock_name;
++++};
++++
++++struct rwlock * rwlock_create(const char *);
++++void rwlock_destroy(struct rwlock *);
++++
++++void rwlock_acquire_read(struct rwlock *);
++++void rwlock_release_read(struct rwlock *);
++++void rwlock_acquire_write(struct rwlock *);
++++void rwlock_release_write(struct rwlock *);
++++
++++#endif /* _SYNCH_H_ */
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..ea96700 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -26,6 +26,7 @@
+++  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++  * SUCH DAMAGE.
+++  */
++++#include<thread.h>
+++ 
+++ #ifndef _SYSCALL_H_
+++ #define _SYSCALL_H_
+++@@ -43,8 +44,9 @@ void syscall(struct trapframe *tf);
+++  * Support functions.
+++  */
+++ 
++++
+++ /* Helper for fork(). You write this. */
+++-void enter_forked_process(struct trapframe *tf);
++++void enter_forked_process(void *tf,unsigned long adrspace);
+++ 
+++ /* Enter user mode. Does not return. */
+++ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++@@ -55,7 +57,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++  * Prototypes for IN-KERNEL entry points for system call implementations.
+++  */
+++ 
++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
++++int sys_close(int fd);
++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
++++int sys_dup2(int oldfd, int newfd, int *retval);
++++int sys_chdir(userptr_t path);
++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
++++
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++int sys_fork(struct trapframe* tf,unsigned long adrspace,int* retval);
++++int sys_execv(char* progname,char** arguments);
++++int sys_getpid(pid_t *retval);
++++int sys_waitpid(pid_t pid,int *status,int options,pid_t *retval);
++++void sys_exit(int exitcode);
++++int mywait(struct process* mypro);
+++ 
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/test.h b/kern/include/test.h
+++index 240d583..84f60fc 100644
+++--- a/kern/include/test.h
++++++ b/kern/include/test.h
+++@@ -105,7 +105,7 @@ int mallocstress(int, char **);
+++ int nettest(int, char **);
+++ 
+++ /* Routine for running a user-level program. */
+++-int runprogram(char *progname);
++++int runprogram(char *progname,char** argv,unsigned long argc);
+++ 
+++ /* Kernel menu system. */
+++ void menu(char *argstr);
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..77a3515 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -73,7 +73,10 @@ struct thread {
+++ 	 */
+++ 	char *t_name;			/* Name of this thread */
+++ 	const char *t_wchan_name;	/* Name of wait channel, if sleeping */
+++-	threadstate_t t_state;		/* State this thread is in */
++++	threadstate_t t_state;
++++	/* State this thread is in */
++++
++++	pid_t pid;
+++ 
+++ 	/*
+++ 	 * Thread subsystem internal fields.
+++@@ -104,7 +107,7 @@ struct thread {
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++-
++++	struct process* proc;
+++ 	/* VM */
+++ 	struct addrspace *t_addrspace;	/* virtual address space */
+++ 
+++@@ -112,6 +115,19 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++  struct filetable *t_filetable;
++++};
++++
++++struct process {
++++	int full;
++++	pid_t pid;
++++    pid_t ppid;
++++    //struct semaphore* exitsem;
++++    struct lock* tlock;
++++    struct cv* wcv;
++++    bool exited;
++++    int exitcode;
++++    struct thread* self;
+++ };
+++ 
+++ /* Call once during system startup to allocate data structures. */
+++diff --git a/kern/include/uio.h b/kern/include/uio.h
+++index 5d97c48..c9124e8 100644
+++--- a/kern/include/uio.h
++++++ b/kern/include/uio.h
+++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+++ void uio_kinit(struct iovec *, struct uio *,
+++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+++ 
++++void uio_uinit(struct iovec *, struct uio *,
++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
++++
+++ 
+++ #endif /* _UIO_H_ */
+++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+++index 594fe96..83ea620 100644
+++--- a/kern/lib/uio.c
++++++ b/kern/lib/uio.c
+++@@ -153,6 +153,7 @@ void
+++ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+++ {
++++	KASSERT(u);
+++ 	iov->iov_kbase = kbuf;
+++ 	iov->iov_len = len;
+++ 	u->uio_iov = iov;
+++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
+++ 	u->uio_rw = rw;
+++ 	u->uio_space = NULL;
+++ }
++++
++++void
++++uio_uinit(struct iovec *iov, struct uio *u,
++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
++++{
++++	KASSERT(u);
++++	iov->iov_ubase = ubuf;
++++	iov->iov_len = len;
++++  u->uio_iov = iov;
++++	u->uio_iovcnt = 1;
++++	u->uio_offset = pos;
++++	u->uio_resid = len;
++++	u->uio_segflg = UIO_USERSPACE;
++++	u->uio_rw = rw;
++++	u->uio_space = curthread->t_addrspace;
++++}
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..4d8e7e2 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -100,7 +100,7 @@ boot(void)
+++ 	kprintf("%s", harvard_copyright);
+++ 	kprintf("\n");
+++ 
+++-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
+++ 		GROUP_VERSION, buildconfig, buildversion);
+++ 	kprintf("\n");
+++ 
+++diff --git a/kern/startup/main.c~ b/kern/startup/main.c~
+++new file mode 100644
+++index 0000000..4d8e7e2
+++--- /dev/null
++++++ b/kern/startup/main.c~
+++@@ -0,0 +1,211 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Main.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/reboot.h>
++++#include <kern/unistd.h>
++++#include <lib.h>
++++#include <spl.h>
++++#include <clock.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++#include <vm.h>
++++#include <mainbus.h>
++++#include <vfs.h>
++++#include <device.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <version.h>
++++#include "autoconf.h"  // for pseudoconfig
++++
++++
++++/*
++++ * These two pieces of data are maintained by the makefiles and build system.
++++ * buildconfig is the name of the config file the kernel was configured with.
++++ * buildversion starts at 1 and is incremented every time you link a kernel. 
++++ *
++++ * The purpose is not to show off how many kernels you've linked, but
++++ * to make it easy to make sure that the kernel you just booted is the
++++ * same one you just built.
++++ */
++++extern const int buildversion;
++++extern const char buildconfig[];
++++
++++/*
++++ * Copyright message for the OS/161 base code.
++++ */
++++static const char harvard_copyright[] =
++++    "Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009\n"
++++    "   President and Fellows of Harvard College.  All rights reserved.\n";
++++
++++
++++/*
++++ * Initial boot sequence.
++++ */
++++static
++++void
++++boot(void)
++++{
++++	/*
++++	 * The order of these is important!
++++	 * Don't go changing it without thinking about the consequences.
++++	 *
++++	 * Among other things, be aware that console output gets
++++	 * buffered up at first and does not actually appear until
++++	 * mainbus_bootstrap() attaches the console device. This can
++++	 * be remarkably confusing if a bug occurs at this point. So
++++	 * don't put new code before mainbus_bootstrap if you don't
++++	 * absolutely have to.
++++	 *
++++	 * Also note that the buffer for this is only 1k. If you
++++	 * overflow it, the system will crash without printing
++++	 * anything at all. You can make it larger though (it's in
++++	 * dev/generic/console.c).
++++	 */
++++
++++	kprintf("\n");
++++	kprintf("OS/161 base system version %s\n", BASE_VERSION);
++++	kprintf("%s", harvard_copyright);
++++	kprintf("\n");
++++
++++	kprintf("nmanivas@buffalo.edu and sitaramc@buffalo.edu system version %s (%s #%d)\n", 
++++		GROUP_VERSION, buildconfig, buildversion);
++++	kprintf("\n");
++++
++++	/* Early initialization. */
++++	ram_bootstrap();
++++	thread_bootstrap();
++++	hardclock_bootstrap();
++++	vfs_bootstrap();
++++
++++	/* Probe and initialize devices. Interrupts should come on. */
++++	kprintf("Device probe...\n");
++++	KASSERT(curthread->t_curspl > 0);
++++	mainbus_bootstrap();
++++	KASSERT(curthread->t_curspl == 0);
++++	/* Now do pseudo-devices. */
++++	pseudoconfig();
++++	kprintf("\n");
++++
++++	/* Late phase of initialization. */
++++	vm_bootstrap();
++++	kprintf_bootstrap();
++++	thread_start_cpus();
++++
++++	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
++++	vfs_setbootfs("emu0");
++++
++++
++++	/*
++++	 * Make sure various things aren't screwed up.
++++	 */
++++	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
++++	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
++++}
++++
++++/*
++++ * Shutdown sequence. Opposite to boot().
++++ */
++++static
++++void
++++shutdown(void)
++++{
++++
++++	kprintf("Shutting down.\n");
++++	
++++	vfs_clearbootfs();
++++	vfs_clearcurdir();
++++	vfs_unmountall();
++++
++++	thread_shutdown();
++++
++++	splhigh();
++++}
++++
++++/*****************************************/
++++
++++/*
++++ * reboot() system call.
++++ *
++++ * Note: this is here because it's directly related to the code above,
++++ * not because this is where system call code should go. Other syscall
++++ * code should probably live in the "syscall" directory.
++++ */
++++int
++++sys_reboot(int code)
++++{
++++	switch (code) {
++++	    case RB_REBOOT:
++++	    case RB_HALT:
++++	    case RB_POWEROFF:
++++		break;
++++	    default:
++++		return EINVAL;
++++	}
++++
++++	shutdown();
++++
++++	switch (code) {
++++	    case RB_HALT:
++++		kprintf("The system is halted.\n");
++++		mainbus_halt();
++++		break;
++++	    case RB_REBOOT:
++++		kprintf("Rebooting...\n");
++++		mainbus_reboot();
++++		break;
++++	    case RB_POWEROFF:
++++		kprintf("The system is halted.\n");
++++		mainbus_poweroff();
++++		break;
++++	}
++++
++++	panic("reboot operation failed\n");
++++	return 0;
++++}
++++
++++/*
++++ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
++++ * request, and then shut down.
++++ */
++++void
++++kmain(char *arguments)
++++{
++++	boot();
++++
++++	menu(arguments);
++++
++++	/* Should not get here */
++++}
+++diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+++index 6c71551..a4c2750 100644
+++--- a/kern/startup/menu.c
++++++ b/kern/startup/menu.c
+++@@ -40,9 +40,13 @@
+++ #include <sfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include<thread.h>
++++#include<synch.h>
+++ #include "opt-synchprobs.h"
+++ #include "opt-sfs.h"
+++ #include "opt-net.h"
++++#include <copyinout.h>
++++//#include "proc_sys.c"
+++ 
+++ /*
+++  * In-kernel menu and command dispatcher.
+++@@ -51,6 +55,7 @@
+++ #define _PATH_SHELL "/bin/sh"
+++ 
+++ #define MAXMENUARGS  16
++++extern struct process* p_table[17];
+++ 
+++ // XXX this should not be in this file
+++ void
+++@@ -100,7 +105,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
+++ 
+++ 	strcpy(progname, args[0]);
+++ 
+++-	result = runprogram(progname);
++++	result = runprogram(progname,args,nargs);
+++ 	if (result) {
+++ 		kprintf("Running program %s failed: %s\n", args[0],
+++ 			strerror(result));
+++@@ -127,6 +132,8 @@ int
+++ common_prog(int nargs, char **args)
+++ {
+++ 	int result;
++++	struct thread* fthread;
++++	//int err;
+++ 
+++ #if OPT_SYNCHPROBS
+++ 	kprintf("Warning: this probably won't work with a "
+++@@ -136,7 +143,28 @@ common_prog(int nargs, char **args)
+++ 	result = thread_fork(args[0] /* thread name */,
+++ 			cmd_progthread /* thread function */,
+++ 			args /* thread arg */, nargs /* thread arg */,
+++-			NULL);
++++			&fthread);
++++	//fthread->
++++	fthread->proc=(struct process*)kmalloc(sizeof(struct process));
++++
++++	fthread->pid=PID_MIN;
++++	fthread->proc->pid=PID_MIN;
++++
++++	fthread->proc->self=fthread;
++++	fthread->proc->wcv=cv_create("First CV");
++++	fthread->proc->tlock=lock_create("First Lock");
++++	p_table[0]=fthread->proc;
++++
++++	lock_acquire(p_table[0]->tlock);
++++	mywait(p_table[0]);
++++	lock_release(p_table[0]->tlock);
++++
++++	//err=sys_waitpid((pid_t)tf->tf_a0,(int*)tf->tf_a1,(int)tf->tf_a2,&retval);
++++
++++	//fthread->proc->
++++	//while(!p_table[0]->exited)
++++
++++
+++ 	if (result) {
+++ 		kprintf("thread_fork failed: %s\n", strerror(result));
+++ 		return result;
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..6c0bb3f 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -43,11 +43,25 @@
+++  * You should implement your solution to the whalemating problem below.
+++  */
+++ 
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++-// the top of the corresponding driver code.
++++// the top of the corresponding driver code
++++
++++struct semaphore *male_sem;
++++struct semaphore *female_sem;
++++struct lock *hold;
++++struct cv* mate_cv;
++++volatile int male_count;
++++volatile int female_count;
+++ 
+++ void whalemating_init() {
++++ hold=lock_create("My lock");
++++ male_sem=sem_create("Male Semaphore",0);
++++ female_sem=sem_create("Female Semaphore",0);
++++mate_cv=cv_create("mating cv");
++++male_count=0;
++++female_count=0;
+++   return;
+++ }
+++ 
+++@@ -55,6 +69,11 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++
++++	sem_destroy(male_sem);
++++	sem_destroy(female_sem);
++++	lock_destroy(hold);
++++	cv_destroy(mate_cv);
+++   return;
+++ }
+++ 
+++@@ -65,6 +84,17 @@ male(void *p, unsigned long which)
+++   (void)which;
+++   
+++   male_start();
++++
++++  lock_acquire(hold);
++++
++++  V(male_sem);
++++  male_count++;
++++  if(female_count!=0)
++++  cv_signal(mate_cv,hold);
++++  else
++++	  cv_wait(mate_cv,hold);
++++  lock_release(hold);
++++
+++ 	// Implement this function 
+++   male_end();
+++ 
+++@@ -81,9 +111,16 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
++++  lock_acquire(hold);
++++   V(female_sem);
++++   female_count++;
++++   if(male_count!=0)
++++   cv_signal(mate_cv,hold);
++++   else
++++	   cv_wait(mate_cv,hold);
++++  lock_release(hold);
+++ 	// Implement this function 
+++   female_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++@@ -97,15 +134,25 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
++++  lock_acquire(hold);
++++ P(male_sem);
++++ male_count--;
++++ lock_release(hold);
++++ lock_acquire(hold);
++++  P(female_sem);
++++  female_count--;
++++  lock_release(hold);
+++ 	// Implement this function 
+++   matchmaker_end();
+++-  
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
++++
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -136,8 +183,26 @@ matchmaker(void *p, unsigned long which)
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
++++struct lock* intersect_lock;
++++struct cv* intersect_cv;
++++volatile int cur_poss[4];// an array to store the possible positions of the car
++++//currently
+++ 
+++ void stoplight_init() {
++++	intersect_cv=cv_create("Intersection Condition Variable");
++++	if(intersect_cv==NULL)
++++	{
++++		///return NULL;
++++		panic("condition variable not created");
++++	}
++++	intersect_lock=lock_create("A lock on the intersection");
++++	if(intersect_lock==NULL)
++++	{
++++		//return NULL;
++++		panic("Lock could not be created");
++++	}
++++	
++++	
+++   return;
+++ }
+++ 
+++@@ -145,6 +210,8 @@ void stoplight_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
++++	cv_destroy(intersect_cv);
++++	lock_destroy(intersect_lock);
+++   return;
+++ }
+++ 
+++@@ -152,8 +219,29 @@ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++  //(void)direction;
++++	int sec_quad=(direction+3)%4;
++++	lock_acquire(intersect_lock);
++++	// So while any of the two possible quadrants are already set, It means some 
++++	//thread is waiting...Hopefully
++++	while(cur_poss[direction]==1||cur_poss[sec_quad]==1)
++++		cv_wait(intersect_cv,intersect_lock);
++++	cur_poss[direction]=1;
++++	cur_poss[sec_quad]=1;
++++	inQuadrant(direction);
++++	lock_release(intersect_lock);
++++	lock_acquire(intersect_lock);
++++    cur_poss[direction]=0;
++++    //while(curr_p)
++++    //cv_broadcast(intersect_cv);
++++    inQuadrant(sec_quad);
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++    cur_poss[sec_quad]=0;
++++    leaveIntersection();
++++    cv_broadcast(intersect_cv,intersect_lock);
++++    lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -165,7 +253,40 @@ turnleft(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
++++  int sec_quad=(direction+3)%4;
++++  int third_quad=(direction+2)%4;
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1||cur_poss[sec_quad]==1||cur_poss[third_quad]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  cur_poss[sec_quad]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++  lock_acquire(intersect_lock);
++++  cur_poss[direction]=0;
+++   
++++  //while(cur_poss[third_quad]==1||cur_poss[sec_quad]==1)
++++  //cv_wait(intersect_cv,intersect_lock);
++++      cur_poss[third_quad]=1;
++++      //while(curr_p)
++++      //cv_broadcast(intersect_cv);
++++      inQuadrant(sec_quad);
++++      cv_broadcast(intersect_cv,intersect_lock);
++++      lock_release(intersect_lock);
++++        lock_acquire(intersect_lock);
++++            //currposs[direction]=0;
++++            cur_poss[sec_quad]=0;
++++            //while(curr_p)
++++            //cv_broadcast(intersect_cv);
++++            inQuadrant(third_quad);
++++            cv_broadcast(intersect_cv,intersect_lock);
++++                //cur_poss[third_quad]=0;
++++            lock_release(intersect_lock);
++++              lock_acquire(intersect_lock);
++++                leaveIntersection();
++++                cur_poss[third_quad]=0;
++++                cv_broadcast(intersect_cv,intersect_lock);
++++                lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -177,7 +298,18 @@ turnright(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++   (void)direction;
+++-
++++  // Easy coz the vehicle is in same lane!!
++++  lock_acquire(intersect_lock);
++++  while(cur_poss[direction]==1)
++++	  cv_wait(intersect_cv,intersect_lock);
++++  cur_poss[direction]=1;
++++  inQuadrant(direction);
++++  lock_release(intersect_lock);
++++    lock_acquire(intersect_lock);
++++  leaveIntersection();
++++  cur_poss[direction]=0;
++++  cv_broadcast(intersect_cv,intersect_lock);
++++  lock_release(intersect_lock);
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
+++new file mode 100644
+++index 0000000..dc5ffe5
+++--- /dev/null
++++++ b/kern/syscall/file.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * File handles and file tables.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++
++++/*** openfile functions ***/
++++
++++/*
++++ * file_open
++++ * opens a file, places it in the filetable, sets RETFD to the file
++++ * descriptor. the pointer arguments must be kernel pointers.
++++ * NOTE -- the passed in filename must be a mutable string.
++++ */
++++int
++++file_open(char *filename, int flags, int mode, int *retfd)
++++{
++++	struct vnode *vn;
++++	struct openfile *file;
++++	int result;
++++	
++++	result = vfs_open(filename, flags, mode, &vn);
++++	if (result) {
++++		return result;
++++	}
++++
++++	file = kmalloc(sizeof(struct openfile));
++++	if (file == NULL) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	/* initialize the file struct */
++++	file->of_lock = lock_create("file lock");
++++	if (file->of_lock == NULL) {
++++		vfs_close(vn);
++++		kfree(file);
++++		return ENOMEM;
++++	}
++++	file->of_vnode = vn;
++++	file->of_offset = 0;
++++	file->of_accmode = flags & O_ACCMODE;
++++	file->of_refcount = 1;
++++
++++	/* vfs_open checks for invalid access modes */
++++	KASSERT(file->of_accmode==O_RDONLY ||
++++	        file->of_accmode==O_WRONLY ||
++++	        file->of_accmode==O_RDWR);
++++
++++	/* place the file in the filetable, getting the file descriptor */
++++	result = filetable_placefile(file, retfd);
++++	if (result) {
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++		vfs_close(vn);
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * file_doclose
++++ * shared code for file_close and filetable_destroy
++++ */
++++static
++++int
++++file_doclose(struct openfile *file)
++++{
++++	lock_acquire(file->of_lock);
++++
++++	/* if this is the last close of this file, free it up */
++++	if (file->of_refcount == 1) {
++++		vfs_close(file->of_vnode);
++++		lock_release(file->of_lock);
++++		lock_destroy(file->of_lock);
++++		kfree(file);
++++	}
++++	else {
++++		KASSERT(file->of_refcount > 1);
++++		file->of_refcount--;
++++		lock_release(file->of_lock);
++++	}
++++
++++	return 0;
++++}
++++
++++/* 
++++ * file_close
++++ * knock off the refcount, freeing the memory if it goes to 0.
++++ */
++++int
++++file_close(int fd)
++++{
++++	struct openfile *file;
++++	int result;
++++
++++	/* find the file in the filetable */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	result = file_doclose(file);
++++	if (result) {
++++		/* leave file open for possible retry */
++++		return result;
++++	}
++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
++++
++++	return 0;
++++}
++++
++++/*** filetable functions ***/
++++
++++/* 
++++ * filetable_init
++++ * pretty straightforward -- allocate the space, initialize to NULL.
++++ * note that the one careful thing is to open the std i/o in order to
++++ * get
++++ * stdin  == 0
++++ * stdout == 1
++++ * stderr == 2
++++ */
++++int
++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
++++{
++++	/* the filenames come from the kernel; assume reasonable length */
++++	char path[32];
++++	int result;
++++	int fd;
++++
++++	/* make sure we can fit these */
++++	KASSERT(strlen(inpath) < sizeof(path));
++++	KASSERT(strlen(outpath) < sizeof(path));
++++	KASSERT(strlen(errpath) < sizeof(path));
++++	
++++	/* catch memory leaks, repeated calls */
++++	KASSERT(curthread->t_filetable == NULL);
++++
++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
++++	if (curthread->t_filetable == NULL) {
++++		return ENOMEM;
++++	}
++++	
++++	/* NULL-out the table */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
++++	}
++++
++++	/*
++++	 * open the std fds.  note that the names must be copied into
++++	 * the path buffer so that they're mutable.
++++	 */
++++	strcpy(path, inpath);
++++	result = file_open(path, O_RDONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, outpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	strcpy(path, errpath);
++++	result = file_open(path, O_WRONLY, 0, &fd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_copy
++++ * again, pretty straightforward.  the subtle business here is that instead of
++++ * copying the openfile structure, we just increment the refcount.  this means
++++ * that openfile structs will, in fact, be shared between processes, as in
++++ * Unix.
++++ */
++++int
++++filetable_copy(struct filetable **copy)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int fd;
++++
++++	/* waste of a call, really */
++++	if (ft == NULL) {
++++		*copy = NULL;
++++		return 0;
++++	}
++++	
++++	*copy = kmalloc(sizeof(struct filetable));
++++	
++++	if (*copy == NULL) {
++++		return ENOMEM;
++++	}
++++
++++	/* copy over the entries */
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd] != NULL) {
++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
++++			ft->ft_openfiles[fd]->of_refcount++;
++++			lock_release(ft->ft_openfiles[fd]->of_lock);
++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
++++		} 
++++		else {
++++			(*copy)->ft_openfiles[fd] = NULL;
++++		}
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_destroy
++++ * closes the files in the file table, frees the table.
++++ */
++++void
++++filetable_destroy(struct filetable *ft)
++++{
++++	int fd, result;
++++
++++	KASSERT(ft != NULL);
++++
++++	for (fd = 0; fd < OPEN_MAX; fd++) {
++++		if (ft->ft_openfiles[fd]) {
++++			result = file_doclose(ft->ft_openfiles[fd]);
++++			KASSERT(result==0);
++++		}
++++	}
++++	
++++	kfree(ft);
++++}	
++++
++++/* 
++++ * filetable_placefile
++++ * finds the smallest available file descriptor, places the file at the point,
++++ * sets FD to it.
++++ */
++++int
++++filetable_placefile(struct openfile *file, int *fd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	int i;
++++	
++++	for (i = 0; i < OPEN_MAX; i++) {
++++		if (ft->ft_openfiles[i] == NULL) {
++++			ft->ft_openfiles[i] = file;
++++			*fd = i;
++++			return 0;
++++		}
++++	}
++++
++++	return EMFILE;
++++}
++++
++++/*
++++ * filetable_findfile
++++ * verifies that the file descriptor is valid and actually references an
++++ * open file, setting the FILE to the file at that index if it's there.
++++ */
++++int
++++filetable_findfile(int fd, struct openfile **file)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++
++++	if (fd < 0 || fd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++	
++++	*file = ft->ft_openfiles[fd];
++++	if (*file == NULL) {
++++		return EBADF;
++++	}
++++
++++	return 0;
++++}
++++
++++/*
++++ * filetable_dup2file
++++ * verifies that both file descriptors are valid, and that the OLDFD is
++++ * actually an open file.  then, if the NEWFD is open, it closes it.
++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
++++ */
++++int
++++filetable_dup2file(int oldfd, int newfd)
++++{
++++	struct filetable *ft = curthread->t_filetable;
++++	struct openfile *file;
++++	int result;
++++
++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
++++		return EBADF;
++++	}
++++
++++	file = ft->ft_openfiles[oldfd];
++++	if (file == NULL) {
++++		return EBADF;
++++	}
++++
++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
++++	if (oldfd == newfd) {
++++		return 0;
++++	}
++++
++++	/* closes the newfd if it's open */
++++	if (ft->ft_openfiles[newfd] != NULL) {
++++		result = file_close(newfd);
++++		if (result) {
++++			return result;
++++		}
++++	}
++++
++++	/* up the refcount */
++++	lock_acquire(file->of_lock);
++++	file->of_refcount++;
++++	lock_release(file->of_lock);
++++
++++	/* doesn't need to be synchronized because it's just changing the ft */
++++	ft->ft_openfiles[newfd] = file;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..8aa024c
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,270 @@
++++/*
++++ * File-related system call implementations.
++++ * New for SOL2.
++++ */
++++
++++#include <types.h>
++++#include <kern/errno.h>
++++#include <kern/limits.h>
++++#include <kern/stat.h>
++++#include <kern/unistd.h>
++++#include <kern/fcntl.h>
++++#include <kern/seek.h>
++++#include <lib.h>
++++#include <synch.h>
++++#include <uio.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <file.h>
++++#include <syscall.h>
++++#include <copyinout.h>
++++
++++/*
++++ * sys_open
++++ * just copies in the filename, then passes work to file_open.
++++ */
++++int
++++sys_open(userptr_t filename, int flags, int mode, int *retval)
++++{
++++	char fname[PATH_MAX];
++++	int result;
++++
++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return file_open(fname, flags, mode, retval);
++++}
++++
++++/*
++++ * sys_read
++++ * translates the fd into its openfile, then calls VOP_READ.
++++ */
++++int
++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	/* better be a valid file descriptor */
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_WRONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
++++  
++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
++++
++++	/* does the read */
++++	result = VOP_READ(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++	
++++	/*
++++	 * The amount read is the size of the buffer originally, minus
++++	 * how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/*
++++ * sys_write
++++ * translates the fd into its openfile, then calls VOP_WRITE.
++++ */
++++int
++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++
++++	if (file->of_accmode == O_RDONLY) {
++++		lock_release(file->of_lock);
++++		return EBADF;
++++	}
++++
++++	/* set up a uio with the buffer, its size, and the current offset */
++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
++++	
++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
++++
++++	/* does the write */
++++	result = VOP_WRITE(file->of_vnode, &useruio);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++
++++	/* set the offset to the updated offset in the uio */
++++	file->of_offset = useruio.uio_offset;
++++
++++	lock_release(file->of_lock);
++++
++++	/*
++++	 * the amount written is the size of the buffer originally,
++++	 * minus how much is left in it.
++++	 */
++++	*retval = size - useruio.uio_resid;
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_close
++++ * just pass off the work to file_close.
++++ */
++++int
++++sys_close(int fd)
++++{
++++	return file_close(fd);
++++}
++++
++++/*
++++ * sys_lseek
++++ * translates the fd into its openfile, then based on the type of seek,
++++ * figure out the new offset, try the seek, if that succeeds, update the
++++ * openfile.
++++ */
++++int
++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
++++{
++++	struct stat info;
++++	struct openfile *file;
++++	int result;
++++
++++	result = filetable_findfile(fd, &file);
++++	if (result) {
++++		return result;
++++	}
++++
++++	lock_acquire(file->of_lock);
++++	
++++	/* based on the type of seek, set the retval */ 
++++	switch (whence) {
++++	    case SEEK_SET:
++++		*retval = offset;
++++		break;
++++	    case SEEK_CUR:
++++		*retval = file->of_offset + offset;
++++		break;
++++	    case SEEK_END:
++++		result = VOP_STAT(file->of_vnode, &info);
++++		if (result) {
++++			lock_release(file->of_lock);
++++			return result;
++++		}
++++		*retval = info.st_size + offset;
++++		break;
++++	    default:
++++		lock_release(file->of_lock);
++++		return EINVAL;
++++	}
++++
++++	/* try the seek -- if it fails, return */
++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
++++	if (result) {
++++		lock_release(file->of_lock);
++++		return result;
++++	}
++++	
++++	/* success -- update the file structure */
++++	file->of_offset = *retval;
++++
++++	lock_release(file->of_lock);
++++
++++	return 0;
++++}
++++
++++/* 
++++ * sys_dup2
++++ * just pass the work off to the filetable
++++ */
++++int
++++sys_dup2(int oldfd, int newfd, int *retval)
++++{
++++	int result;
++++
++++	result = filetable_dup2file(oldfd, newfd);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = newfd;
++++	return 0;
++++}
++++
++++/* really not "file" calls, per se, but might as well put it here */
++++
++++/*
++++ * sys_chdir
++++ * copyin the path and pass it off to vfs.
++++ */
++++int
++++sys_chdir(userptr_t path)
++++{
++++	char pathbuf[PATH_MAX];
++++	int result;
++++	
++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
++++	if (result) {
++++		return result;
++++	}
++++
++++	return vfs_chdir(pathbuf);
++++}
++++
++++/*
++++ * sys___getcwd
++++ * just use vfs_getcwd.
++++ */
++++int
++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
++++{
++++  struct iovec iov;
++++	struct uio useruio;
++++	int result;
++++  
++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
++++
++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
++++
++++	result = vfs_getcwd(&useruio);
++++	if (result) {
++++		return result;
++++	}
++++
++++	*retval = buflen - useruio.uio_resid;
++++
++++	return 0;
++++}
+++diff --git a/kern/syscall/proc_sys.c b/kern/syscall/proc_sys.c
+++new file mode 100644
+++index 0000000..dfd7b53
+++--- /dev/null
++++++ b/kern/syscall/proc_sys.c
+++@@ -0,0 +1,445 @@
++++/*
++++
++++ * proc_sys.c
++++ *
++++ *  Created on: Mar 7, 2014
++++ *      Author: trinity
++++ */
++++
++++#include <types.h>
++++#include<mips/trapframe.h>
++++#include <kern/errno.h>
++++#include <kern/fcntl.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <addrspace.h>
++++#include <vm.h>
++++#include <vfs.h>
++++#include <syscall.h>
++++#include <test.h>
++++#include <file.h>
++++#include <synch.h>
++++#include<copyinout.h>
++++#include <spl.h>
++++#include<kern/wait.h>
++++
++++extern struct process* p_table[17];
++++
++++//struct cv* wcv;
++++
++++extern pid_t pidcount;
++++int mywait(struct process* mypro) {
++++	//lock_acquire(mypro->tlock);
++++	while (!mypro->exited) {
++++		cv_wait(mypro->wcv, mypro->tlock);
++++	}
++++	//*status=mypro->exitcode;
++++	//lock_release(mypro->tlock);
++++	//int test = mypro->exitcode;
++++	//test++;
++++	return 0;
++++}
++++
++++int sys_fork(struct trapframe* tf, unsigned long adrs, int *retval) {
++++	(void) adrs;
++++	int flag;
++++	pid_t childid;
++++	struct addrspace *adrcopy;
++++	struct trapframe* copyt = (struct trapframe*) kmalloc(
++++			sizeof(struct trapframe));
++++	bzero(copyt, sizeof(struct trapframe));
++++
++++	//struct filetable* copyft;
++++	//kprintf("Parent ID:%d\n",curthread->proc->pid);
++++
++++	memcpy(copyt, tf, sizeof(struct trapframe));
++++	flag = as_copy(curthread->t_addrspace, &adrcopy);
++++	//if(curthread->pid==0)
++++	//{
++++	//curthread->pid=PID_MIN;
++++	//}
++++	if (flag) {
++++		kfree(copyt);
++++		return flag;
++++	}
++++
++++	//we need to allocate pid for our new process
++++
++++	//pid_t cpid;
++++	for (childid = 0; childid <= 16; childid++) {
++++		if (p_table[childid] == NULL ) {
++++			p_table[childid] = (struct process*) kmalloc(
++++					sizeof(struct process));
++++			p_table[childid]->full = 1;
++++			pidcount++;
++++			p_table[childid]->pid = pidcount;
++++			p_table[childid]->ppid = curthread->pid;
++++			//p_table[childid]->exitsem=sem_create("process",0);
++++			p_table[childid]->tlock = lock_create("My Lock");
++++			p_table[childid]->wcv = cv_create("My CV");
++++			p_table[childid]->self = NULL;
++++			break;
++++		}
++++	}
++++	if (childid > PID_MAX) {
++++		*retval = 1;
++++		return EMPROC;
++++	}
++++	//int i;
++++
++++	copyt->tf_a0 = (int) p_table[childid]->pid;
++++	//kprintf("Ret:%d\n",copyt->tf_a0);
++++	struct thread *new_proc;
++++	//curthread->t_addrspace=(struct addrspace*)adrcopy;
++++	//int s=splhigh();
++++	flag = thread_fork("newproc", enter_forked_process, (void *) copyt,
++++			(unsigned long) adrcopy, &new_proc);
++++	//kprintf("Out of thread fork:%d\n",flag);
++++	if (flag) {
++++		kfree(copyt);
++++		as_destroy(adrcopy);
++++
++++		return flag;
++++	}
++++
++++	//new_proc->pid=(pid_t)childid;
++++	//new_proc=p_table[childid];
++++
++++	new_proc->pid = p_table[childid]->pid;
++++	new_proc->proc = p_table[childid];
++++	// new_proc->t_filetable = kmalloc(sizeof(struct filetable));
++++	//if (new_proc->t_filetable == NULL) {
++++	//return ENOMEM;
++++	//}
++++	p_table[childid]->self = new_proc;
++++
++++	//new_proc->pid=p_table[childid]->pid;
++++	//new_proc->proc->pid=p_table[childid]->pid;
++++	//kprintf("Child id in fork: %d\n",new_proc->pid);
++++
++++	//kprintf("Child id:%d",new_proc->pid);
++++	//new_proc->t_filetable->
++++	//for(i=0;i<128;i++)
++++	//{
++++	flag = filetable_copy(&new_proc->t_filetable);
++++	//}
++++	//splx(s);
++++	// kprintf("Fork over!");
++++
++++	*retval = p_table[childid]->pid;
++++	//kprintf("Return val in fork:%d",*retval);
++++	return 0;
++++
++++	//flag=
++++	//flag=thread_fork=
++++}
++++
++++int sys_execv(char *progname, char** arguments) {
++++
++++	int flag;
++++	int numargs;
++++	int addr;
++++	int i;
++++	// first we need to copy the program name to the kernel space
++++	// then we go for arguments. Path size unknown
++++
++++	size_t actual_size = 0;
++++	char *namedes;
++++
++++	if (progname == NULL ) {
++++		return EFAULT;
++++	}
++++	if (progname == "") {
++++		return EINVAL;
++++	}
++++
++++	namedes = (char*) kmalloc(PATH_MAX);
++++	flag = copyinstr((const_userptr_t) progname, namedes, PATH_MAX,
++++			&actual_size);
++++	if (flag != 0) {
++++		kfree(namedes);
++++		return flag;
++++	}
++++	//namedes[actual_size]
++++	if (strlen(namedes) == 0) {
++++		//*retval=1;
++++		return EISDIR;
++++	}
++++
++++	// now we open file using vfs_open. Same as runprogram
++++	struct vnode* vn;
++++	flag = vfs_open(namedes, O_RDONLY, 0, &vn);
++++	if (flag) {
++++		return flag;
++++	}
++++	actual_size = 0;
++++	// according to the blog, now cpy the arguments 1 by one into the kernel spca.
++++
++++	//char** kargv=(char**)kmalloc(sizeof(char));
++++	// get the number of arguments
++++	if (arguments == NULL ) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++	flag = copyin((userptr_t) arguments, &addr, sizeof(int));
++++	if (flag) {
++++		kfree(namedes);
++++		return EFAULT;
++++	}
++++
++++	//check=wthread->exitcode;
++++	//err=copyout(&check,(userptr_t)status,sizeof(check));
++++	//if(err)
++++	//{
++++	//	lock_release(p_table[i]->tlock);
++++	//return err;
++++	//}
++++
++++	numargs = 0;
++++	while (arguments[numargs] != NULL ) {
++++		//kprintf("%");
++++		numargs = numargs + 1;
++++	}
++++
++++	char** kargv = (char**) kmalloc(sizeof(char*) * numargs);
++++	//int i;
++++	for (i = 0; i < numargs; i++) {
++++		actual_size = 0;
++++		kargv[i] = (char*) kmalloc(PATH_MAX);
++++		flag = copyinstr((userptr_t) arguments[i], kargv[i], PATH_MAX,
++++				&actual_size);
++++		if (flag) {
++++			kfree(kargv);
++++			kfree(namedes);
++++			return EFAULT;
++++		}
++++
++++	}
++++	actual_size = 0;
++++
++++	curthread->t_addrspace = as_create();
++++	if (curthread->t_addrspace == NULL ) {
++++		vfs_close(vn);
++++		return ENOMEM;
++++	}
++++
++++	vaddr_t entrypoint, stackptr;
++++	as_activate(curthread->t_addrspace);
++++	flag = load_elf(vn, &entrypoint);
++++	if (flag) {
++++		// thread_exit destroys curthread->t_addrspace
++++		vfs_close(vn);
++++		return flag;
++++	}
++++
++++	vfs_close(vn);
++++
++++	// now set up the user stack with the arguments
++++	flag = as_define_stack(curthread->t_addrspace, &stackptr);
++++	if (flag) {
++++		//thread_exit destroys curthread->t_addrspace
++++		return flag;
++++	}
++++
++++	//i=0;
++++	vaddr_t stackptrv[numargs + 1];
++++	for (i = numargs - 1; i >= 0; i--) {
++++		int len = strlen(kargv[i]);
++++		int padder=0;
++++		len++;// to account for string terminator
++++		if(len%4!=0)
++++		padder = len % 4;
++++		stackptr =stackptr-(len + padder);
++++		flag = copyoutstr((const char *) kargv[i], (userptr_t) stackptr, len,
++++				&actual_size);
++++
++++		if (flag)
++++		{
++++			kfree(kargv);
++++			kfree(namedes);
++++			return flag;
++++		}
++++
++++		stackptrv[i] = stackptr;
++++	}
++++	stackptrv[numargs] = 0;
++++
++++	//This copies the actual stack addresses of the arguments
++++	//* into the stack. Hopefully.
++++
++++	 for(i = numargs; i >= 0; i--)
++++	 {
++++	 stackptr -= sizeof(vaddr_t);
++++	 flag = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++
++++	 if(flag)
++++	 {
++++	 kfree(kargv);
++++	 kfree(namedes);
++++	 return flag;
++++	 }
++++
++++	 }
++++
++++	enter_new_process(numargs, (userptr_t) stackptr, stackptr, entrypoint);
++++	//pt_getthread();
++++
++++	//enter_new_process does not return.
++++	panic("enter_new_process returned\n");
++++	return EINVAL;
++++
++++}
++++
++++int sys_getpid(pid_t *retval) {
++++	//kprintf("In get pid:%d\n",curthread->pid);
++++	//kprintf("In get pid2:%d\n",curthread->proc->pid);
++++
++++	*retval = curthread->proc->pid;
++++	return 0;
++++}
++++
++++int sys_waitpid(pid_t pid, int* status, int options, pid_t *retval) {
++++	struct process* wthread = NULL;
++++	int check;
++++	int err;
++++	pid_t i;
++++	//kprintf("PID in wait pid:%d\n",pid);
++++	if (status == NULL )
++++		return EFAULT;
++++	if (options != 0)
++++		return EINVAL;
++++	if (pid == curthread->pid)
++++		return ECHILD;
++++	if (pid < PID_MIN || pid > PID_MAX)
++++		return ESRCH;
++++	if (status == NULL )
++++		return EFAULT;
++++	if (pid == curthread->proc->ppid)
++++		return ECHILD;
++++	//int *shit;
++++	//*shit=(int)&status;
++++	//kprintf("%d\n",*shit);
++++	//if(curthread->)
++++	//if(pid!=curthread->)
++++	//char* argv=(char*)(status);
++++	//int length=strlen(argv)+1;
++++	//int length=strlen(kargv[i])+1;
++++	//int padder=length%4;
++++	//kprintf("Hai:%d\n",padder);
++++	//if(padder!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++
++++	//if()
++++
++++	//char pathbuf[PATH_MAX];
++++	//int *buffer;
++++	//int result;
++++
++++	//result = copyin((const_userptr_t)status, (void*)buffer, sizeof(int));
++++	//if (result) {
++++	//return result;
++++	//}
++++	//int addr=(int)&status;
++++	//kprintf("Status:%d\n",addr);
++++	//int *addr=&status;
++++	//if(addr%4!=0)
++++	//{
++++	//return EFAULT;
++++	//}
++++	//kprintf("Got Here\n");
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				wthread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++	if (wthread == NULL ) {
++++		return ESRCH;
++++	}
++++	if (curthread->proc->pid != wthread->ppid)
++++		return ECHILD;
++++	//panic("We are here");
++++
++++	lock_acquire(p_table[i]->tlock);
++++
++++	//while(!wthread->exited)
++++	//{
++++//
++++	//	cv_wait(p_table[i]->wcv,p_table[i]->tlock);
++++	//}
++++	mywait(wthread);
++++
++++	//copyout((const void*)wthread->exitcode,(userptr_t)status,sizeof(int));
++++	//kprintf("We are here!");
++++
++++	check = wthread->exitcode;
++++	err = copyout(&check, (userptr_t) status, sizeof(check));
++++	if (err) {
++++		lock_release(p_table[i]->tlock);
++++		return err;
++++	}
++++	//kprintf("Exit code After waiting:%d\n",*status);
++++	//kfree(p_table[i]->exitsem);
++++	//p_table[i]=NULL;
++++
++++	//panic("After kfree");
++++	//p_table[i]=NULL;
++++	lock_release(p_table[i]->tlock);
++++	//filetable_destroy(p_table[i]->self->t_filetable);
++++	//lock_destroy(p_table[i]->tlock);
++++	//cv_destroy(p_table[i]->wcv);
++++	//kfree(p_table[i]);
++++	p_table[i] = NULL;
++++
++++	*retval = pid;
++++	//panic("After dereferencing");
++++	return 0;
++++
++++	//return -1;
++++	//return 0;
++++}
++++
++++void sys_exit(int exitcode) {
++++	pid_t pid = curthread->proc->pid;
++++	pid_t i = PID_MIN;
++++	struct process* ethread;
++++//pid_t parent;
++++//if(pid!=2)
++++//{
++++	for (i = 0; i <= 16; i++) {
++++		if (p_table[i] != NULL ) {
++++			if (p_table[i]->pid == pid) {
++++				ethread = p_table[i];
++++				break;
++++			}
++++		}
++++	}
++++
++++//parent=ethread->ppid;
++++	if (ethread != NULL ) {
++++		lock_acquire(ethread->tlock);
++++//kprintf("Exit code Before:%d\n",exitcode);
++++
++++		ethread->exitcode = _MKWAIT_EXIT(exitcode);
++++//kprintf("Exitcode After:%d\n",ethread->exitcode);
++++		ethread->exited = 1;
++++//p_table[i]=ethread;
++++		cv_broadcast(ethread->wcv, ethread->tlock);
++++//kfree(curthread->t_filetable);
++++		lock_release(ethread->tlock);
++++	}
++++//}
++++	i = 0;
++++//
++++//kprintf("Before hanging");
++++//filetable_destroy(curthread->t_filetable);
++++//kfree(curthread->p);
++++
++++	thread_exit();
++++}
++++
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..1ada408 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,6 +44,8 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
++++#include <file.h>
++++#include<copyinout.h>
+++ 
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++@@ -52,7 +54,7 @@
+++  * Calls vfs_open on progname and thus may destroy it.
+++  */
+++ int
+++-runprogram(char *progname)
++++runprogram(char *progname,char**argv,unsigned long argc)
+++ {
+++ 	struct vnode *v;
+++ 	vaddr_t entrypoint, stackptr;
+++@@ -66,6 +68,13 @@ runprogram(char *progname)
+++ 
+++ 	/* We should be a new thread. */
+++ 	KASSERT(curthread->t_addrspace == NULL);
++++	curthread->t_filetable=NULL;
++++  if (curthread->t_filetable == NULL) {
++++		result = filetable_init("con:", "con:", "con:");
++++		if (result) {
++++			return result;
++++		}
++++	}
+++ 
+++ 	/* Create a new address space. */
+++ 	curthread->t_addrspace = as_create();
+++@@ -94,9 +103,40 @@ runprogram(char *progname)
+++ 		/* thread_exit destroys curthread->t_addrspace */
+++ 		return result;
+++ 	}
++++	vaddr_t stackptrv[argc+1];
++++int i;
++++size_t actual;
++++for(i = argc-1; i >= 0; i--)
++++{
++++int len = strlen(argv[i]);
++++int padder=0;
++++len++;
++++if(len%4!=0)
++++padder = len % 4;
++++stackptr=stackptr-(len + padder);
++++result = copyoutstr(argv[i], (userptr_t)stackptr, len, &actual);
++++if(result)
++++{
++++return result;
++++}
++++stackptrv[i] = stackptr;
++++}
++++stackptrv[argc] = 0;
++++for(i = argc; i >= 0; i--)
++++{
++++stackptr -= sizeof(vaddr_t);
++++result = copyout(&stackptrv[i], (userptr_t)stackptr, sizeof(vaddr_t));
++++if(result)
++++{
++++return result;
++++}
++++}
++++
++++
++++
+++ 
+++ 	/* Warp to user mode. */
+++-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++++	enter_new_process(argc, (userptr_t)stackptr,
+++ 			  stackptr, entrypoint);
+++ 	
+++ 	/* enter_new_process does not return. */
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..851f9ea 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -40,6 +40,8 @@
+++ #include <current.h>
+++ #include <synch.h>
+++ 
++++#define MAXREADERS 20;
++++
+++ ////////////////////////////////////////////////////////////
+++ //
+++ // Semaphore.
+++@@ -162,9 +164,17 @@ lock_create(const char *name)
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
+++-        // add stuff here as needed
+++-        
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
+++         return lock;
+++ }
+++ 
+++@@ -175,6 +185,8 @@ lock_destroy(struct lock *lock)
+++ 
+++         // add stuff here as needed
+++         
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
+++         kfree(lock->lk_name);
+++         kfree(lock);
+++ }
+++@@ -183,26 +195,78 @@ void
+++ lock_acquire(struct lock *lock)
+++ {
+++         // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(&lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -225,7 +289,18 @@ cv_create(const char *name)
+++                 kfree(cv);
+++                 return NULL;
+++         }
+++-        
++++        cv->cv_wchan = wchan_create(cv->cv_name);
++++                	if (cv->cv_wchan == NULL) {
++++                		kfree(cv->cv_name);
++++                		kfree(cv);
++++                		return NULL;
++++                	}
++++
++++                	//spinlock_init(&cv->cv_lock);
++++                        //lock->hold = 0;
++++        		//lock->holder=NULL;
++++                //lock->=NULL
++++                return cv;
+++         // add stuff here as needed
+++         
+++         return cv;
+++@@ -238,6 +313,9 @@ cv_destroy(struct cv *cv)
+++ 
+++         // add stuff here as needed
+++         
++++        //spinlock_cleanup(&cv->cv_lock);
++++        
++++        wchan_destroy(cv->cv_wchan);
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++ }
+++@@ -245,23 +323,140 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	//KASSERT(lock_do_i_hold(lock));
++++	wchan_lock(cv->cv_wchan);
++++	lock_release(lock);
++++	
++++	wchan_sleep(cv->cv_wchan);
++++	lock_acquire(lock);
++++	
++++    // Write this
++++    //(void)cv;    // suppress warning until code gets written
++++    //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++         // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeone(cv->cv_wchan);
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv!=NULL);
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock_do_i_hold(lock));
++++	wchan_wakeall(cv->cv_wchan);
++++		
++++	
++++	//(void)cv;    // suppress warning until code gets written
++++	//(void)lock;  // suppress warning until code gets written
++++}
++++
++++struct rwlock *rwlock_create(const char *name)
++++{
++++	struct rwlock *rw;
++++	rw=kmalloc(sizeof(struct rwlock));
++++	if(rw==NULL)
++++	{
++++		return NULL;
++++	}
++++	rw->rwlock_name=kstrdup(name);
++++	if(rw->rwlock_name==NULL)
++++	{
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->rd_wchan=wchan_create(rw->rwlock_name);
++++	if(rw->rd_wchan==NULL)
++++	{
++++		kfree(rw->rwlock_name);
++++		kfree(rw);
++++		return NULL;
++++	}
++++	rw->wr_wchan=wchan_create(rw->rwlock_name);
++++		if(rw->wr_wchan==NULL)
++++		{
++++			kfree(rw->rwlock_name);
++++			kfree(rw);
++++			return NULL;
++++		}
++++		rw->rw_sem=sem_create("mysem",20);
++++		rw->rw_lock=lock_create("mylock");
++++	///rw->res_count=MAXREADERS;
++++	return rw;
++++	
++++}
++++void rwlock_destroy(struct rwlock *rw)
++++{
++++		KASSERT(rw != NULL);
++++		
++++		wchan_destroy(rw->rd_wchan);
++++		wchan_destroy(rw->wr_wchan);
++++		sem_destroy(rw->rw_sem);
++++		lock_destroy(rw->rw_lock);
++++	    kfree(rw->rwlock_name);
++++        kfree(rw);	
++++}
++++
++++void rwlock_acquire_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	P(rw->rw_sem);
++++	lock_release(rw->rw_lock);
++++}
++++void rwlock_release_read(struct rwlock *rw)
++++{
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	V(rw->rw_sem);
++++	//lock_release(rw->rw_lock);
++++}
++++void rwlock_acquire_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	lock_acquire(rw->rw_lock);
++++	//rwlock->rw_sem->V();
++++	for(i=0;i<20;i++)
++++	{
++++	P(rw->rw_sem);
++++	}	
++++	lock_release(rw->rw_lock);
++++	
++++	
+++ }
++++void rwlock_release_write(struct rwlock *rw)
++++{
++++	int i;
++++	KASSERT(rw!=NULL);
++++	//lock_acquire(rw->rw_lock);
++++	for(i=0;i<20;i++)
++++	{
++++	V(rw->rw_sem);
++++	}	
++++	//lock_release(rw->rw_lock);
++++	
++++}
++++
++++
++++
++++
++++
++++
++++
++++
++++
++++
+++diff --git a/kern/thread/synch.c~ b/kern/thread/synch.c~
+++new file mode 100644
+++index 0000000..b9680d1
+++--- /dev/null
++++++ b/kern/thread/synch.c~
+++@@ -0,0 +1,329 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++/*
++++ * Synchronization primitives.
++++ * The specifications of the functions are in synch.h.
++++ */
++++
++++#include <types.h>
++++#include <lib.h>
++++#include <spinlock.h>
++++#include <wchan.h>
++++#include <thread.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Semaphore.
++++
++++struct semaphore *
++++sem_create(const char *name, int initial_count)
++++{
++++        struct semaphore *sem;
++++
++++        KASSERT(initial_count >= 0);
++++
++++        sem = kmalloc(sizeof(struct semaphore));
++++        if (sem == NULL) {
++++                return NULL;
++++        }
++++
++++        sem->sem_name = kstrdup(name);
++++        if (sem->sem_name == NULL) {
++++                kfree(sem);
++++                return NULL;
++++        }
++++
++++	sem->sem_wchan = wchan_create(sem->sem_name);
++++	if (sem->sem_wchan == NULL) {
++++		kfree(sem->sem_name);
++++		kfree(sem);
++++		return NULL;
++++	}
++++
++++	spinlock_init(&sem->sem_lock);
++++        sem->sem_count = initial_count;
++++
++++        return sem;
++++}
++++
++++void
++++sem_destroy(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	/* wchan_cleanup will assert if anyone's waiting on it */
++++	spinlock_cleanup(&sem->sem_lock);
++++	wchan_destroy(sem->sem_wchan);
++++        kfree(sem->sem_name);
++++        kfree(sem);
++++}
++++
++++void 
++++P(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++        /*
++++         * May not block in an interrupt handler.
++++         *
++++         * For robustness, always check, even if we can actually
++++         * complete the P without blocking.
++++         */
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++        while (sem->sem_count == 0) {
++++		/*
++++		 * Bridge to the wchan lock, so if someone else comes
++++		 * along in V right this instant the wakeup can't go
++++		 * through on the wchan until we've finished going to
++++		 * sleep. Note that wchan_sleep unlocks the wchan.
++++		 *
++++		 * Note that we don't maintain strict FIFO ordering of
++++		 * threads going through the semaphore; that is, we
++++		 * might "get" it on the first try even if other
++++		 * threads are waiting. Apparently according to some
++++		 * textbooks semaphores must for some reason have
++++		 * strict ordering. Too bad. :-)
++++		 *
++++		 * Exercise: how would you implement strict FIFO
++++		 * ordering?
++++		 */
++++		wchan_lock(sem->sem_wchan);
++++		spinlock_release(&sem->sem_lock);
++++                wchan_sleep(sem->sem_wchan);
++++
++++		spinlock_acquire(&sem->sem_lock);
++++        }
++++        KASSERT(sem->sem_count > 0);
++++        sem->sem_count--;
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++void
++++V(struct semaphore *sem)
++++{
++++        KASSERT(sem != NULL);
++++
++++	spinlock_acquire(&sem->sem_lock);
++++
++++        sem->sem_count++;
++++        KASSERT(sem->sem_count > 0);
++++	wchan_wakeone(sem->sem_wchan);
++++
++++	spinlock_release(&sem->sem_lock);
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// Lock.
++++
++++struct lock *
++++lock_create(const char *name)
++++{
++++        struct lock *lock;
++++
++++        lock = kmalloc(sizeof(struct lock));
++++        if (lock == NULL) {
++++                return NULL;
++++        }
++++
++++        lock->lk_name = kstrdup(name);
++++        if (lock->lk_name == NULL) {
++++                kfree(lock);
++++                return NULL;
++++        }
++++        lock->mut_wchan = wchan_create(lock->lk_name);
++++        	if (lock->mut_wchan == NULL) {
++++        		kfree(lock->lk_name);
++++        		kfree(lock);
++++        		return NULL;
++++        	}
++++
++++        	spinlock_init(&lock->mut_lock);
++++                lock->hold = 0;
++++		lock->holder=NULL;
++++        //lock->=NULL
++++        return lock;
++++}
++++
++++void
++++lock_destroy(struct lock *lock)
++++{
++++        KASSERT(lock != NULL);
++++
++++        // add stuff here as needed
++++        
++++        spinlock_cleanup(&lock->mut_lock);
++++        	wchan_destroy(lock->mut_wchan);
++++        kfree(lock->lk_name);
++++        kfree(lock);
++++}
++++
++++void
++++lock_acquire(struct lock *lock)
++++{
++++        // Write this
++++KASSERT(lock!=NULL);
++++
++++
++++//KASSERT(sem != NULL);
++++
++++        
++++        KASSERT(curthread->t_in_interrupt == false);
++++
++++	spinlock_acquire(&lock->mut_lock);
++++        while (lock->hold ) {
++++		
++++		wchan_lock(lock->mut_wchan);
++++		spinlock_release(&lock->mut_lock);
++++                wchan_sleep(lock->mut_wchan);
++++
++++		spinlock_acquire(lock->mut_lock);
++++        }
++++        KASSERT(lock->hold ==0 );
++++        lock->hold=1;
++++	lock->holder=curthread;
++++        //sem->sem_count--;
++++	spinlock_release(&lock->mut_lock);
++++
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++lock_release(struct lock *lock)
++++{
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->hold);
++++	KASSERT(lock_do_i_hold(lock));
++++	spinlock_acquire(&lock->mut_lock);
++++	lock->hold=0;
++++	
++++	        //sem->sem_count++;
++++	        KASSERT(lock->hold == 0);
++++lock->holder=NULL;
++++		wchan_wakeone(lock->mut_wchan);
++++
++++		spinlock_release(&lock->mut_lock);
++++        // Write this
++++	/*
++++	
++++	KASSERT(lock!=NULL);
++++	KASSERT(lock->lockNeed==curthread);
++++	spinlock_acquire(&lock->lockNeed);
++++	lock->lockNeed==NULL;
++++	
++++	//thread_wakeup(lock);// wake a thread suppose it waits for the same lock.
++++	spinlock_release(&lock->lockNeed);
++++*/
++++        //(void)lock;  // suppress warning until code gets written
++++}
++++
++++bool
++++lock_do_i_hold(struct lock *lock)
++++{
++++        // Write this
++++	
++++
++++        //(void)lock;  // suppress warning until code gets written
++++	KASSERT(lock!=NULL);
++++	//spinlock_acquire(&lock->mut_lock);
++++	if(!lock->hold) return false;
++++if(lock->holder==curthread) return true;
++++else 
++++return false;
++++	
++++    //spinlock_release(&lock->mut_lock);
++++    
++++        //return res; // dummy until code gets written
++++}
++++
++++////////////////////////////////////////////////////////////
++++//
++++// CV
++++
++++
++++struct cv *
++++cv_create(const char *name)
++++{
++++        struct cv *cv;
++++
++++        cv = kmalloc(sizeof(struct cv));
++++        if (cv == NULL) {
++++                return NULL;
++++        }
++++
++++        cv->cv_name = kstrdup(name);
++++        if (cv->cv_name==NULL) {
++++                kfree(cv);
++++                return NULL;
++++        }
++++        
++++        // add stuff here as needed
++++        
++++        return cv;
++++}
++++
++++void
++++cv_destroy(struct cv *cv)
++++{
++++        KASSERT(cv != NULL);
++++
++++        // add stuff here as needed
++++        
++++        kfree(cv->cv_name);
++++        kfree(cv);
++++}
++++
++++void
++++cv_wait(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++        (void)cv;    // suppress warning until code gets written
++++        (void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_signal(struct cv *cv, struct lock *lock)
++++{
++++        // Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
++++
++++void
++++cv_broadcast(struct cv *cv, struct lock *lock)
++++{
++++	// Write this
++++	(void)cv;    // suppress warning until code gets written
++++	(void)lock;  // suppress warning until code gets written
++++}
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..df129b9 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <file.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -69,6 +70,8 @@ static struct cpuarray allcpus;
+++ 
+++ /* Used to wait for secondary CPUs to come online. */
+++ static struct semaphore *cpu_startup_sem;
++++pid_t pidcount;
++++struct process* p_table[17];
+++ 
+++ ////////////////////////////////////////////////////////////
+++ 
+++@@ -89,7 +92,7 @@ thread_checkstack_init(struct thread *thread)
+++ 
+++ /*
+++  * Check the magic number we put on the bottom end of the stack in
+++- * thread_checkstack_init. If these assertions go off, it most likely
++++ * thread_checkstack_init. If these KASSERTions go off, it most likely
+++  * means you overflowed your stack at some point, which can cause all
+++  * kinds of mysterious other things to happen.
+++  *
+++@@ -262,6 +265,8 @@ thread_destroy(struct thread *thread)
+++ 	/* sheer paranoia */
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
++++  KASSERT(thread->t_filetable == NULL);
++++
+++ 	kfree(thread->t_name);
+++ 	kfree(thread);
+++ }
+++@@ -352,8 +357,15 @@ thread_bootstrap(void)
+++ {
+++ 	struct cpu *bootcpu;
+++ 	struct thread *bootthread;
++++	int i;
+++ 
+++ 	cpuarray_init(&allcpus);
++++	pidcount=PID_MIN;
++++
++++	for(i=0;i<=16;i++)
++++	{
++++		p_table[i]=NULL;
++++	}
+++ 
+++ 	/*
+++ 	 * Create the cpu structure for the bootup CPU, the one we're
+++@@ -365,6 +377,7 @@ thread_bootstrap(void)
+++ 	 */
+++ 	bootcpu = cpu_create(0);
+++ 	bootthread = bootcpu->c_curthread;
++++	//bootthread->pid=PID_MIN;
+++ 
+++ 	/*
+++ 	 * Initializing curcpu and curthread is machine-dependent
+++@@ -519,7 +532,7 @@ thread_fork(const char *name,
+++ 	 * for the spllower() that will be done releasing it.
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++-
++++	//newthread->pid=pidcount++;
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -589,7 +602,6 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 	switch (newstate) {
+++ 	    case S_RUN:
+++ 		panic("Illegal S_RUN in thread_switch\n");
+++-		break;
+++ 	    case S_READY:
+++ 		thread_make_runnable(cur, true /*have lock*/);
+++ 		break;
+++@@ -799,6 +811,11 @@ thread_exit(void)
+++ 		VOP_DECREF(cur->t_cwd);
+++ 		cur->t_cwd = NULL;
+++ 	}
++++	
++++	if (curthread->t_filetable) {
++++		filetable_destroy(curthread->t_filetable);
++++		curthread->t_filetable = NULL;
++++	}
+++ 
+++ 	/* VM fields */
+++ 	if (cur->t_addrspace) {
+++diff --git a/single10.patch b/single10.patch
+++new file mode 100644
+++index 0000000..2267436
+++--- /dev/null
++++++ b/single10.patch
+++@@ -0,0 +1,915 @@
++++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++++index 0f773bd..68c73ff 100644
++++--- a/kern/arch/mips/syscall/syscall.c
+++++++ b/kern/arch/mips/syscall/syscall.c
++++@@ -32,6 +32,7 @@
++++ #include <kern/syscall.h>
++++ #include <lib.h>
++++ #include <mips/trapframe.h>
+++++#include <copyinout.h>
++++ #include <thread.h>
++++ #include <current.h>
++++ #include <syscall.h>
++++@@ -80,7 +81,10 @@ syscall(struct trapframe *tf)
++++ {
++++ 	int callno;
++++ 	int32_t retval;
+++++        int32_t retvalv1 = 0;
+++++        int64_t retval64;
++++ 	int err;
+++++        int32_t stackarg1;
++++ 
++++ 	KASSERT(curthread != NULL);
++++ 	KASSERT(curthread->t_curspl == 0);
++++@@ -108,6 +112,37 @@ syscall(struct trapframe *tf)
++++ 		err = sys___time((userptr_t)tf->tf_a0,
++++ 				 (userptr_t)tf->tf_a1);
++++ 		break;
+++++            case SYS_open:
+++++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_read:
+++++		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++			       &retval);
+++++		break;
+++++	    case SYS_write:
+++++		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, 
+++++				&retval);
+++++		break;
+++++	    case SYS_close:
+++++		err = sys_close(tf->tf_a0);
+++++		break;
+++++	    case SYS_lseek:
+++++                copyin((const_userptr_t) tf->tf_sp + 16, &stackarg1, sizeof(int32_t));
+++++                err = sys_lseek(tf->tf_a0, (off_t) ((off_t) tf->tf_a2 << 32 | (off_t) tf->tf_a3),
+++++                                stackarg1, &retval64);
+++++                retval = retval64 >> 32;
+++++                retvalv1 = (int) retval64;
+++++		break;
+++++	    case SYS_dup2:
+++++		err = sys_dup2(tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
+++++	    case SYS_chdir:
+++++		err = sys_chdir((userptr_t)tf->tf_a0);
+++++		break;
+++++	    case SYS___getcwd:
+++++		err = sys___getcwd((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+++++		break;
++++ 
++++ 	    /* Add stuff here */
++++  
++++@@ -130,6 +165,7 @@ syscall(struct trapframe *tf)
++++ 	else {
++++ 		/* Success. */
++++ 		tf->tf_v0 = retval;
+++++                tf->tf_v1 = retvalv1;
++++ 		tf->tf_a3 = 0;      /* signal no error */
++++ 	}
++++ 	
++++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++++index d527f61..e1d7682 100644
++++--- a/kern/conf/conf.kern
+++++++ b/kern/conf/conf.kern
++++@@ -367,6 +367,8 @@ file      vfs/devnull.c
++++ file      syscall/loadelf.c
++++ file      syscall/runprogram.c
++++ file      syscall/time_syscalls.c
+++++file      syscall/file_syscalls.c
+++++file      syscall/file.c
++++ 
++++ #
++++ # Startup and initialization
++++diff --git a/kern/include/file.h b/kern/include/file.h
++++new file mode 100644
++++index 0000000..2c63bc2
++++--- /dev/null
+++++++ b/kern/include/file.h
++++@@ -0,0 +1,59 @@
+++++/*
+++++ * Declarations for file handle and file table management.
+++++ * New for SOL2.
+++++ */
+++++
+++++#ifndef _FILE_H_
+++++#define _FILE_H_
+++++
+++++#include <limits.h>
+++++
+++++struct lock;
+++++struct vnode;
+++++
+++++/*** openfile section ***/
+++++
+++++/* 
+++++ * openfile struct 
+++++ * note that there's not too much to keep track of, since the vnode does most
+++++ * of that.  note that it does require synchronization, because a single
+++++ * openfile can be shared between processes (filetable inheritance).
+++++ */
+++++struct openfile {
+++++	struct vnode *of_vnode;
+++++	
+++++	struct lock *of_lock;
+++++	off_t of_offset;
+++++	int of_accmode;	/* from open: O_RDONLY, O_WRONLY, or O_RDWR */
+++++	int of_refcount;
+++++};
+++++
+++++/* opens a file (must be kernel pointers in the args) */
+++++int file_open(char *filename, int flags, int mode, int *retfd);
+++++
+++++/* closes a file */
+++++int file_close(int fd);
+++++
+++++
+++++/*** file table section ***/
+++++
+++++/*
+++++ * filetable struct
+++++ * just an array of open files.  nice and simple.  doesn't require
+++++ * synchronization, because a table can only be owned by a single process (on
+++++ * inheritance in fork, the table is copied).
+++++ */
+++++struct filetable {
+++++	struct openfile *ft_openfiles[OPEN_MAX];
+++++};
+++++
+++++/* these all have an implicit arg of the curthread's filetable */
+++++int filetable_init(const char *inpath, const char *outpath, 
+++++		   const char *errpath);
+++++int filetable_copy(struct filetable **copy);
+++++int filetable_placefile(struct openfile *file, int *fd);
+++++int filetable_findfile(int fd, struct openfile **file);
+++++int filetable_dup2file(int oldfd, int newfd);
+++++void filetable_destroy(struct filetable *ft);
+++++
+++++#endif /* _FILE_H_ */
++++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++++index befd3d8..f3a01ad 100644
++++--- a/kern/include/syscall.h
+++++++ b/kern/include/syscall.h
++++@@ -55,6 +55,15 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++++  * Prototypes for IN-KERNEL entry points for system call implementations.
++++  */
++++ 
+++++int sys_open(userptr_t filename, int flags, int mode, int *retval);
+++++int sys_read(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_write(int fd, userptr_t buf, size_t size, int *retval);
+++++int sys_close(int fd);
+++++int sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval);
+++++int sys_dup2(int oldfd, int newfd, int *retval);
+++++int sys_chdir(userptr_t path);
+++++int sys___getcwd(userptr_t buf, size_t buflen, int *retval);
+++++
++++ int sys_reboot(int code);
++++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++++ 
++++diff --git a/kern/include/thread.h b/kern/include/thread.h
++++index 86706ca..08b8f8c 100644
++++--- a/kern/include/thread.h
+++++++ b/kern/include/thread.h
++++@@ -112,6 +112,7 @@ struct thread {
++++ 	struct vnode *t_cwd;		/* current working directory */
++++ 
++++ 	/* add more here as needed */
+++++  struct filetable *t_filetable;
++++ };
++++ 
++++ /* Call once during system startup to allocate data structures. */
++++diff --git a/kern/include/uio.h b/kern/include/uio.h
++++index 5d97c48..c9124e8 100644
++++--- a/kern/include/uio.h
+++++++ b/kern/include/uio.h
++++@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
++++ void uio_kinit(struct iovec *, struct uio *,
++++ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++++ 
+++++void uio_uinit(struct iovec *, struct uio *,
+++++	       userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw);
+++++
++++ 
++++ #endif /* _UIO_H_ */
++++diff --git a/kern/lib/uio.c b/kern/lib/uio.c
++++index 594fe96..83ea620 100644
++++--- a/kern/lib/uio.c
+++++++ b/kern/lib/uio.c
++++@@ -153,6 +153,7 @@ void
++++ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++++ {
+++++	KASSERT(u);
++++ 	iov->iov_kbase = kbuf;
++++ 	iov->iov_len = len;
++++ 	u->uio_iov = iov;
++++@@ -163,3 +164,19 @@ uio_kinit(struct iovec *iov, struct uio *u,
++++ 	u->uio_rw = rw;
++++ 	u->uio_space = NULL;
++++ }
+++++
+++++void
+++++uio_uinit(struct iovec *iov, struct uio *u,
+++++    userptr_t ubuf, size_t len, off_t pos, enum uio_rw rw)
+++++{
+++++	KASSERT(u);
+++++	iov->iov_ubase = ubuf;
+++++	iov->iov_len = len;
+++++  u->uio_iov = iov;
+++++	u->uio_iovcnt = 1;
+++++	u->uio_offset = pos;
+++++	u->uio_resid = len;
+++++	u->uio_segflg = UIO_USERSPACE;
+++++	u->uio_rw = rw;
+++++	u->uio_space = curthread->t_addrspace;
+++++}
++++diff --git a/kern/syscall/file.c b/kern/syscall/file.c
++++new file mode 100644
++++index 0000000..dc5ffe5
++++--- /dev/null
+++++++ b/kern/syscall/file.c
++++@@ -0,0 +1,341 @@
+++++/*
+++++ * File handles and file tables.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++
+++++/*** openfile functions ***/
+++++
+++++/*
+++++ * file_open
+++++ * opens a file, places it in the filetable, sets RETFD to the file
+++++ * descriptor. the pointer arguments must be kernel pointers.
+++++ * NOTE -- the passed in filename must be a mutable string.
+++++ */
+++++int
+++++file_open(char *filename, int flags, int mode, int *retfd)
+++++{
+++++	struct vnode *vn;
+++++	struct openfile *file;
+++++	int result;
+++++	
+++++	result = vfs_open(filename, flags, mode, &vn);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	file = kmalloc(sizeof(struct openfile));
+++++	if (file == NULL) {
+++++		vfs_close(vn);
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* initialize the file struct */
+++++	file->of_lock = lock_create("file lock");
+++++	if (file->of_lock == NULL) {
+++++		vfs_close(vn);
+++++		kfree(file);
+++++		return ENOMEM;
+++++	}
+++++	file->of_vnode = vn;
+++++	file->of_offset = 0;
+++++	file->of_accmode = flags & O_ACCMODE;
+++++	file->of_refcount = 1;
+++++
+++++	/* vfs_open checks for invalid access modes */
+++++	KASSERT(file->of_accmode==O_RDONLY ||
+++++	        file->of_accmode==O_WRONLY ||
+++++	        file->of_accmode==O_RDWR);
+++++
+++++	/* place the file in the filetable, getting the file descriptor */
+++++	result = filetable_placefile(file, retfd);
+++++	if (result) {
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++		vfs_close(vn);
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * file_doclose
+++++ * shared code for file_close and filetable_destroy
+++++ */
+++++static
+++++int
+++++file_doclose(struct openfile *file)
+++++{
+++++	lock_acquire(file->of_lock);
+++++
+++++	/* if this is the last close of this file, free it up */
+++++	if (file->of_refcount == 1) {
+++++		vfs_close(file->of_vnode);
+++++		lock_release(file->of_lock);
+++++		lock_destroy(file->of_lock);
+++++		kfree(file);
+++++	}
+++++	else {
+++++		KASSERT(file->of_refcount > 1);
+++++		file->of_refcount--;
+++++		lock_release(file->of_lock);
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * file_close
+++++ * knock off the refcount, freeing the memory if it goes to 0.
+++++ */
+++++int
+++++file_close(int fd)
+++++{
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* find the file in the filetable */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	result = file_doclose(file);
+++++	if (result) {
+++++		/* leave file open for possible retry */
+++++		return result;
+++++	}
+++++	curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++
+++++	return 0;
+++++}
+++++
+++++/*** filetable functions ***/
+++++
+++++/* 
+++++ * filetable_init
+++++ * pretty straightforward -- allocate the space, initialize to NULL.
+++++ * note that the one careful thing is to open the std i/o in order to
+++++ * get
+++++ * stdin  == 0
+++++ * stdout == 1
+++++ * stderr == 2
+++++ */
+++++int
+++++filetable_init(const char *inpath, const char *outpath, const char *errpath)
+++++{
+++++	/* the filenames come from the kernel; assume reasonable length */
+++++	char path[32];
+++++	int result;
+++++	int fd;
+++++
+++++	/* make sure we can fit these */
+++++	KASSERT(strlen(inpath) < sizeof(path));
+++++	KASSERT(strlen(outpath) < sizeof(path));
+++++	KASSERT(strlen(errpath) < sizeof(path));
+++++	
+++++	/* catch memory leaks, repeated calls */
+++++	KASSERT(curthread->t_filetable == NULL);
+++++
+++++	curthread->t_filetable = kmalloc(sizeof(struct filetable));
+++++	if (curthread->t_filetable == NULL) {
+++++		return ENOMEM;
+++++	}
+++++	
+++++	/* NULL-out the table */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		curthread->t_filetable->ft_openfiles[fd] = NULL;
+++++	}
+++++
+++++	/*
+++++	 * open the std fds.  note that the names must be copied into
+++++	 * the path buffer so that they're mutable.
+++++	 */
+++++	strcpy(path, inpath);
+++++	result = file_open(path, O_RDONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, outpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	strcpy(path, errpath);
+++++	result = file_open(path, O_WRONLY, 0, &fd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_copy
+++++ * again, pretty straightforward.  the subtle business here is that instead of
+++++ * copying the openfile structure, we just increment the refcount.  this means
+++++ * that openfile structs will, in fact, be shared between processes, as in
+++++ * Unix.
+++++ */
+++++int
+++++filetable_copy(struct filetable **copy)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int fd;
+++++
+++++	/* waste of a call, really */
+++++	if (ft == NULL) {
+++++		*copy = NULL;
+++++		return 0;
+++++	}
+++++	
+++++	*copy = kmalloc(sizeof(struct filetable));
+++++	
+++++	if (*copy == NULL) {
+++++		return ENOMEM;
+++++	}
+++++
+++++	/* copy over the entries */
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd] != NULL) {
+++++			lock_acquire(ft->ft_openfiles[fd]->of_lock);
+++++			ft->ft_openfiles[fd]->of_refcount++;
+++++			lock_release(ft->ft_openfiles[fd]->of_lock);
+++++			(*copy)->ft_openfiles[fd] = ft->ft_openfiles[fd];
+++++		} 
+++++		else {
+++++			(*copy)->ft_openfiles[fd] = NULL;
+++++		}
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_destroy
+++++ * closes the files in the file table, frees the table.
+++++ */
+++++void
+++++filetable_destroy(struct filetable *ft)
+++++{
+++++	int fd, result;
+++++
+++++	KASSERT(ft != NULL);
+++++
+++++	for (fd = 0; fd < OPEN_MAX; fd++) {
+++++		if (ft->ft_openfiles[fd]) {
+++++			result = file_doclose(ft->ft_openfiles[fd]);
+++++			KASSERT(result==0);
+++++		}
+++++	}
+++++	
+++++	kfree(ft);
+++++}	
+++++
+++++/* 
+++++ * filetable_placefile
+++++ * finds the smallest available file descriptor, places the file at the point,
+++++ * sets FD to it.
+++++ */
+++++int
+++++filetable_placefile(struct openfile *file, int *fd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	int i;
+++++	
+++++	for (i = 0; i < OPEN_MAX; i++) {
+++++		if (ft->ft_openfiles[i] == NULL) {
+++++			ft->ft_openfiles[i] = file;
+++++			*fd = i;
+++++			return 0;
+++++		}
+++++	}
+++++
+++++	return EMFILE;
+++++}
+++++
+++++/*
+++++ * filetable_findfile
+++++ * verifies that the file descriptor is valid and actually references an
+++++ * open file, setting the FILE to the file at that index if it's there.
+++++ */
+++++int
+++++filetable_findfile(int fd, struct openfile **file)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++
+++++	if (fd < 0 || fd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++	
+++++	*file = ft->ft_openfiles[fd];
+++++	if (*file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * filetable_dup2file
+++++ * verifies that both file descriptors are valid, and that the OLDFD is
+++++ * actually an open file.  then, if the NEWFD is open, it closes it.
+++++ * finally, it sets the filetable entry at newfd, and ups its refcount.
+++++ */
+++++int
+++++filetable_dup2file(int oldfd, int newfd)
+++++{
+++++	struct filetable *ft = curthread->t_filetable;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	if (oldfd < 0 || oldfd >= OPEN_MAX || newfd < 0 || newfd >= OPEN_MAX) {
+++++		return EBADF;
+++++	}
+++++
+++++	file = ft->ft_openfiles[oldfd];
+++++	if (file == NULL) {
+++++		return EBADF;
+++++	}
+++++
+++++	/* dup2'ing an fd to itself automatically succeeds (BSD semantics) */
+++++	if (oldfd == newfd) {
+++++		return 0;
+++++	}
+++++
+++++	/* closes the newfd if it's open */
+++++	if (ft->ft_openfiles[newfd] != NULL) {
+++++		result = file_close(newfd);
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
+++++
+++++	/* up the refcount */
+++++	lock_acquire(file->of_lock);
+++++	file->of_refcount++;
+++++	lock_release(file->of_lock);
+++++
+++++	/* doesn't need to be synchronized because it's just changing the ft */
+++++	ft->ft_openfiles[newfd] = file;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++++new file mode 100644
++++index 0000000..8aa024c
++++--- /dev/null
+++++++ b/kern/syscall/file_syscalls.c
++++@@ -0,0 +1,270 @@
+++++/*
+++++ * File-related system call implementations.
+++++ * New for SOL2.
+++++ */
+++++
+++++#include <types.h>
+++++#include <kern/errno.h>
+++++#include <kern/limits.h>
+++++#include <kern/stat.h>
+++++#include <kern/unistd.h>
+++++#include <kern/fcntl.h>
+++++#include <kern/seek.h>
+++++#include <lib.h>
+++++#include <synch.h>
+++++#include <uio.h>
+++++#include <thread.h>
+++++#include <current.h>
+++++#include <vfs.h>
+++++#include <vnode.h>
+++++#include <file.h>
+++++#include <syscall.h>
+++++#include <copyinout.h>
+++++
+++++/*
+++++ * sys_open
+++++ * just copies in the filename, then passes work to file_open.
+++++ */
+++++int
+++++sys_open(userptr_t filename, int flags, int mode, int *retval)
+++++{
+++++	char fname[PATH_MAX];
+++++	int result;
+++++
+++++	result = copyinstr(filename, fname, sizeof(fname), NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return file_open(fname, flags, mode, retval);
+++++}
+++++
+++++/*
+++++ * sys_read
+++++ * translates the fd into its openfile, then calls VOP_READ.
+++++ */
+++++int
+++++sys_read(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	/* better be a valid file descriptor */
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_WRONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_READ);
+++++  
+++++  // mk_useruio(&useruio, buf, size, file->of_offset, UIO_READ);
+++++
+++++	/* does the read */
+++++	result = VOP_READ(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++	
+++++	/*
+++++	 * The amount read is the size of the buffer originally, minus
+++++	 * how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/*
+++++ * sys_write
+++++ * translates the fd into its openfile, then calls VOP_WRITE.
+++++ */
+++++int
+++++sys_write(int fd, userptr_t buf, size_t size, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++
+++++	if (file->of_accmode == O_RDONLY) {
+++++		lock_release(file->of_lock);
+++++		return EBADF;
+++++	}
+++++
+++++	/* set up a uio with the buffer, its size, and the current offset */
+++++  uio_uinit(&iov, &useruio, buf, size, file->of_offset, UIO_WRITE);
+++++	
+++++  //mk_useruio(&useruio, buf, size, file->of_offset, UIO_WRITE);
+++++
+++++	/* does the write */
+++++	result = VOP_WRITE(file->of_vnode, &useruio);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++
+++++	/* set the offset to the updated offset in the uio */
+++++	file->of_offset = useruio.uio_offset;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	/*
+++++	 * the amount written is the size of the buffer originally,
+++++	 * minus how much is left in it.
+++++	 */
+++++	*retval = size - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_close
+++++ * just pass off the work to file_close.
+++++ */
+++++int
+++++sys_close(int fd)
+++++{
+++++	return file_close(fd);
+++++}
+++++
+++++/*
+++++ * sys_lseek
+++++ * translates the fd into its openfile, then based on the type of seek,
+++++ * figure out the new offset, try the seek, if that succeeds, update the
+++++ * openfile.
+++++ */
+++++int
+++++sys_lseek(int fd, off_t offset, int32_t whence, off_t *retval)
+++++{
+++++	struct stat info;
+++++	struct openfile *file;
+++++	int result;
+++++
+++++	result = filetable_findfile(fd, &file);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	lock_acquire(file->of_lock);
+++++	
+++++	/* based on the type of seek, set the retval */ 
+++++	switch (whence) {
+++++	    case SEEK_SET:
+++++		*retval = offset;
+++++		break;
+++++	    case SEEK_CUR:
+++++		*retval = file->of_offset + offset;
+++++		break;
+++++	    case SEEK_END:
+++++		result = VOP_STAT(file->of_vnode, &info);
+++++		if (result) {
+++++			lock_release(file->of_lock);
+++++			return result;
+++++		}
+++++		*retval = info.st_size + offset;
+++++		break;
+++++	    default:
+++++		lock_release(file->of_lock);
+++++		return EINVAL;
+++++	}
+++++
+++++	/* try the seek -- if it fails, return */
+++++	result = VOP_TRYSEEK(file->of_vnode, *retval);
+++++	if (result) {
+++++		lock_release(file->of_lock);
+++++		return result;
+++++	}
+++++	
+++++	/* success -- update the file structure */
+++++	file->of_offset = *retval;
+++++
+++++	lock_release(file->of_lock);
+++++
+++++	return 0;
+++++}
+++++
+++++/* 
+++++ * sys_dup2
+++++ * just pass the work off to the filetable
+++++ */
+++++int
+++++sys_dup2(int oldfd, int newfd, int *retval)
+++++{
+++++	int result;
+++++
+++++	result = filetable_dup2file(oldfd, newfd);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = newfd;
+++++	return 0;
+++++}
+++++
+++++/* really not "file" calls, per se, but might as well put it here */
+++++
+++++/*
+++++ * sys_chdir
+++++ * copyin the path and pass it off to vfs.
+++++ */
+++++int
+++++sys_chdir(userptr_t path)
+++++{
+++++	char pathbuf[PATH_MAX];
+++++	int result;
+++++	
+++++	result = copyinstr(path, pathbuf, PATH_MAX, NULL);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	return vfs_chdir(pathbuf);
+++++}
+++++
+++++/*
+++++ * sys___getcwd
+++++ * just use vfs_getcwd.
+++++ */
+++++int
+++++sys___getcwd(userptr_t buf, size_t buflen, int *retval)
+++++{
+++++  struct iovec iov;
+++++	struct uio useruio;
+++++	int result;
+++++  
+++++  uio_uinit(&iov, &useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	// mk_useruio(&useruio, buf, buflen, 0, UIO_READ);
+++++
+++++	result = vfs_getcwd(&useruio);
+++++	if (result) {
+++++		return result;
+++++	}
+++++
+++++	*retval = buflen - useruio.uio_resid;
+++++
+++++	return 0;
+++++}
++++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++++index a6f45c8..4ba181a 100644
++++--- a/kern/syscall/runprogram.c
+++++++ b/kern/syscall/runprogram.c
++++@@ -44,6 +44,7 @@
++++ #include <vfs.h>
++++ #include <syscall.h>
++++ #include <test.h>
+++++#include <file.h>
++++ 
++++ /*
++++  * Load program "progname" and start running it in usermode.
++++@@ -66,6 +67,13 @@ runprogram(char *progname)
++++ 
++++ 	/* We should be a new thread. */
++++ 	KASSERT(curthread->t_addrspace == NULL);
+++++	
+++++  if (curthread->t_filetable == NULL) {
+++++		result = filetable_init("con:", "con:", "con:");
+++++		if (result) {
+++++			return result;
+++++		}
+++++	}
++++ 
++++ 	/* Create a new address sp
++\ No newline at end of file
++diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
++index 287a678..db31b89 100644
++--- a/user/testbin/badcall/bad_execv.c
+++++ b/user/testbin/badcall/bad_execv.c
++@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
++ 		return;
++ 	}
++ 
+++
++ 	rv = execv("/bin/true", args);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	exit(MAGIC_STATUS);
++diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
++index 809c68c..8eb69c3 100644
++--- a/user/testbin/badcall/bad_waitpid.c
+++++ b/user/testbin/badcall/bad_waitpid.c
++@@ -36,6 +36,7 @@
++ #include <unistd.h>
++ #include <errno.h>
++ #include <err.h>
+++#include<stdio.h>
++ 
++ #include "config.h"
++ #include "test.h"
++@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Hello:%d",(int)ptr);
++ 
++ 	rv = waitpid(pid, ptr, 0);
++ 	report_test(rv, errno, EFAULT, desc);
++ 	waitpid(pid, &x, 0);
++ }
++ 
+++
++ static
++ void
++ wait_unaligned(void)
++@@ -85,13 +88,16 @@ wait_unaligned(void)
++ 	if (pid==0) {
++ 		exit(0);
++ 	}
+++	//printf("Aligned int:%d",&status);
++ 
++ 	/* start with proper integer alignment */
++ 	ptr = (char *)(&status[0]);
++-
+++	//printf("Aligned:%c\n",*ptr);
++ 	/* generate improper alignment on platforms with restrictions*/
++ 	ptr++;
++ 
+++	//Print("UnAligned:%c\n",*ptr);
+++
++ 	rv = waitpid(pid, (int *)ptr, 0);
++ 	report_survival(rv, errno, "wait with unaligned status");
++ 	if (rv<0) {
++diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
++new file mode 100644
++index 0000000..fe21882
++--- /dev/null
+++++ b/user/testbin/myforktest/Makefile
++@@ -0,0 +1,11 @@
+++# Makefile for forktest
+++
+++TOP=../../..
+++.include "$(TOP)/mk/os161.config.mk"
+++
+++PROG=myforktest
+++SRCS=myforktest.c
+++BINDIR=/testbin
+++
+++.include "$(TOP)/mk/os161.prog.mk"
+++
++diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
++new file mode 100644
++index 0000000..7bd6663
++--- /dev/null
+++++ b/user/testbin/myforktest/myforktest.c
++@@ -0,0 +1,33 @@
+++#include <unistd.h>
+++#include <string.h>
+++#include <stdlib.h>
+++#include <stdio.h>
+++#include <err.h>
+++
+++int main()
+++{
+++	int status;
+++	int pid;
+++	int childpid;
+++	int parent;
+++	int returnCode=fork();
+++
+++	if(returnCode==0)
+++	{
+++		childpid=getpid();
+++		printf("I am child:%d\n",childpid);
+++		return -10;
+++	}
+++	else
+++	{
+++		//printf("Return:%d",returnCode);
+++		//printf("Wait for child\n");
+++		parent=getpid();
+++		printf("I am parent:%d\n",parent);
+++		pid=waitpid(returnCode,&status,0);
+++		printf("Child id returned" "%d",pid);
+++		printf(" Return code: %d\n",status);
+++
+++	}
+++	return 0;
+++}
+diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
+index 287a678..db31b89 100644
+--- a/user/testbin/badcall/bad_execv.c
++++ b/user/testbin/badcall/bad_execv.c
+@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
+ 		return;
+ 	}
+ 
++
+ 	rv = execv("/bin/true", args);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	exit(MAGIC_STATUS);
+diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
+index 809c68c..8eb69c3 100644
+--- a/user/testbin/badcall/bad_waitpid.c
++++ b/user/testbin/badcall/bad_waitpid.c
+@@ -36,6 +36,7 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <err.h>
++#include<stdio.h>
+ 
+ #include "config.h"
+ #include "test.h"
+@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Hello:%d",(int)ptr);
+ 
+ 	rv = waitpid(pid, ptr, 0);
+ 	report_test(rv, errno, EFAULT, desc);
+ 	waitpid(pid, &x, 0);
+ }
+ 
++
+ static
+ void
+ wait_unaligned(void)
+@@ -85,13 +88,16 @@ wait_unaligned(void)
+ 	if (pid==0) {
+ 		exit(0);
+ 	}
++	//printf("Aligned int:%d",&status);
+ 
+ 	/* start with proper integer alignment */
+ 	ptr = (char *)(&status[0]);
+-
++	//printf("Aligned:%c\n",*ptr);
+ 	/* generate improper alignment on platforms with restrictions*/
+ 	ptr++;
+ 
++	//Print("UnAligned:%c\n",*ptr);
++
+ 	rv = waitpid(pid, (int *)ptr, 0);
+ 	report_survival(rv, errno, "wait with unaligned status");
+ 	if (rv<0) {
+diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
+new file mode 100644
+index 0000000..fe21882
+--- /dev/null
++++ b/user/testbin/myforktest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=myforktest
++SRCS=myforktest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
+new file mode 100644
+index 0000000..7bd6663
+--- /dev/null
++++ b/user/testbin/myforktest/myforktest.c
+@@ -0,0 +1,33 @@
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++int main()
++{
++	int status;
++	int pid;
++	int childpid;
++	int parent;
++	int returnCode=fork();
++
++	if(returnCode==0)
++	{
++		childpid=getpid();
++		printf("I am child:%d\n",childpid);
++		return -10;
++	}
++	else
++	{
++		//printf("Return:%d",returnCode);
++		//printf("Wait for child\n");
++		parent=getpid();
++		printf("I am parent:%d\n",parent);
++		pid=waitpid(returnCode,&status,0);
++		printf("Child id returned" "%d",pid);
++		printf(" Return code: %d\n",status);
++
++	}
++	return 0;
++}
diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
index 287a678..db31b89 100644
--- a/user/testbin/badcall/bad_execv.c
+++ b/user/testbin/badcall/bad_execv.c
@@ -114,6 +114,7 @@ exec_badargs(void *args, const char *desc)
 		return;
 	}
 
+
 	rv = execv("/bin/true", args);
 	report_test(rv, errno, EFAULT, desc);
 	exit(MAGIC_STATUS);
diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
index 809c68c..8eb69c3 100644
--- a/user/testbin/badcall/bad_waitpid.c
+++ b/user/testbin/badcall/bad_waitpid.c
@@ -36,6 +36,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <err.h>
+#include<stdio.h>
 
 #include "config.h"
 #include "test.h"
@@ -63,12 +64,14 @@ wait_badstatus(void *ptr, const char *desc)
 	if (pid==0) {
 		exit(0);
 	}
+	//printf("Hello:%d",(int)ptr);
 
 	rv = waitpid(pid, ptr, 0);
 	report_test(rv, errno, EFAULT, desc);
 	waitpid(pid, &x, 0);
 }
 
+
 static
 void
 wait_unaligned(void)
@@ -85,13 +88,16 @@ wait_unaligned(void)
 	if (pid==0) {
 		exit(0);
 	}
+	//printf("Aligned int:%d",&status);
 
 	/* start with proper integer alignment */
 	ptr = (char *)(&status[0]);
-
+	//printf("Aligned:%c\n",*ptr);
 	/* generate improper alignment on platforms with restrictions*/
 	ptr++;
 
+	//Print("UnAligned:%c\n",*ptr);
+
 	rv = waitpid(pid, (int *)ptr, 0);
 	report_survival(rv, errno, "wait with unaligned status");
 	if (rv<0) {
diff --git a/user/testbin/forkbomb/forkbomb.c b/user/testbin/forkbomb/forkbomb.c
index 880027c..1e9b5cc 100644
--- a/user/testbin/forkbomb/forkbomb.c
+++ b/user/testbin/forkbomb/forkbomb.c
@@ -49,7 +49,7 @@
 
 #include <unistd.h>
 #include <err.h>
-
+#include<stdio.h>
 static volatile int pid;
 
 int
@@ -61,11 +61,12 @@ main()
 		fork();
 
 		pid = getpid();
-
+		//printf("First:%d\n",pid);
 		/* Make sure each fork has its own address space. */
 		for (i=0; i<300; i++) {
 			volatile int seenpid;
 			seenpid = pid;
+			//printf("Second:%d\n",seenpid);
 			if (seenpid != getpid()) {
 				errx(1, "pid mismatch (%d, should be %d) "
 				     "- your vm is broken!", 
diff --git a/user/testbin/myforktest/Makefile b/user/testbin/myforktest/Makefile
new file mode 100644
index 0000000..fe21882
--- /dev/null
+++ b/user/testbin/myforktest/Makefile
@@ -0,0 +1,11 @@
+# Makefile for forktest
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=myforktest
+SRCS=myforktest.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/myforktest/myforktest.c b/user/testbin/myforktest/myforktest.c
new file mode 100644
index 0000000..7bd6663
--- /dev/null
+++ b/user/testbin/myforktest/myforktest.c
@@ -0,0 +1,33 @@
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <err.h>
+
+int main()
+{
+	int status;
+	int pid;
+	int childpid;
+	int parent;
+	int returnCode=fork();
+
+	if(returnCode==0)
+	{
+		childpid=getpid();
+		printf("I am child:%d\n",childpid);
+		return -10;
+	}
+	else
+	{
+		//printf("Return:%d",returnCode);
+		//printf("Wait for child\n");
+		parent=getpid();
+		printf("I am parent:%d\n",parent);
+		pid=waitpid(returnCode,&status,0);
+		printf("Child id returned" "%d",pid);
+		printf(" Return code: %d\n",status);
+
+	}
+	return 0;
+}
